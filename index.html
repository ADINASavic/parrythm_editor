<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8">
<title>Rhythm Chart Editor (Absolute 1920×1080)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- (필수) JSZip 로드 -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<style>
  :root{--bg:#0f1115;--panel:#171b27;--muted:#8a94aa;--text:#e6e9f2;--accent:#66d9ef;--ok:#6ee7b7;--warn:#fbbf24;--bad:#f87171;--line:#26304a;}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,Segoe UI,Apple SD Gothic Neo,Malgun Gothic,sans-serif}
  header{padding:12px 16px;border-bottom:1px solid var(--line);background:#0b0d12;position:sticky;top:0;z-index:5}
  header h1{margin:0;font-size:16px}
  .wrap{display:grid;grid-template-columns:340px 1fr;gap:12px;padding:12px}
  .card{background:var(--panel);border:1px solid var(--line);border-radius:10px;padding:12px}
  .row{display:flex;gap:8px;align-items:center;margin:6px 0}
  .row label{width:130px;color:var(--muted)}
  input[type="number"],input[type="text"],select{width:100%;background:#0e1220;color:var(--text);border:1px solid #273047;border-radius:8px;padding:8px}
  button{background:#1b2235;color:#e9ecf5;border:1px solid #2d3653;border-radius:8px;padding:8px 10px;cursor:pointer}
  button.primary{background:#163a4a;border-color:#265a6d;color:#dff6ff}
  button.warn{background:#3a2a13;border-color:#6e4f1a;color:#ffd48a}
  button.bad{background:#3a1616;border-color:#6e1c1c;color:#ffd2d2}
  button:disabled{opacity:.5;cursor:not-allowed}
  .grid{display:grid;grid-template-columns:repeat(3,1fr);grid-auto-rows:80px;gap:6px}
  .cell{background:#0e1220;border:1px dashed #2a314a;border-radius:8px;display:flex;align-items:center;justify-content:center;cursor:pointer}
  .cell.active{outline:2px solid var(--accent)}
  .canvasWrap{display:flex;gap:12px;flex-wrap:wrap}
  /* 캔버스는 반드시 클릭을 받는다 */
  #view { pointer-events: auto; display:block; }
  /* 혹시 뷰 상단에 떠 있는 디버그 배지/오버레이가 있다면 */
  #dbgBadge { pointer-events: none; }

  canvas{background:#0b0f1c;border:1px solid #233;border-radius:8px}
  table{width:100%;border-collapse:collapse;margin-top:8px}
  th,td{border-bottom:1px solid var(--line);padding:8px;font-size:13px}
  th{color:#a5b0c6;text-align:left}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;font-size:11px;border:1px solid #2d3653;color:#b9c2d9}
  .muted{color:var(--muted)}
  .hint{font-size:12px;color:#9aa4bb;margin-top:4px}
  .editbar{display:none;gap:8px;align-items:center;margin:10px 0;padding:8px;border-radius:8px;background:#112033;border:1px solid #264463}
  .editbar.active{display:flex}
  .editrow{background:rgba(102,217,239,0.08)}
  .fullrow{grid-column:1 / -1}
  .wave-toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .timebadge{font-variant-numeric:tabular-nums}
  .sep{width:1px;height:22px;background:#2d3653;margin:0 4px}
  .mini{width:auto}
  #orderToolbar{gap:8px;align-items:center;margin:6px 0}
  .two{display:grid;grid-template-columns:1fr 1fr;gap:8px}
</style>
</head>
<body>
<header><h1>Rhythm Chart Editor (Absolute 1920×1080)</h1></header>

<div class="wrap">
  <!-- 왼쪽 패널 -->
  <section class="card">

    <hr style="border:none;border-top:1px solid var(--line);margin:10px 0">
    <h3 style="margin:4px 0 8px">Add/Edit Note</h3>
    <div class="row"><label>Type</label>
      <select id="noteType">
        <option value="Grid">Grid</option>
        <option value="CircleTap">CircleTap</option>
        <option value="Slider">Slider</option>
        <option value="Bullet">Bullet</option>
        <option value="Camera">Camera</option>
      </select>
    </div>

    <!-- Grid -->
    <div id="gridInputs">
      <div class="hint">오른쪽 3x3 Grid를 클릭해도 설정됩니다.</div>
      <div class="row"><label>Cell (c,r)</label><input id="cellCR" type="text" value="1,1"></div>
      <div class="row"><label>Time (sec)</label><input id="judgeTimeSec" type="number" step="0.001" value="1.000"></div>
      <div class="row"><label>Time (beats)</label><input id="judgeBeat" type="number" step="0.001" value="1.000"></div>
      <button id="btnAddGrid" class="primary" onclick="addGrid()">Add Grid</button>
    </div>

    <!-- Circle -->
    <div id="circleInputs" style="display:none">
      <div class="hint">Absolute 캔버스를 클릭해 좌표를 잡을 수 있습니다. (1920×1080)</div>
      <div class="row"><label>Pos (x,y)</label><input id="circlePos" type="text" value="960,540"></div>
      <div class="row"><label>Time (sec)</label><input id="circleJudgeSec" type="number" step="0.001" value="1.000"></div>
      <div class="row"><label>Time (beats)</label><input id="circleJudgeBeat" type="number" step="0.001" value="1.000"></div>
      <button id="btnAddCircle" class="primary" onclick="addCircle()">Add CircleTap</button>
    </div>

    <!-- Slider -->
    <div id="sliderInputs" style="display:none">
      <div class="hint">Absolute 캔버스에서 점을 찍어 경로를 만듭니다. 숫자로도 수정 가능.</div>
      <div class="row"><label>Start (sec)</label><input id="sliderStartSec" type="number" step="0.001" value="2.000"></div>
      <div class="row"><label>Start (beats)</label><input id="sliderStartBeat" type="number" step="0.001" value="2.000"></div>
      <div class="row"><label>Duration (sec)</label><input id="sliderDurSec" type="number" step="0.001" value="0.800"></div>
      <div class="row"><label>Duration (beats)</label><input id="sliderDurBeats" type="number" step="0.001" value="0.800"></div>
      <div class="row two">
        <div><label>Point Index</label><input id="ptIndex" type="number" value="0" step="1"></div>
        <div><label>Point (x,y)</label><input id="ptXY" type="text" value="960,540"></div>
      </div>
      <div class="row" style="gap:6px;flex-wrap:wrap">
        <button onclick="finishPath()">Finish Path</button>
        <button class="warn" onclick="clearPath()">Clear Path</button>
        <button onclick="applyPointXY()">Set Point XY</button>
        <button onclick="insertPointAfter()">Insert After</button>
        <button class="bad" onclick="removePoint()">Remove Point</button>
        <span class="hint">Path pts: <span id="pathCount">0</span></span>
        <div class="row" style="align-items:flex-start">
        <label>Points</label>
        <div style="flex:1">
            <div id="sliderPointList"
                style="max-height:160px;overflow:auto;border:1px solid #2d3653;border-radius:8px;padding:6px;font-size:12px"></div>
            <div style="display:flex;gap:6px;margin-top:6px">
            <button type="button" id="ptPrevBtn">Prev (PgUp)</button>
            <button type="button" id="ptNextBtn">Next (PgDn)</button>
            <span class="muted" style="margin-left:auto">Keys: ← → ↑ ↓ (Shift=20px), PgUp/PgDn, Enter=Apply</span>
            </div>
        </div>
        </div>
      </div>
      <div class="hint">키보드: Arrow = 선택 점 미세이동 (기본 5px, Shift=20px)</div>
      <button id="btnAddSlider" class="primary" onclick="addSlider()">Add Slider</button>
    </div>

    <!-- Bullet -->
    <div id="bulletInputs" style="display:none">
      <div class="row"><label>Spawn (x,y)</label><input id="bulletSpawn" type="text" value="192,540"></div>
      <div class="row"><label>Dock (x,y)</label><input id="bulletDock" type="text" value="960,540"></div>
      <div class="row"><label>Despawn (x,y)</label><input id="bulletDespawn" type="text" value="1728,540"></div>
      <div class="row"><label>Start (sec)</label><input id="bulletStartSec" type="number" step="0.001" value="3.000"></div>
      <div class="row"><label>Start (beats)</label><input id="bulletStartBeat" type="number" step="0.001" value="3.000"></div>
      <div class="row"><label>ToDock (sec)</label><input id="bulletToDockSec" type="number" step="0.001" value="1.000"></div>
      <div class="row"><label>ToDock (beats)</label><input id="bulletToDockBeats" type="number" step="0.001" value="1.000"></div>
      <div class="row"><label>DockToDespawn (sec)</label><input id="bulletDockToDespawnSec" type="number" step="0.001" value="1.000"></div>
      <div class="row"><label>DockToDespawn (beats)</label><input id="bulletDockToDespawnBeats" type="number" step="0.001" value="1.000"></div>
      <div class="row"><label>Canvas click target</label>
        <select id="bulletClickTarget">
          <option value="spawn">Spawn</option>
          <option value="dock">Dock</option>
          <option value="despawn">Despawn</option>
        </select>
      </div>
      <div class="row">
        <label class="mini">
          <input id="bullet3Click" type="checkbox" checked>
          3-Click 배치 (Spawn→Dock→Despawn)
        </label>
        <label class="mini" style="margin-left:12px">
          <input id="bulletAutoAdd" type="checkbox">
          3점 완료 시 자동 Add
        </label>
      </div>
      <div class="hint">
        <span id="bulletStageLabel">Stage: Spawn을 클릭하세요</span>
      </div>
      <button id="btnAddBullet" class="primary" onclick="addBullet()">Add Bullet</button>
      <div class="hint">Absolute 캔버스 클릭으로 선택된 target 좌표를 세팅할 수 있습니다.</div>
    </div>

    <!-- [CAMERA] -->
<div id="cameraInputs" style="display:none">
  <div class="hint">카메라 트윈: 절대 높이(px) / 각도(도) / 센터(px). 비트/초 중 원하는 축만 체크.</div>

  <div class="row two">
    <div><label>Start (sec)</label><input id="camStartSec" type="number" step="0.001" value="5.000"></div>
    <div><label>Duration (sec)</label><input id="camDurSec" type="number" step="0.001" value="0.500"></div>
  </div>
  <div class="row two">
    <div><label>Start (beats)</label><input id="camStartBeat" type="number" step="0.001" value="0.000"></div>
    <div><label>Duration (beats)</label><input id="camDurBeats" type="number" step="0.001" value="0.000"></div>
  </div>

  <div class="row"><label class="mini"><input id="camAffectHeight" type="checkbox" checked> Height(px)</label>
    <input id="camHeightPx" type="number" step="1" value="720">
  </div>
  <div class="row"><label class="mini"><input id="camAffectAngle" type="checkbox"> AngleZ(deg)</label>
    <input id="camAngleDegZ" type="number" step="0.1" value="0">
  </div>
  <div class="row"><label class="mini"><input id="camAffectCenter" type="checkbox"> Center (x,y)</label>
    <input id="camCenterPx" type="text" value="960,540">
  </div>

  <div class="row two">
    <div><label>Ease</label>
      <select id="camEase">
        <option value="">(default)</option>
        <option>linear</option>
        <option>easeInOut</option>
        <option>quadInOut</option>
      </select>
    </div>
    <div style="display:flex;gap:10px;align-items:center">
      <label class="mini"><input id="camUseBeats" type="checkbox"> Use Beats</label>
      <label class="mini"><input id="camUseUIScaling" type="checkbox"> UI Scaling</label>
    </div>
  </div>

  <button id="btnAddCamera" class="primary" onclick="addCamera()">Add Camera</button>
</div>


    <div id="editBar" class="editbar">
      <span class="pill">Editing <span id="editLabel" style="font-weight:700"></span></span>
      <button class="primary" onclick="saveEdit()">Save</button>
      <button class="warn" onclick="cancelEdit()">Cancel</button>
    </div>

        <h3 style="margin:4px 0 8px">Chart</h3>
    <div class="row"><label>FMOD Event</label>
  <input id="fmodEvent" type="text" placeholder="event:/your/path/here">
</div>
    <div class="row"><label>Title</label><input id="title" type="text" value="New Chart"></div>
    <div class="row"><label>BPM</label><input id="bpm" type="number" value="120" step="0.01"></div>
    <div class="row"><label>Time Mode</label>
      <select id="timeMode"><option value="Seconds">Seconds</option><option value="Beats">Beats</option></select>
    </div>
<div class="row"><label>Song Duration (sec)</label>
  <input id="durationSec" type="number" value="0" step="0.001">
</div>

    <div class="row"><label>Start Offset (sec)</label><input id="startOffsetSec" type="number" value="0" step="0.001"></div>
    <div class="row"><label>Start Offset (beats)</label><input id="startOffsetBeats" type="number" value="0" step="0.001"></div>
    <div class="row"><label>Artist</label><input id="artist" type="text" value="Unknown"></div>
  <div class="row"><label>Preview Start</label><input id="previewStart" type="number" value="5.0" step="0.01"></div>
  <div class="row"><label>Preview Duration</label><input id="previewDuration" type="number" value="10.0" step="0.01"></div>
  <div class="row"><label>Tags (comma)</label><input id="tags" type="text" value="demo"></div>
  <div class="row"><label>Cover</label><input id="coverFile" type="file" accept="image/*"></div>

    <hr style="border:none;border-top:1px solid var(--line);margin:10px 0">
    <h3 style="margin:4px 0 8px">Spawn Calc Settings</h3>
    <div class="row"><label>Circle Lead (s)</label><input id="circleLead" type="number" step="0.001" value="1.2"></div>
    <div class="row"><label>Slider Lead (s)</label><input id="sliderLead" type="number" step="0.001" value="1.0"></div>
    <div class="row"><label>Grid Target Size</label><input id="gridTarget" type="number" step="0.001" value="216"></div>
    <div class="row"><label>Grid Grow Speed</label><input id="gridGrow" type="number" step="0.001" value="324"></div>
    <div class="hint">Grid spawn = judge - (targetSize / growSpeed), Circle = judge - circleLead, Slider = start - sliderLead</div>
    <div class="row"><label>Grid Grow Unit</label>
  <select id="gridGrowUnit">
    <option value="pxps" selected>px/sec</option>
    <option value="pxpbeat">px/beat</option>
  </select>
</div>
<div class="row"><label>Circle Lead (beats)</label>
  <input id="circleLeadBeats" type="number" step="0.001" value="0.0">
</div>
<div class="row"><label>Slider Lead (beats)</label>
  <input id="sliderLeadBeats" type="number" step="0.001" value="0.0">
</div>

<!-- Grid 타깃을 픽셀/간격 모드로 선택 -->
<div class="row"><label>Grid Target Mode</label>
  <select id="gridTargetMode">
    <option value="px" selected>Absolute px</option>
    <option value="spacingX">Touch centers (Horizontal)</option>
    <option value="spacingY">Touch centers (Vertical)</option>
  </select>
</div>

<!-- Bullet 크기 설정 (지름 px) -->
<div class="row"><label>Bullet Size (px, diameter)</label>
  <input id="bulletSize" type="number" step="1" value="64">
</div>



    <!-- [ADD] Circle/Slider/Bullet 시뮬 크기 설정 -->
    <div class="row"><label>Circle Target (radius px)</label><input id="circleTargetRadius" type="number" step="1" value="100"></div> <!-- [ADD] -->


    <hr style="border:none;border-top:1px solid var(--line);margin:10px 0">
    <div class="row" style="gap:6px">
      <button onclick="downloadJSON()" class="primary">Download JSON</button>
      <button onclick="exportSongZip()" class="primary">Export Song Folder (.zip)</button>
      <label class="pill">LevelChart (schemaVersion=2)</label>
    </div>
    <div class="row" style="gap:6px">
      <input id="importFile" type="file" accept=".json">
      <button class="bad" onclick="clearAll()">Clear All</button>
    </div>
  </section>

  <!-- 오른쪽 작업영역 -->
  <section class="card">
    <h3 style="margin:4px 0 12px">Workspace</h3>
    <div class="canvasWrap">
      <div>
        <div class="row" style="margin-top:0"><span class="pill">3x3 Grid</span></div>
        <div id="grid" class="grid"></div>
      </div>

      <div style="min-width:460px">
        <div class="row" style="margin-top:0;justify-content:space-between;align-items:center">
          <span class="pill">Absolute (1920×1080)</span>
          <div style="display:flex;gap:8px;align-items:center">
            <label class="mini">Aspect
              <select id="aspect">
                <option value="1">1:1</option>
                <option value="1.7777777778" selected>16:9</option>
              </select>
            </label>
            <label class="mini" style="display:flex;gap:6px;align-items:center">
              <input id="showCamFrame" type="checkbox" checked>
              Cam Frame
            </label>
            <span class="muted">Click: set pos / path / bullet point</span>
          </div>
        </div>
        <canvas id="view" width="440" height="440"></canvas>
      </div>
    </div>

      <section class="card fullrow">
    <h3 style="margin:4px 0 12px">Audio Reference (Waveform & Beat Grid)</h3>
    <div class="wave-toolbar">
      <input id="audioFile" type="file" accept="audio/*">
      <button id="playBtn" disabled>Play</button>
      <button id="pauseBtn" disabled>Pause</button>
      <span class="pill timebadge">Time: <span id="curTime">0.000</span> / <span id="durTime">0.000</span> s</span>
      <span class="pill timebadge">Beat: <span id="curBeat">-</span></span>
      <span class="sep"></span>
      <label class="mini">Subdivision
        <select id="subdiv">
          <option value="4">1/4</option>
          <option value="8" selected>1/8</option>
          <option value="16">1/16</option>
        </select>
      </label>
      <label class="mini">Speed
  <select id="playbackRate">
    <option value="0.25">0.25×</option>
    <option value="0.5">0.5×</option>
    <option value="1" selected>1.0×</option>
    <option value="1.5">1.5×</option>
    <option value="2">2.0×</option>
  </select>
</label>

      <label class="mini"><input id="snap" type="checkbox" checked> Snap</label>
      <span class="sep"></span>
      <button id="zoomInBtn" disabled>Zoom+</button>
      <button id="zoomOutBtn" disabled>Zoom-</button>
      <button id="fitBtn" disabled>Fit</button>
      <span class="sep"></span>
      <label class="mini">Amp <input id="ampScale" type="range" min="0.2" max="1.0" value="0.6" step="0.05"></label>
      <span class="muted">Click: seek/set time / Drag: pan / Shift+Drag: select / Ctrl+Wheel: zoom</span>
    </div>
    <div style="margin-top:8px">
      <canvas id="wave" height="140" style="width:100%"></canvas>
      <audio id="audio" style="display:none" preload="metadata" crossorigin="anonymous"></audio>
    </div>
  </section>
</div>

    <div class="row" id="orderToolbar">
      <span class="pill">Order</span>
      <button onclick="sortByCreation()">By Creation</button>
      <button onclick="sortByTimeSec()">By Time (sec)</button>
      <button onclick="sortByTimeBeats()">By Time (beats)</button>
      <button onclick="sortBySpawn()">By Spawn</button>
      <button class="primary" onclick="reindexNotes()">Reindex</button>
      <span class="muted">Tip: drag table rows to reorder</span>
    </div>

    <h4 style="margin:8px 0 6px">Notes</h4>
    <table id="notesTable">
      <thead>
        <tr>
          <th>#</th><th>Type</th><th>Data</th><th>Time</th><th>Spawn(s)</th><th></th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <!-- 파형/재생/박자 -->


<script>

const WAVE_ROW_H   = 18; // 서브레인 한 칸 높이
const WAVE_ROW_GAP = 4;
const WAVE_TYPES = ["Grid","CircleTap","Slider","Bullet","Camera"];
let waveBlocks = [];     // [{x,y,w,h, idx, type, row, t0,t1}]

const GRID_LEFT   = 648;
const GRID_RIGHT  = 1296;            // inclusive boundary for area end
const GRID_TOP    = 216;
const GRID_BOTTOM = 1080 - 216;      // 864
const GRID_W = GRID_RIGHT - GRID_LEFT;   // 648
const GRID_H = GRID_BOTTOM - GRID_TOP;   // 648
const GRID_CELL = GRID_W / 3;      

const $ = s => document.querySelector(s);

/* ---------- 절대좌표 기준 ---------- */
const REF_W = 1920;
const REF_H = 1080;

/* ---------- 상태 ---------- */

window.onerror = (msg, src, line, col, err) => {
  console.groupCollapsed("[onerror]", msg);
  console.log("src", src, "line", line, "col", col);
  console.error(err);
  console.groupEnd();
};
window.onunhandledrejection = (e) => {
  console.groupCollapsed("[unhandledrejection]");
  console.error(e.reason || e);
  console.groupEnd();
};

let DBG = true; // 필요시 false
function dlog(tag, obj){ if(!DBG) return; console.log(`[DBG] ${tag}`, obj||""); }

// 화면 우상단에 디버그 배지
(function(){
  const div = document.createElement("div");
  div.id = "dbgBadge";
  div.style.cssText = "position:fixed;right:8px;top:8px;z-index:9999;background:#111a30;color:#cfe4ff;border:1px solid #264463;border-radius:6px;padding:6px 8px;font:12px/1.2 system-ui;white-space:pre;";
  div.textContent = "dbg: init…";
  document.addEventListener("DOMContentLoaded", ()=> document.body.appendChild(div));
})();
function setDbg(text){
  const el = document.getElementById("dbgBadge");
  if (el) el.textContent = text;
}

function snapshotState(extra={}){
  const span = (viewEnd - viewStart);
  return {
    span, viewStart, viewEnd,
    audioEl_dur: audioEl?.duration || 0,
    AC_buf_dur: (typeof AC_buf !== "undefined" && AC_buf) ? AC_buf.duration : 0,
    audioBuffer_dur: audioBuffer?.duration || 0,
    audioEl_ct: audioEl?.currentTime || 0,
    nowAccurate: (typeof getNowAccurate === "function") ? getNowAccurate() : null,
    isPanning, dragSelecting,
    ...extra
  };
}



let chart = {
  schemaVersion: 2,
  title:"New Chart", bpm:120, timeMode:"Seconds",
  startOffset:0, startOffsetBeats:0,
  notes:[]
};
let selectedCell = {c:1,r:1};
let circlePosAbs = {x:REF_W/2,y:REF_H/2};
let pathPtsAbs = []; let pathFinished = false;
let editIndex = null; let editType = null;
let aspect = 1.7777777778;
// Bullet 3-Click 상태
let bulletStage = 0; // 0:spawn, 1:dock, 2:despawn
let bulletTemp = { spawn:null, dock:null, despawn:null };

/* ---------- 좌측 입력 바인딩 ---------- */
$("#title").addEventListener("input", e=> chart.title = e.target.value );
$("#bpm").addEventListener("input", e=> { chart.bpm = num(e.target.value); redrawBeat(); });
$("#timeMode").addEventListener("change", e=> { chart.timeMode = e.target.value; redrawBeat(); });
$("#startOffsetSec").addEventListener("input", e=> { chart.startOffset = num(e.target.value); redrawBeat(); });
$("#startOffsetBeats").addEventListener("input", e=> { chart.startOffsetBeats = num(e.target.value); redrawBeat(); });

$("#noteType").addEventListener("change", e=>{
  const t = e.target.value;
  $("#gridInputs").style.display   = (t==="Grid") ? "block":"none";
  $("#circleInputs").style.display = (t==="CircleTap") ? "block":"none";
  $("#sliderInputs").style.display = (t==="Slider") ? "block":"none";
  $("#bulletInputs").style.display = (t==="Bullet") ? "block":"none";
  $("#cameraInputs").style.display = (t==="Camera") ? "block":"none";
  refreshAddButtons();
});

/* ---------- Grid UI ---------- */
const gridEl = $("#grid");
function buildGrid(){
  gridEl.innerHTML = "";
  for(let ui_r=0;ui_r<3;ui_r++){
    for(let c=0;c<3;c++){
      const r = 2 - ui_r;
      const div = document.createElement("div");
      div.className = "cell";
      div.textContent = `${c},${r}`;
      div.addEventListener("click", ()=>{
        selectedCell = {c,r};
        $("#cellCR").value = `${c},${r}`;
        refreshGridActive();
      });
      gridEl.appendChild(div);
    }
  }
  $("#cellCR").value = "1,1";
  refreshGridActive();
}
function refreshGridActive(){
  [...gridEl.children].forEach((el,i)=>{
    const c = i%3, ui_r = Math.floor(i/3), r = 2-ui_r;
    el.classList.toggle("active", c===selectedCell.c && r===selectedCell.r);
    el.textContent = `${c},${r}`;
  });
}

/* ---------- Viewport ---------- */
const view = $("#view"); const ctx = view.getContext("2d");
$("#aspect").addEventListener("change", e=>{ aspect = parseFloat(e.target.value)||1; drawView(); });

function getAR(){
  const w=view.width,h=view.height,t=aspect;
  let cw=Math.min(w,h*t), ch=cw/t;
  if(ch>h){ch=h;cw=ch*t}
  return {x:(w-cw)/2,y:(h-ch)/2,w:cw,h:ch};
}
// absolute → canvas pixel
function toCXabs(p){
  const ar=getAR();
  return {
    x: ar.x + (p.x/REF_W) * ar.w,
    y: ar.y + (1 - (p.y/REF_H)) * ar.h
  };
}
// canvas pixel → absolute
function fromCXabs(mx,my){
  const ar=getAR();
  const nx = clamp((mx - ar.x) / ar.w, 0, 1);
  const ny = clamp(1 - (my - ar.y) / ar.h, 0, 1);
  return { x: nx * REF_W, y: ny * REF_H };
}

// ... 기존 변수/함수 선언들 위·아래 상관없이 동일 스코프에 들어가면 됨

// 안전: 캔버스가 꼭 클릭을 받도록
view.style.pointerEvents = 'auto';
view.tabIndex = 0;

// 클릭/터치 모두 커버
view.addEventListener("pointerdown", onViewPointerDown, {passive:true});

function onViewPointerDown(e){
  if (!view) return;
  const rect = view.getBoundingClientRect();
  // DPR 보정 (width/height는 devicePixel 크기)
  const sx = (rect.width  > 0) ? (view.width  / rect.width)  : 1;
  const sy = (rect.height > 0) ? (view.height / rect.height) : 1;
  const mx = (e.clientX - rect.left) * sx;
  const my = (e.clientY - rect.top)  * sy;

  const ar = getAR();
  // AR 영역 밖 클릭은 무시 (의도치 않은 가장자리 클릭 방지)
  if (mx < ar.x || mx > ar.x + ar.w || my < ar.y || my > ar.y + ar.h) return;

  const p = fromCXabs(mx, my);           // 절대 좌표(1920x1080)
  const t = $("#noteType").value;

  // 디버그 배지에 마지막 클릭 정보 표시 (유용)
  setDbg(`click: ${t}\nabs=(${Math.round(p.x)},${Math.round(p.y)})`);

  if (t === "CircleTap"){
    circlePosAbs = p;
    $("#circlePos").value = `${Math.round(p.x)},${Math.round(p.y)}`;
    drawView();
    return;
  }

  if (t === "Slider"){
    // pathFinished 상태면 추가 클릭이 막히므로, 편집 시작 시 자동 해제 옵션
  if (pathFinished && (pathPtsAbs?.length ?? 0) >= 2){
    // 기존 경로 비우고 새로 시작
    pathPtsAbs = [];
    pathFinished = false;
  }
    if (!pathPtsAbs) pathPtsAbs = [];
    pathPtsAbs.push({x:p.x, y:p.y});
    $("#pathCount").textContent = String(pathPtsAbs.length);
    renderPointList();
    drawView();
    return;
  }

  if (t === "Bullet"){
    const three = $("#bullet3Click").checked;
    if (three){
      if (bulletStage === 0){
        bulletTemp.spawn = p;
        $("#bulletSpawn").value = `${Math.round(p.x)},${Math.round(p.y)}`;
        bulletStage = 1;
      } else if (bulletStage === 1){
        bulletTemp.dock = p;
        $("#bulletDock").value = `${Math.round(p.x)},${Math.round(p.y)}`;
        bulletStage = 2;
      } else {
        bulletTemp.despawn = p;
        $("#bulletDespawn").value = `${Math.round(p.x)},${Math.round(p.y)}`;
        bulletStage = 0;
        if ($("#bulletAutoAdd").checked){
          addBullet();
          bulletTemp = { spawn:null, dock:null, despawn:null };
        }
      }
    } else {
      const target = $("#bulletClickTarget").value;
      const s = `${Math.round(p.x)},${Math.round(p.y)}`;
      if      (target === "spawn")   $("#bulletSpawn").value   = s;
      else if (target === "dock")    $("#bulletDock").value    = s;
      else if (target === "despawn") $("#bulletDespawn").value = s;
    }
    updateBulletStageLabel();
    drawView();
    return;
  }
}



function drawView(){
  const w=view.width,h=view.height; ctx.clearRect(0,0,w,h);
  ctx.fillStyle="#0b0f1c"; ctx.fillRect(0,0,w,h);
  const ar=getAR(); ctx.fillStyle="#0c1324"; ctx.fillRect(ar.x,ar.y,ar.w,ar.h);
  ctx.strokeStyle="#233"; ctx.strokeRect(ar.x+0.5,ar.y+0.5,ar.w-1,ar.h-1);
  // grid lines (4×4 보조)
  ctx.strokeStyle="#1e2744"; ctx.lineWidth=1;
  for(let i=1;i<4;i++){
    const x=ar.x+i*ar.w/4, y=ar.y+i*ar.h/4;
    ctx.beginPath();ctx.moveTo(x,ar.y);ctx.lineTo(x,ar.y+ar.h);ctx.stroke();
    ctx.beginPath();ctx.moveTo(ar.x,y);ctx.lineTo(ar.x+ar.w,y);ctx.stroke();
  }
  // slider path (editing preview)
  if(pathPtsAbs.length){
    ctx.strokeStyle="#6ee7b7"; ctx.lineWidth=2; ctx.beginPath();
    let p0=toCXabs(pathPtsAbs[0]); ctx.moveTo(p0.x,p0.y);
    for(let i=1;i<pathPtsAbs.length;i++){ const p=toCXabs(pathPtsAbs[i]); ctx.lineTo(p.x,p.y); }
    ctx.stroke();
  }

  // [ADD] 인게임 “지금만” 시뮬 미리보기
  drawIngamePreview(getPreviewNowSec());
  drawCameraFrame(getPreviewNowSec());
  drawGridOverlay();
}

/* ---------- [ADD] Ingame Preview helpers ---------- */
function lerp(a,b,t){ return a + (b - a) * t; }
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function within(t,a,b,pad=0){ return t >= (a - pad) && t <= (b + pad); }
// c: 0~2 (왼→오), r: 0~2 (아래=0, 위=2)  ← 기존 인덱싱을 유지
function cellToAbsPos(c, r) {
  const centerX = GRID_LEFT + GRID_CELL * (0.5 + c);        // 648 + 108 + 216*c → 756, 972, 1188
  const centerY = GRID_TOP  + GRID_CELL * (0.5 + (2 - r));  // r=2(위): 324, r=1: 540, r=0: 756
  return { x: centerX, y: centerY };
}
// 교체: px 그대로 받고 내부에서만 스케일
function drawCircleAbs(ctx, abs, radiusPx, stroke="#fff", fill=null, lineW=2){
  const p = toCXabs(abs);
  const s = (getAR().w / REF_W);
  ctx.save();
  ctx.lineWidth = lineW;
  ctx.strokeStyle = stroke;
  if (fill) ctx.fillStyle = fill;
  ctx.beginPath();
  ctx.arc(p.x, p.y, Math.max(0.5, radiusPx * s), 0, Math.PI*2);
  if (fill) ctx.fill();
  ctx.stroke();
  ctx.restore();
}

// 교체: sizePx 그대로 받고 내부에서만 스케일
function drawRectAbs(ctx, centerAbs, sizePx, stroke="#fff", fill=null, lineW=2, radius=8){
  const p = toCXabs(centerAbs);
  const s = (getAR().w / REF_W);
  const w = sizePx * s, h = sizePx * s;
  const x = p.x - w/2, y = p.y - h/2;
  const r = Math.min(radius*s, Math.min(w,h)/2);
  ctx.save();
  ctx.lineWidth = lineW;
  ctx.strokeStyle = stroke;
  if (fill) ctx.fillStyle = fill;
  if (r>0){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,  x+w,y+h, r);
    ctx.arcTo(x+w,y+h,x,  y+h, r);
    ctx.arcTo(x,  y+h,x,  y,   r);
    ctx.arcTo(x,  y,  x+w,y,   r);
    ctx.closePath();
    if (fill) ctx.fill();
    ctx.stroke();
  }else{
    if (fill) ctx.fillRect(x,y,w,h);
    ctx.strokeRect(x,y,w,h);
  }
  ctx.restore();
}

function drawLineAbs(ctx, aAbs, bAbs, stroke="#fff", lineW=2, dash=null){
  const a=toCXabs(aAbs), b=toCXabs(bAbs);
  ctx.save();
  ctx.lineWidth=lineW; ctx.strokeStyle=stroke; if(dash) ctx.setLineDash(dash);
  ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
  ctx.restore();
}
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function polyLengths(pts){ const L=[0]; let acc=0; for(let i=1;i<pts.length;i++){ acc+=dist(pts[i-1],pts[i]); L.push(acc);} return { total:acc, prefix:L }; }
function pointOnPolyline(pts, ratio){
  if(!pts || pts.length===0) return {x:0,y:0};
  if(pts.length===1) return pts[0];
  const { total, prefix } = polyLengths(pts);
  const target = total * clamp01(ratio);
  let i=1; while(i<prefix.length && prefix[i] < target) i++;
  const i0 = Math.max(1, i);
  const segStart = pts[i0-1], segEnd = pts[i0];
  const segBase = prefix[i0-1], segLen = Math.max(1e-6, prefix[i0]-prefix[i0-1]);
  const t = (target - segBase) / segLen;
  return { x: lerp(segStart.x, segEnd.x, t), y: lerp(segStart.y, segEnd.y, t) };
}
function getPreviewNowSec(){
  // 오디오가 로드되어 있고 재생·정지 상관없이 currentTime이 유효하면 그것을 사용
  if (window.audio && isFinite(audio.currentTime) && (audio.duration||0) > 0) {
    return audio.currentTime;
  }
  // 아니면 파형/스크럽에서 관리하는 커서값(없다면 0)
  const t = parseFloat(document.querySelector("#timeScrub")?.value || "0");
  return isFinite(t) ? t : 0;
}


// 교체: drawIngamePreview 내부 Grid/Circle/Slider/Bullet 분기
function drawIngamePreview(nowSec){
  const s = (getAR().w / REF_W);

  const gridTargetPx = resolveGridTargetPx();
  const gridGrowSec  = resolveGridGrowPxPerSec();        // px/s
  const gridLeadSec  = gridTargetPx / gridGrowSec;       // s

  const circleLeadSec = resolveCircleLeadSec();
  const sliderLeadSec = resolveSliderLeadSec();
  const circleR       = Math.max(1, num($("#circleTargetRadius").value));
  drawCameraBadges(nowSec);
  for (const n of chart.notes){

    // --- GRID: 사각형, 서로 "중앙에서" 맞닿도록 모드 선택 ---
    if (n.type === "Grid"){
      const tJ = getNoteTimeSec(n), tS = tJ - gridLeadSec;
      if (nowSec < tS-0.2 || nowSec > tJ+0.2) continue;

      const pos  = cellToAbsPos(n.cell.x, n.cell.y);
      const size = clamp((nowSec - tS) * gridGrowSec, 0, gridTargetPx); // px
      drawRectAbs(ctx, pos, size, "#6ee7b7", null, 3*s, 8);
      drawRectAbs(ctx, pos, gridTargetPx, "rgba(110,231,183,0.35)", null, 1.5*s, 8);
      if (Math.abs(nowSec - tJ) < 0.05){
        drawRectAbs(ctx, pos, gridTargetPx*1.06, "#66d9ef", "rgba(102,217,239,0.1)", 3*s, 10);
      }
    }

    // --- CIRCLE: 반지름(px) 기준, 접근 링 → 판정 ---
    else if (n.type === "CircleTap"){
      const tJ = getNoteTimeSec(n), tS = tJ - circleLeadSec;
      if (nowSec < tS-0.2 || nowSec > tJ+0.2) continue;

      const pos  = n.absPos || {x:REF_W/2,y:REF_H/2};
      const prog = clamp((nowSec - tS)/Math.max(1e-6, circleLeadSec), 0, 1);
      const ringR = lerp(circleR*1.6, circleR, prog);

      drawCircleAbs(ctx, pos, ringR,   "#fbbf24", null, 2*s);
      drawCircleAbs(ctx, pos, circleR, "#6ee7b7", "rgba(110,231,183,0.12)", 2*s);
      if (Math.abs(nowSec - tJ) < 0.05){
        drawCircleAbs(ctx, pos, circleR*1.12, "#66d9ef", "rgba(102,217,239,0.08)", 3*s);
      }
    }

    // --- SLIDER: 리드 동안 헤드 고정 → 시작 이후 진행, 헤드 크기 = Circle과 동일 ---
    else if (n.type === "Slider"){
      const pts = n.absPath || [];
      if (pts.length < 2) continue;

      const durSec = getSliderDurationSec(n);
      const tStart = getSliderStartSec(n);
      const tEnd   = tStart + durSec;
      const tSpawn = tStart - sliderLeadSec;
      if (nowSec < tSpawn-0.2 || nowSec > tEnd+0.2) continue;

      // 전체 경로(옅게)
      ctx.save(); ctx.lineWidth=4*s; ctx.strokeStyle="rgba(185,194,217,0.25)";
      const p0 = toCXabs(pts[0]); ctx.beginPath(); ctx.moveTo(p0.x,p0.y);
      for (let i=1;i<pts.length;i++){ const p=toCXabs(pts[i]); ctx.lineTo(p.x,p.y); }
      ctx.stroke(); ctx.restore();

           if (nowSec < tStart) {
       const head0 = pts[0];
       const leadDur = Math.max(1e-6, sliderLeadSec);
       const progLead = clamp((nowSec - tSpawn) / leadDur, 0, 1); // 0→1
      const ringR   = lerp(circleR * 1.8, circleR, progLead);    // 큰 원 → 타깃 반경
       // 바깥(접근) 링
       drawCircleAbs(ctx, head0, ringR,   "rgba(251,191,36,0.85)", null, 2*s);
       // 타깃(정박) 링 희미하게
       drawCircleAbs(ctx, head0, circleR, "rgba(110,231,183,0.7)", "rgba(110,231,183,0.10)", 2*s);
     }



           // === [NEW] 리드(접근) 구간: 테두리가 "다가오는" 효과 ===


      let head = pts[0];
      if (nowSec >= tStart){
        const r = clamp((nowSec - tStart)/Math.max(1e-6, durSec), 0, 1);
        head = pointOnPolyline(pts, r);

        // 진행 강조
        const { total, prefix } = polyLengths(pts);
        const target = total * r;
        ctx.save(); ctx.lineWidth=6*s; ctx.strokeStyle="#6ee7b7"; ctx.beginPath(); let moved=false;
        for (let i=1;i<pts.length;i++){
          const a=pts[i-1], b=pts[i], segS=prefix[i-1], segE=prefix[i];
          const aC=toCXabs(a), bC=toCXabs(b);
          if (segE <= target){ if(!moved){ ctx.moveTo(aC.x,aC.y); moved=true; } ctx.lineTo(bC.x,bC.y); }
          else if (segS < target && segE > target){
            const t=(target-segS)/Math.max(1e-6, segE-segS);
            const mid={x:lerp(a.x,b.x,t), y:lerp(a.y,b.y,t)}, midC=toCXabs(mid);
            if(!moved){ ctx.moveTo(aC.x,aC.y); moved=true; } ctx.lineTo(midC.x,midC.y); break;
          }
        }
        ctx.stroke(); ctx.restore();
      }
      // 헤드(리드 중엔 시작점 고정, 시작 후엔 진행 위치). 크기 = circleR
      drawCircleAbs(ctx, head, circleR, "#66d9ef", "rgba(102,217,239,0.25)", 3*s);
    }

    // --- BULLET: 크기 설정 가능(기본 64px 지름) ---
    else if (n.type === "Bullet"){
        const t0 = getBulletSpawnSec(n);
          const toDock = getBulletToDockSec(n);
  const dockToDespawn = getBulletDockToDespawnSec(n);
  const t1 = t0 + toDock;
  const t2 = t1 + dockToDespawn;
      if (nowSec < t0-0.2 || nowSec > t2+0.2) continue;
      const S=n.bulletSpawnPos, D=n.bulletDockPos, E=n.bulletDespawnPos;

      const bulletDiameter = Math.max(1, num($("#bulletSize")?.value || "64")); // px
      const bulletR = bulletDiameter * 0.5;

      drawLineAbs(ctx,S,D,"rgba(217,188,90,0.25)",2*s,[6,6]);
      drawLineAbs(ctx,D,E,"rgba(217,188,90,0.18)",2*s,[6,6]);

      let cur;
      if (nowSec < t1){
        const r=clamp((nowSec - t0)/Math.max(1e-6,t1-t0),0,1);
        cur = { x: lerp(S.x,D.x,r), y: lerp(S.y,D.y,r) };
      } else {
        const r=clamp((nowSec - t1)/Math.max(1e-6,t2-t1),0,1);
        cur = { x: lerp(D.x,E.x,r), y: lerp(D.y,E.y,r) };
      }
      drawCircleAbs(ctx, cur, bulletR, "#fbbf24", "rgba(251,191,36,0.25)", 2*s);
      if (Math.abs(nowSec - t1) < 0.05){
        drawCircleAbs(ctx, D, bulletR*1.3, "#ffd48a", "rgba(255,212,138,0.15)", 3*s);
      }
    }
  }
}

// 정확 모드면 WebAudio 시계, 아니면 HTMLAudio 시계
function nowSec(){
  return (AC_enabled && AC_buf && AC_src)
    ? getNowAccurate()
    : (audioEl.currentTime || 0);
}

function nowSecQms(){
  const t = nowSec();
  return (typeof qms === "function") ? qms(t) : t;
}


function getCameraDurSec(n){
  const byBeats = $("#timeMode").value === "Beats";
  if (byBeats) return (isFinite(n.durationBeats) ? beatsToSec(n.durationBeats) : (n.duration||0));
  return (isFinite(n.duration) ? n.duration : (isFinite(n.durationBeats) ? beatsToSec(n.durationBeats) : 0));
}



function noteTimeWindowSec(n){
  if(n.type==="Camera"){
    const t0 = getCameraStartSec(n);
    const d  = Math.max(0, getCameraDurSec(n));
    const span = Math.max(d, 0.02); // 최소 폭
    return { t0, t1: t0 + span };
  }
  if(n.type==="Slider"){
    const t0 = getSliderStartSec(n);
    const d  = Math.max(0, getSliderDurationSec(n));
    return {t0, t1: t0 + d};
  }
  if(n.type==="Bullet"){
    const t0 = getBulletSpawnSec(n);
    const t1 = t0 + getBulletToDockSec(n) + getBulletDockToDespawnSec(n);
    return {t0, t1};
  }
  // Grid / CircleTap : 한 점 → 화면에서 보이도록 최소폭 부여
  const t = getNoteTimeSec(n); // 기존 함수 그대로 사용
  const span = Math.max( (viewEnd-viewStart)||1, 1e-3 );
  const minPx = 6; // 최소 시각화 폭(px)
  const minSec = (minPx / (waveCanvas.clientWidth||1)) * span;
  return {t0: t, t1: t + minSec};
}
 function drawNoteBlocks(){
   waveBlocks = [];
   const lanesTop = 6;
   const allByType = Object.fromEntries(WAVE_TYPES.map(t=>[t,[]]));
   // 1) 수집 (보이는 구간만)
   chart.notes.forEach((n, idx)=>{
     const {t0,t1} = noteTimeWindowSec(n);
     const a = Math.max(t0, viewStart), b = Math.min(t1, viewEnd);
     if(b <= a) return;
     const x0 = timeToX(a), x1=timeToX(b);
     allByType[n.type||"Grid"].push({ x0, x1, idx, type:n.type||"Grid", t0:a, t1:b });
   });
  // 2) 타입별 패킹 (행수 계산)
  const packedByType = {};
   const rowsByType   = {};
  for(const t of WAVE_TYPES){
     const { placed, rowCount } = packIntoRows(allByType[t]);
     packedByType[t] = placed;
     rowsByType[t]   = rowCount;
   }
   // 3) 타입별 베이스 Y (최대 행 고려해서 밴드 높이 확보)
   let yCursor = lanesTop;
   const baseYByType = {};
   for(const t of WAVE_TYPES){
     baseYByType[t] = yCursor;
     const rows = Math.max(1, rowsByType[t]||0);
     yCursor += rows * (WAVE_ROW_H + WAVE_ROW_GAP) + 6; // 타입 간 추가 간격
   }
   // 4) 그리기 & waveBlocks 적재
   for(const t of WAVE_TYPES){
     const items = packedByType[t] || [];
     for(const it of items){
       const rowY = baseYByType[t] + it.row * (WAVE_ROW_H + WAVE_ROW_GAP);
       const w    = Math.max(2, it.x1 - it.x0);
       // 색상
       let fill="rgba(102,217,239,0.18)", stroke="#66d9ef";
       if(t==="Grid"){ fill="rgba(110,231,183,0.20)"; stroke="#6ee7b7"; }
       if(t==="CircleTap"){ fill="rgba(66,180,255,0.20)"; stroke="#44aaff"; }
       if(t==="Slider"){ fill="rgba(102,217,239,0.22)"; stroke="#66d9ef"; }
       if(t==="Bullet"){ fill="rgba(251,191,36,0.24)"; stroke="#fbbf24"; }
       if(t==="Camera"){ fill="rgba(147,197,253,0.20)"; stroke="#93c5fd"; }
       // 박스
       wctx.save();
       wctx.fillStyle = fill;
       wctx.strokeStyle = stroke;
       wctx.lineWidth = 1;
       wctx.fillRect(it.x0, rowY, w, WAVE_ROW_H);
       wctx.strokeRect(it.x0+0.5, rowY+0.5, w-1, WAVE_ROW_H-1);
       // 라벨
       const label = `#${it.idx+1} ${t}`;
       wctx.fillStyle = "#dfe7ff";
       wctx.font = "12px system-ui, sans-serif";
       wctx.fillText(label, it.x0+4, rowY + WAVE_ROW_H - 5);
       wctx.restore();
       waveBlocks.push({ x:it.x0, y:rowY, w, h:WAVE_ROW_H, idx:it.idx, type:t, row:it.row, t0:it.t0, t1:it.t1 });
     }
   }
 }

function beatsToSec(b){ return b * spb(); }

function strokeRectAbs(ctx, x0, y0, x1, y1, stroke="#2d3653", lineW=1){
  const a = toCXabs({x:x0,y:y0});
  const b = toCXabs({x:x1,y:y1});
  const x = Math.min(a.x,b.x), y = Math.min(a.y,b.y);
  const w = Math.abs(a.x-b.x), h = Math.abs(a.y-b.y);
  ctx.save();
  ctx.lineWidth = lineW;
  ctx.strokeStyle = stroke;
  ctx.strokeRect(x+0.5, y+0.5, Math.max(0,w-1), Math.max(0,h-1));
  ctx.restore();
}

function drawGridOverlay(){
  // 외곽 테두리
  strokeRectAbs(ctx, GRID_LEFT, GRID_TOP, GRID_RIGHT, GRID_BOTTOM, "#3a4a6a", 2);

  // 셀 경계선 (수직 2개, 수평 2개)
  for(let i=1;i<3;i++){
    const x = GRID_LEFT + GRID_CELL * i;
    drawLineAbs(ctx, {x, y:GRID_TOP}, {x, y:GRID_BOTTOM}, "#273a59", 1);
    const y = GRID_TOP + GRID_CELL * i;
    drawLineAbs(ctx, {x:GRID_LEFT, y}, {x:GRID_RIGHT, y}, "#273a59", 1);
  }

  // 셀 라벨 (c,r) — (0,0)=왼아래 ~ (2,2)=오른위
  ctx.save();
  ctx.font = "12px system-ui, sans-serif";
  ctx.fillStyle = "#9fb3d9";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  for(let r=0;r<3;r++){
    for(let c=0;c<3;c++){
      const p = cellToAbsPos(c, r);
      const pc = toCXabs(p);
      ctx.fillText(`${c},${r}`, pc.x, pc.y);
    }
  }
  ctx.restore();
}


function getSliderStartSec(n){
  return chartTimeToPlaybackSec({ sec: n.startTime, beat: n.startBeat });
}
function getSliderDurationSec(n){
  // 지속시간은 오프셋과 무관 → mode 우선순위만 유지
  const byBeats = ($("#timeMode").value === "Beats");
  if (byBeats) return isFinite(n.durationBeats) ? beatsToSec(n.durationBeats) : (n.duration || 0);
  return isFinite(n.duration) ? n.duration : (isFinite(n.durationBeats) ? beatsToSec(n.durationBeats) : 0);
}

// 불릿 구간도 동일하게 초로 환산
function getBulletSpawnSec(n){
  return chartTimeToPlaybackSec({ sec: n.bulletSpawnTime, beat: n.bulletSpawnBeat });
}
function getBulletToDockSec(n){
  const byBeats = $("#timeMode").value === "Beats";
  if (byBeats) return (isFinite(n.bulletToDockBeats) ? beatsToSec(n.bulletToDockBeats) : (n.bulletToDockDuration||0));
  return (isFinite(n.bulletToDockDuration) ? n.bulletToDockDuration : (isFinite(n.bulletToDockBeats) ? beatsToSec(n.bulletToDockBeats) : 0));
}
function getBulletDockToDespawnSec(n){
  const byBeats = $("#timeMode").value === "Beats";
  if (byBeats) return (isFinite(n.bulletDockToDespawnBeats) ? beatsToSec(n.bulletDockToDespawnBeats) : (n.bulletDockToDespawnDuration||0));
  return (isFinite(n.bulletDockToDespawnDuration) ? n.bulletDockToDespawnDuration : (isFinite(n.bulletDockToDespawnBeats) ? beatsToSec(n.bulletDockToDespawnBeats) : 0));
}

/* ---------- Slider path helpers ---------- */
function finishPath(){ pathFinished=true; }
function clearPath(){ pathPtsAbs=[]; pathFinished=false; $("#pathCount").textContent="0"; renderPointList(); drawView(); }
function applyPointXY(){
  const i = Math.max(0, Math.min(pathPtsAbs.length-1, parseInt($("#ptIndex").value||"0")));
  const [xs,ys] = ($("#ptXY").value||"960,540").split(",");
  const x=clamp(parseFloat(xs||"960"),0,REF_W), y=clamp(parseFloat(ys||"540"),0,REF_H);
  if(pathPtsAbs.length===0){ pathPtsAbs.push({x,y}); } else { pathPtsAbs[i]={x,y}; }
  $("#ptIndex").value = String(i); renderPointList(); drawView();
}
function insertPointAfter(){
  if(pathPtsAbs.length===0){ applyPointXY(); $("#pathCount").textContent="1"; return; }
  const i = Math.max(0, Math.min(pathPtsAbs.length-1, parseInt($("#ptIndex").value||"0")));
  const [xs,ys] = ($("#ptXY").value||"960,540").split(",");
  const x=clamp(parseFloat(xs||"960"),0,REF_W), y=clamp(parseFloat(ys||"540"),0,REF_H);
  pathPtsAbs.splice(i+1,0,{x,y}); $("#ptIndex").value=String(i+1);
  $("#pathCount").textContent=String(pathPtsAbs.length); renderPointList(); drawView();
}
function removePoint(){
  if(pathPtsAbs.length===0) return;
  const i = Math.max(0, Math.min(pathPtsAbs.length-1, parseInt($("#ptIndex").value||"0")));
  pathPtsAbs.splice(i,1);
  $("#ptIndex").value=String(Math.max(0,i-1));
  $("#pathCount").textContent=String(pathPtsAbs.length); renderPointList(); drawView();
}

/* ---------- 통합 키다운 핸들러 ---------- */
window.addEventListener("keydown",(e)=>{
  // Slider: 화살표로 선택 점 미세 이동
  if($("#noteType").value==="Slider" && pathPtsAbs.length>0){
    let i = Math.max(0, Math.min(pathPtsAbs.length-1, parseInt($("#ptIndex").value||"0")));
    let step = e.shiftKey ? 20 : 5; // px
    let p = pathPtsAbs[i];
    let moved = false;
    if(e.key==="ArrowLeft"){ p.x=clamp(p.x-step,0,REF_W); moved=true; }
    if(e.key==="ArrowRight"){ p.x=clamp(p.x+step,0,REF_W); moved=true; }
    if(e.key==="ArrowUp"){ p.y=clamp(p.y+step,0,REF_H); moved=true; }
    if(e.key==="ArrowDown"){ p.y=clamp(p.y-step,0,REF_H); moved=true; }
    if(moved){ $("#ptXY").value = `${Math.round(p.x)},${Math.round(p.y)}`; renderPointList(); drawView(); e.preventDefault(); }
  }
});

function updateBulletStageLabel(){
  const el = $("#bulletStageLabel"); if(!el) return;
  const names = ["Spawn", "Dock", "Despawn"];
  const done = (p)=> p?`(${Math.round(p.x)},${Math.round(p.y)})`:"(미정)";
  const s = bulletStage;
  el.textContent = `Stage: ${names[s]}을 클릭하세요  |  S${done(bulletTemp.spawn)}  →  Dk${done(bulletTemp.dock)}  →  De${done(bulletTemp.despawn)}`;
}

/* ---------- Add Note ---------- */
function addGrid(){
  if(editIndex!==null) return;
  const [cs,rs] = ($("#cellCR").value||"1,1").split(",");
  const c=parseInt(cs||"1"), r=parseInt(rs||"1");
  const judgeTime=num($("#judgeTimeSec").value), judgeBeat=num($("#judgeBeat").value);
  pushNote({type:"Grid", cell:{x:c,y:r}, judgeTime, judgeBeat});
}
function addCircle(){
  if(editIndex!==null) return;
  const judgeTime=num($("#circleJudgeSec").value), judgeBeat=num($("#circleJudgeBeat").value);
  const [xs,ys] = ($("#circlePos").value||"960,540").split(",");
  const x=clamp(parseFloat(xs||"960"),0,REF_W), y=clamp(parseFloat(ys||"540"),0,REF_H);
  pushNote({type:"CircleTap", absPos:{x,y}, judgeTime, judgeBeat});
}
function addSlider(){
  if(editIndex!==null) return;
  if(pathPtsAbs.length<2){ alert("Slider path needs at least 2 points"); return; }
  const startTime=num($("#sliderStartSec").value), startBeat=num($("#sliderStartBeat").value);
  const duration=num($("#sliderDurSec").value), durationBeats=num($("#sliderDurBeats").value);
  pushNote({type:"Slider", absPath: pathPtsAbs.map(p=>({x:Math.round(p.x),y:Math.round(p.y)})),
            startTime, startBeat, duration, durationBeats});
  clearPath();
}
function addBullet(){
  if(editIndex!==null) return;
  const spawn = parseAbsXY($("#bulletSpawn").value,"192,540");
  const dock  = parseAbsXY($("#bulletDock").value,"960,540");
  const desp  = parseAbsXY($("#bulletDespawn").value,"1728,540");
  const startSec=num($("#bulletStartSec").value), startBeat=num($("#bulletStartBeat").value);
  const toDockSec=num($("#bulletToDockSec").value), toDockBeats=num($("#bulletToDockBeats").value);
  const dockToDespawnSec=num($("#bulletDockToDespawnSec").value), dockToDespawnBeats=num($("#bulletDockToDespawnBeats").value);
  pushNote({
    type:"Bullet",
    bulletSpawnPos:{x:spawn.x, y:spawn.y},
    bulletDockPos:{x:dock.x, y:dock.y},
    bulletDespawnPos:{x:desp.x, y:desp.y},
    bulletSpawnTime:startSec, bulletSpawnBeat:startBeat,
    bulletToDockDuration:toDockSec, bulletToDockBeats:toDockBeats,
    bulletDockToDespawnDuration:dockToDespawnSec, bulletDockToDespawnBeats:dockToDespawnBeats
  });
  if($("#bullet3Click").checked){ bulletStage = 0; bulletTemp = { spawn:null, dock:null, despawn:null }; updateBulletStageLabel(); drawView(); }
}

function addCamera(){
  if(editIndex!==null) return;

  const startTime = num($("#camStartSec").value);
  const startBeat = num($("#camStartBeat").value);
  const duration  = num($("#camDurSec").value);
  const durationBeats = num($("#camDurBeats").value);

  const camAffectHeight = $("#camAffectHeight").checked;
  const camAffectAngle  = $("#camAffectAngle").checked;
  const camAffectCenter = $("#camAffectCenter").checked;

  const camHeightPx  = num($("#camHeightPx").value);
  const camAngleDegZ = num($("#camAngleDegZ").value);
  const [xs,ys] = ($("#camCenterPx").value||"960,540").split(",");
  const camCenterPx = { x: clamp(parseFloat(xs||"960"),0,REF_W),
                        y: clamp(parseFloat(ys||"540"),0,REF_H) };

  const camEase = ($("#camEase").value||"").trim();
  const camUseBeats = $("#camUseBeats").checked;
  const camUseUIScaling = $("#camUseUIScaling").checked;

  // 간단 검증(선택된 축만)
  if (camAffectHeight && !(camHeightPx>0)) { alert("Height(px) > 0 필요"); return; }
  if (camAffectCenter && (!isFinite(camCenterPx.x)||!isFinite(camCenterPx.y))) { alert("Center (x,y) 확인"); return; }

  pushNote({
    type:"Camera",
    startTime, startBeat, duration, durationBeats,
    camAffectHeight, camAffectAngle, camAffectCenter,
    camHeightPx, camAngleDegZ, camCenterPx,
    camEase, camUseBeats, camUseUIScaling
  });
}

function pushNote(obj){ ensureCreatedAt(); obj._id = rid(); obj._createdAt = Date.now(); chart.notes.push(obj); renderNotes(); }

/* ---------- Edit ---------- */
function startEdit(i){
  const n=chart.notes[i]; editIndex=i; editType=n.type;
  $("#editLabel").textContent = `${n.type} #${i+1}`; $("#editBar").classList.add("active");
  $("#noteType").value=n.type; $("#noteType").dispatchEvent(new Event("change"));
  if(n.type==="Grid"){
    selectedCell={c:n.cell.x,r:n.cell.y}; $("#cellCR").value=`${n.cell.x},${n.cell.y}`;
    $("#judgeTimeSec").value = n.judgeTime??0; $("#judgeBeat").value = n.judgeBeat??0; refreshGridActive();
  }else if(n.type==="CircleTap"){
    const p = n.absPos || {x:REF_W/2,y:REF_H/2};
    $("#circlePos").value = `${Math.round(p.x)},${Math.round(p.y)}`;
    $("#circleJudgeSec").value = n.judgeTime??0; $("#circleJudgeBeat").value = n.judgeBeat??0;
  }else if(n.type==="Slider"){
    pathPtsAbs = (n.absPath||[]).map(p=>({x:p.x,y:p.y})); $("#pathCount").textContent=String(pathPtsAbs.length); pathFinished=false;
    $("#sliderStartSec").value=n.startTime??0; $("#sliderStartBeat").value=n.startBeat??0;
    $("#sliderDurSec").value=n.duration??0; $("#sliderDurBeats").value=n.durationBeats??0;
    renderPointList();
  }else if(n.type==="Bullet"){
    const s = n.bulletSpawnPos || {x:192,y:540};
    const d = n.bulletDockPos  || {x:960,y:540};
    const e = n.bulletDespawnPos || {x:1728,y:540};
    $("#bulletSpawn").value = `${Math.round(s.x)},${Math.round(s.y)}`;
    $("#bulletDock").value  = `${Math.round(d.x)},${Math.round(d.y)}`;
    $("#bulletDespawn").value = `${Math.round(e.x)},${Math.round(e.y)}`;
    $("#bulletStartSec").value = n.bulletSpawnTime??0; $("#bulletStartBeat").value = n.bulletSpawnBeat??0;
    $("#bulletToDockSec").value = n.bulletToDockDuration??0; $("#bulletToDockBeats").value = n.bulletToDockBeats??0;
    $("#bulletDockToDespawnSec").value = n.bulletDockToDespawnDuration??0; $("#bulletDockToDespawnBeats").value = n.bulletDockToDespawnBeats??0;
  }
  if(n.type==="Camera"){
    $("#camStartSec").value  = n.startTime??0;
    $("#camStartBeat").value = n.startBeat??0;
    $("#camDurSec").value    = n.duration??0;
    $("#camDurBeats").value  = n.durationBeats??0;
    $("#camAffectHeight").checked = !!n.camAffectHeight;
    $("#camAffectAngle").checked  = !!n.camAffectAngle;
    $("#camAffectCenter").checked = !!n.camAffectCenter;
    $("#camHeightPx").value  = n.camHeightPx??720;
    $("#camAngleDegZ").value = n.camAngleDegZ??0;
    const cp = n.camCenterPx || {x:960,y:540};
    $("#camCenterPx").value  = `${Math.round(cp.x)},${Math.round(cp.y)}`;
    $("#camEase").value      = n.camEase || "";
    $("#camUseBeats").checked = !!n.camUseBeats;
    $("#camUseUIScaling").checked = !!n.camUseUIScaling;
  }
  drawView(); renderNotes(); refreshAddButtons(); updateBulletStageLabel();
}
function saveEdit(){
  if(editIndex===null) return;
  const idx=editIndex, t=editType, prev=chart.notes[idx];
  if(t==="Grid"){
    const [cs,rs]=($("#cellCR").value||"1,1").split(","); const c=parseInt(cs||"1"), r=parseInt(rs||"1");
    chart.notes[idx]={...prev,type:"Grid",cell:{x:c,y:r},judgeTime:num($("#judgeTimeSec").value),judgeBeat:num($("#judgeBeat").value)};
  }else if(t==="CircleTap"){
    const [xs,ys]=($("#circlePos").value||"960,540").split(","); const x=clamp(parseFloat(xs||"960"),0,REF_W), y=clamp(parseFloat(ys||"540"),0,REF_H);
    chart.notes[idx]={...prev,type:"CircleTap",absPos:{x,y},judgeTime:num($("#circleJudgeSec").value),judgeBeat:num($("#circleJudgeBeat").value)};
  }else if(t==="Slider"){
    if(pathPtsAbs.length<2){ alert("Path needs >= 2 points"); return; }
    chart.notes[idx]={...prev,type:"Slider",absPath:pathPtsAbs.map(p=>({x:Math.round(p.x),y:Math.round(p.y)})),
      startTime:num($("#sliderStartSec").value),startBeat:num($("#sliderStartBeat").value),
      duration:num($("#sliderDurSec").value),durationBeats:num($("#sliderDurBeats").value)};
  }else if(t==="Bullet"){
    const spawn=parseAbsXY($("#bulletSpawn").value,"192,540"), dock=parseAbsXY($("#bulletDock").value,"960,540"), desp=parseAbsXY($("#bulletDespawn").value,"1728,540");
    chart.notes[idx]={...prev,type:"Bullet",
      bulletSpawnPos:spawn, bulletDockPos:dock, bulletDespawnPos:desp,
      bulletSpawnTime:num($("#bulletStartSec").value), bulletSpawnBeat:num($("#bulletStartBeat").value),
      bulletToDockDuration:num($("#bulletToDockSec").value), bulletToDockBeats:num($("#bulletToDockBeats").value),
      bulletDockToDespawnDuration:num($("#bulletDockToDespawnSec").value), bulletDockToDespawnBeats:num($("#bulletDockToDespawnBeats").value)
    };
  }else if(t==="Camera"){
    const camAffectHeight = $("#camAffectHeight").checked;
    const camAffectAngle  = $("#camAffectAngle").checked;
    const camAffectCenter = $("#camAffectCenter").checked;
    const [xs,ys] = ($("#camCenterPx").value||"960,540").split(",");
    const camCenterPx = { x: clamp(parseFloat(xs||"960"),0,REF_W),
                          y: clamp(parseFloat(ys||"540"),0,REF_H) };
    chart.notes[idx] = {
      ...prev, type:"Camera",
      startTime:num($("#camStartSec").value),
      startBeat:num($("#camStartBeat").value),
      duration:num($("#camDurSec").value),
      durationBeats:num($("#camDurBeats").value),
      camAffectHeight, camAffectAngle, camAffectCenter,
      camHeightPx:num($("#camHeightPx").value),
      camAngleDegZ:num($("#camAngleDegZ").value),
      camCenterPx,
      camEase:($("#camEase").value||"").trim(),
      camUseBeats: $("#camUseBeats").checked,
      camUseUIScaling: $("#camUseUIScaling").checked
    };
  }
  cancelEdit(false); renderNotes();
}
function cancelEdit(reset=true){
  editIndex=null; editType=null; $("#editBar").classList.remove("active");
  if(reset){
    $("#noteType").value="Grid"; $("#noteType").dispatchEvent(new Event("change"));
    $("#cellCR").value="1,1"; $("#judgeTimeSec").value="1.000"; $("#judgeBeat").value="1.000";
    $("#circlePos").value="960,540"; $("#circleJudgeSec").value="1.000"; $("#circleJudgeBeat").value="1.000";
    $("#sliderStartSec").value="2.000"; $("#sliderStartBeat").value="2.000"; $("#sliderDurSec").value="0.800"; $("#sliderDurBeats").value="0.800";
    clearPath(); circlePosAbs={x:REF_W/2,y:REF_H/2}; selectedCell={c:1,r:1}; refreshGridActive(); drawView();
  }
  refreshAddButtons(); updateBulletStageLabel();
}
function refreshAddButtons(){
  const editing=(editIndex!==null);
  $("#btnAddGrid").disabled   = editing || $("#noteType").value!=="Grid";
  $("#btnAddCircle").disabled = editing || $("#noteType").value!=="CircleTap";
  $("#btnAddSlider").disabled = editing || $("#noteType").value!=="Slider";
  $("#btnAddBullet").disabled = editing || $("#noteType").value!=="Bullet";
  const camBtn = $("#btnAddCamera"); if (camBtn) camBtn.disabled = editing || $("#noteType").value!=="Camera";

}

/* ---------- Notes Table / 정렬 / 드래그 ---------- */
function ensureCreatedAt(){ let t0=Date.now(); for(let n of chart.notes){ if(n._createdAt==null){ n._createdAt=t0; t0++; } if(n._id==null){ n._id = rid(); } } }
function rid(){ return (crypto.randomUUID && crypto.randomUUID()) || (Math.random().toString(36).slice(2)+Date.now().toString(36)); }

function renderNotes(){
  chart.title=$("#title").value; chart.bpm=num($("#bpm").value); chart.timeMode=$("#timeMode").value;
  chart.startOffset=num($("#startOffsetSec").value); chart.startOffsetBeats=num($("#startOffsetBeats").value);
  ensureCreatedAt();
  const tbody=$("#notesTable tbody"); tbody.innerHTML="";
  chart.notes.forEach((n,i)=>{
    const tr=document.createElement("tr"); tr.dataset.index=i; if(editIndex===i) tr.classList.add("editrow");
    const tdIdx=cel("td","muted",String(i+1));
    const tdType=cel("td","","<span class=\"pill\">"+n.type+"</span>",true);
    let data="";
    if(n.type==="Grid"){ data=`cell=(${n.cell.x},${n.cell.y})`; }
    else if(n.type==="CircleTap"){
      const p = n.absPos || {x:REF_W/2,y:REF_H/2};
      data=`pos=(${Math.round(p.x)},${Math.round(p.y)})`;
    }
    else if(n.type==="Slider"){ data=`pts=${(n.absPath||[]).length}`; }
    else if(n.type==="Bullet"){
      const s = n.bulletSpawnPos || {x:192,y:540};
      const d = n.bulletDockPos  || {x:960,y:540};
      const e = n.bulletDespawnPos || {x:1728,y:540};
      data=`S(${Math.round(s.x)},${Math.round(s.y)}) Dk(${Math.round(d.x)},${Math.round(d.y)}) De(${Math.round(e.x)},${Math.round(e.y)})`;
    }else if(n.type==="Camera"){
      const flags = [
        n.camAffectHeight ? `H=${Math.round(n.camHeightPx||0)}px` : null,
        n.camAffectAngle  ? `A=${fmt(n.camAngleDegZ)}°` : null,
        n.camAffectCenter ? `C=(${Math.round(n.camCenterPx?.x||960)},${Math.round(n.camCenterPx?.y||540)})` : null
      ].filter(Boolean).join(" · ");
      data = flags || "(no axes)";
    }
    const tdData=cel("td","",data);
    let timeTxt="";
    if(n.type==="Slider"){ timeTxt=`start=${fmt(n.startTime)}/${fmt(n.startBeat)} | dur=${fmt(n.duration)}/${fmt(n.durationBeats)}`; }
    else if(n.type==="Bullet"){ timeTxt=`start=${fmt(n.bulletSpawnTime)}/${fmt(n.bulletSpawnBeat)} | toDock=${fmt(n.bulletToDockDuration)}/${fmt(n.bulletToDockBeats)} | dockToDespawn=${fmt(n.bulletDockToDespawnDuration)}/${fmt(n.bulletDockToDespawnBeats)}`; }
    else if(n.type==="Camera"){
      timeTxt = `start=${fmt(n.startTime)}/${fmt(n.startBeat)} | dur=${fmt(n.duration)}/${fmt(n.durationBeats)}`;
    }
    else{ timeTxt=`t=${fmt(n.judgeTime)}/${fmt(n.judgeBeat)}`; }
    const tdTime=cel("td","muted",timeTxt);
    const tdSpawn=cel("td","muted","spawn="+fmt(spawnSecOf(n)));
    const tdAct=document.createElement("td"); tdAct.style.display="flex"; tdAct.style.gap="6px";
    tdAct.innerHTML = `<button onclick="startEdit(${i})">Edit</button>
      <button class="bad" onclick="removeNote(${i})">Del</button>
      <button onclick="moveUp(${i})">Up</button>
      <button onclick="moveDown(${i})">Down</button>`;
    tr.appendChild(tdIdx); tr.appendChild(tdType); tr.appendChild(tdData); tr.appendChild(tdTime); tr.appendChild(tdSpawn); tr.appendChild(tdAct);
    attachRowDragHandlers(tr,i); tbody.appendChild(tr);
  });
}
function cel(tag,cls,txt,isHTML=false){ const el=document.createElement(tag); if(cls) el.className=cls; if(isHTML) el.innerHTML=txt; else el.textContent=txt; return el; }
function removeNote(i){ if(editIndex===i) cancelEdit(); chart.notes.splice(i,1); renderNotes(); }
function moveUp(i){ if(i<=0) return; const it=chart.notes.splice(i,1)[0]; chart.notes.splice(i-1,0,it); renderNotes(); }
function moveDown(i){ if(i>=chart.notes.length-1) return; const it=chart.notes.splice(i,1)[0]; chart.notes.splice(i+1,0,it); renderNotes(); }
let dragIndex=null; function attachRowDragHandlers(tr,idx){ tr.setAttribute("draggable","true"); tr.addEventListener("dragstart",(e)=>{ dragIndex=idx; tr.style.opacity="0.5"; }); tr.addEventListener("dragend",()=>{ tr.style.opacity=""; dragIndex=null; }); tr.addEventListener("dragover",(e)=>{ e.preventDefault(); }); tr.addEventListener("drop",(e)=>{ e.preventDefault(); const targetIdx=parseInt(tr.dataset.index,10); if(dragIndex===null || dragIndex===targetIdx) return; const item=chart.notes.splice(dragIndex,1)[0]; chart.notes.splice(targetIdx,0,item); renderNotes(); }); }

/* ---------- 정렬 & 시간 계산 ---------- */
function spb(){ const bpm = num($("#bpm").value); return bpm>0 ? 60/bpm : 0; }
function getNoteTimeSec(n){
  if (n.type === "Slider") {
    return chartTimeToPlaybackSec({ sec: n.startTime,  beat: n.startBeat });
  }
  if (n.type === "Bullet") {
    return chartTimeToPlaybackSec({ sec: n.bulletSpawnTime,  beat: n.bulletSpawnBeat });
  }
  // Grid / CircleTap
  return chartTimeToPlaybackSec({ sec: n.judgeTime, beat: n.judgeBeat });
}

function packIntoRows(intervals){
  // intervals: [{x0,x1, idx, type, t0,t1}]
  // return: [{... , row}]
  const rowsEnd = [];  // 각 row의 마지막 x1
  const out = [];
  intervals.sort((a,b)=> (a.x0 - b.x0) || (a.x1 - b.x1));
  for(const it of intervals){
    let placed = false;
    for(let r=0;r<rowsEnd.length;r++){
      if(it.x0 >= rowsEnd[r] - 0.5){  // 살짝 겹치는 경계 허용
        rowsEnd[r] = it.x1;
        out.push({...it, row:r});
        placed = true;
        break;
      }
    }
    if(!placed){
      rowsEnd.push(it.x1);
      out.push({...it, row:rowsEnd.length-1});
    }
  }
  return { placed: out, rowCount: rowsEnd.length };
}


function getNoteTimeBeats(n){
  const S = spb();
  const byBeats = $("#timeMode").value === "Beats";

  const present = v => v != null && isFinite(v);
  const beatsFromSec = (sec)=> present(sec) ? sec / (S||1) : null;
  const pick = (primary, fallback)=> present(primary) ? primary : (present(fallback) ? fallback : 0);

  if(n.type === "Slider"){
    const sec = n.startTime;
    const beat = n.startBeat;
    return byBeats ? pick(beat, beatsFromSec(sec)) : pick(beatsFromSec(sec), beat);
  }
  if(n.type === "Bullet"){
    const sec = n.bulletSpawnTime;
    const beat = n.bulletSpawnBeat;
    return byBeats ? pick(beat, beatsFromSec(sec)) : pick(beatsFromSec(sec), beat);
  }
  const sec = n.judgeTime;
  const beat = n.judgeBeat;
  return byBeats ? pick(beat, beatsFromSec(sec)) : pick(beatsFromSec(sec), beat);
}
function spawnSecOf(n){
  const gridTargetPx = resolveGridTargetPx();
  const gridGrowSec  = resolveGridGrowPxPerSec();       // px/s
  const gridLeadSec  = gridTargetPx / gridGrowSec;      // s

  if (n.type === "Grid")      return getNoteTimeSec(n) - gridLeadSec;
 if (n.type === "CircleTap") return getNoteTimeSec(n) - resolveCircleLeadSec();
 if (n.type === "Slider")    return getNoteTimeSec(n) - resolveSliderLeadSec();
  if (n.type === "Bullet")    return getNoteTimeSec(n);
  if (n.type === "Camera") return getCameraStartSec(n);
  return getNoteTimeSec(n);
  return getNoteTimeSec(n);
}
function sortByCreation(){ ensureCreatedAt(); chart.notes.sort((a,b)=> (a._createdAt||0)-(b._createdAt||0)); renderNotes(); }
function sortByTimeSec(){ chart.notes.sort((a,b)=> getNoteTimeSec(a)-getNoteTimeSec(b)); renderNotes(); }
function sortByTimeBeats(){ chart.notes.sort((a,b)=> getNoteTimeBeats(a)-getNoteTimeBeats(b)); renderNotes(); }
function sortBySpawn(){ chart.notes.sort((a,b)=> spawnSecOf(a)-spawnSecOf(b)); renderNotes(); }
function reindexNotes(){ for(let i=0;i<chart.notes.length;i++){ chart.notes[i]._order=i; } renderNotes(); }

/* ---------- Export/Import ---------- */
function levelChartJSON(){
  const payload = {
    schemaVersion: 2,
    title: chart.title, bpm: chart.bpm, timeMode: chart.timeMode,
    startOffset: chart.startOffset, startOffsetBeats: chart.startOffsetBeats,
    notes: chart.notes
  };
  return JSON.stringify(payload, null, 2);
}
function downloadJSON(){
  const blob=new Blob([levelChartJSON()],{type:"application/json;charset=utf-8"});
  const url=URL.createObjectURL(blob); const a=document.createElement("a");
  a.href=url; a.download=(chart.title||"chart")+".json"; document.body.appendChild(a); a.click();
  URL.revokeObjectURL(url); a.remove();
}
$("#importFile").addEventListener("change",(e)=>{
  const f=e.target.files[0]; if(!f) return;
  const r=new FileReader();
  r.onload=()=>{
    try{
      const obj=JSON.parse(r.result);
      // 간단 마이그레이션: screenPos01/screenPath01/bullet*01 → abs*
      if(Array.isArray(obj.notes)){
        for(const n of obj.notes){
          if(n.screenPos01 && !n.absPos){
            n.absPos = { x: n.screenPos01.x * REF_W, y: n.screenPos01.y * REF_H };
          }
          if(n.screenPath01 && !n.absPath){
            n.absPath = n.screenPath01.map(p => ({ x: p.x*REF_W, y: p.y*REF_H }));
          }
          if(n.bulletSpawn01 && !n.bulletSpawnPos){
            n.bulletSpawnPos = { x: n.bulletSpawn01.x*REF_W, y: n.bulletSpawn01.y*REF_H };
            n.bulletDockPos  = { x: n.bulletDock01.x*REF_W,  y: n.bulletDock01.y*REF_H  };
            n.bulletDespawnPos = { x: n.bulletDespawn01.x*REF_W, y: n.bulletDespawn01.y*REF_H };
          }
          // schemaVersion 없으면 1로 간주
          if(!("schemaVersion" in obj)) obj.schemaVersion = 1;
        }
      }
      cancelEdit(false);
      chart.schemaVersion = obj.schemaVersion || 2;
      chart.title=obj.title||"Imported"; chart.bpm=obj.bpm||120;
      chart.timeMode=obj.timeMode||"Seconds";
      chart.startOffset=obj.startOffset||0; chart.startOffsetBeats=obj.startOffsetBeats||0;
      chart.notes=Array.isArray(obj.notes)?obj.notes:[];
      $("#title").value=chart.title; $("#bpm").value=chart.bpm; $("#timeMode").value=chart.timeMode;
      $("#startOffsetSec").value=chart.startOffset; $("#startOffsetBeats").value=chart.startOffsetBeats;
      ensureCreatedAt(); renderNotes(); drawWave();
    }catch(err){ alert("JSON parse failed: "+err); }
  };
  r.readAsText(f,"utf-8");
});
function sanitizeName(s){
  // 파일/폴더명에 안 되는 문자 제거(윈도우/맥 공통)
  return (s || "Untitled")
    .replace(/[\\/:*?"<>|]/g, "_")
    .replace(/\s+/g, " ")
    .trim();
}

async function exportSongZip(){
  try{
    if (typeof JSZip === "undefined"){
      alert("JSZip이 로드되지 않았습니다. <script src=...jszip.min.js>를 추가하세요.");
      return;
    }

    const title  = ($("#title")?.value || "New Chart");
    const artist = ($("#artist")?.value || "Unknown");
    const folderName = `${sanitizeName(artist)} - ${sanitizeName(title)}`;

    const zip = new JSZip();
    const root = zip.folder(folderName);
    const chartsFolder = root.folder("charts");

    // chart json
    const chartJson = levelChartJSON();
    chartsFolder.file("Normal.chart.json", chartJson);

    // song.json
const songMeta = {
  title,
  artist,
  bpm: num($("#bpm").value),
  previewStart: num($("#previewStart")?.value || 0),
  previewDuration: num($("#previewDuration")?.value || 0),
  coverImage: "cover.jpg",
  bgVideo: "",
  fmodEvent: ($("#fmodEvent")?.value || ""), 
  durationSec: num($("#durationSec")?.value || 0),
  difficulties: [{ name:"Normal", path:"charts/Normal.chart.json", level:1 }],
  tags: ($("#tags")?.value || "").split(",").map(t=>t.trim()).filter(Boolean)
};
    root.file("song.json", JSON.stringify(songMeta, null, 2));

    // cover
    const coverFile = $("#coverFile")?.files?.[0];
    if (coverFile){
      const coverBuf = await coverFile.arrayBuffer(); // ← 이름 변경
      root.file("cover.jpg", coverBuf);
    }

    // zip 출력
    const zipBlob = await zip.generateAsync({ type:"blob" }); // ← 이름 변경
    const a = document.createElement("a");
    a.href = URL.createObjectURL(zipBlob);
    a.download = `${folderName}.zip`;
    document.body.appendChild(a); // 사파리 호환성
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
  }catch(err){
    console.error("[exportSongZip] failed:", err);
    alert("Export 중 오류가 발생했습니다. 콘솔을 확인하세요.");
  }
}

/* ---------- Waveform ---------- */
function setWaveControlsEnabled(on = true){
  [playBtn, pauseBtn, zoomInBtn, zoomOutBtn, fitBtn].forEach(b=>{
    if (b) b.disabled = !on;
  });
}
// --- Accurate transport state (WebAudio) ---
let AC = null;                 // AudioContext
let AC_buf = null;             // AudioBuffer
let AC_src = null;             // BufferSource
let AC_startCtxT = 0;          // context 기준 시작 시각
let AC_startOffset = 0;        // 곡 내 오프셋(초)
let AC_rate = 1.0;             // 배속
let AC_enabled = true;         // 정확 모드 on/off 스위치
const MIN_VIEW_SPAN_SEC   = 0.01; // 최소 가시 구간 20ms (원하면 0.005s도 가능)
const KEY_PAN_FRAC        = 0.05; // ← 기본 좌우 이동: 현재 구간의 5%
const KEY_PAN_FRAC_FAST   = 0.20; // ← Alt+Arrow: 20%
const KEY_PAN_FRAC_SLOW   = 0.01; // ← Ctrl+Arrow: 1%

let previewTimeSec = 0;  // 정지 중 커서가 보여줄 시각(초)
function isPlaying(){
  return (AC_enabled && !!AC_src) || (!AC_enabled && !audioEl.paused && !audioEl.ended);
}

function ensureAC(){
  if (AC && AC.state !== 'closed') return AC;
  AC = new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'});
  return AC;
}

function stopAccurate(){
  if (AC_src){
    try { AC_src.stop(); } catch {}
    try { AC_src.disconnect(); } catch {}
  }
  AC_src = null;
}

function playAccurate(startAtSec = null){
  dlog?.("playAccurate.in", {startAtSec});
  if (!AC_enabled || !AC_buf) { audioEl.play(); return; }

  const ac = ensureAC();

  // ★ 일부 브라우저는 첫 클릭 이후에도 suspended → 반드시 resume 시도
  if (ac.state === "suspended") {
    try { ac.resume(); } catch(e){ console.warn("AC.resume failed", e); }
  }

  if (startAtSec != null){
    AC_startOffset = qms(Math.max(0, Math.min(startAtSec, AC_buf.duration)));
  }
  stopAccurate();

  AC_src = ac.createBufferSource();
  AC_src.buffer = AC_buf;
  AC_src.playbackRate.value = AC_rate;
  AC_src.connect(ac.destination);

  const safety = Math.max(0.03, (ac.baseLatency||0.02) + (ac.outputLatency||0));
  const when = ac.currentTime + safety;

  AC_startCtxT = when;
  AC_src.start(when, AC_startOffset);

  // ★ UI 갱신 루프 보장
  scheduleAccurateUiLoop();

  dlog?.("playAccurate.out", snapshotState());
}

function pauseAccurate(){
  if (!AC_enabled || !AC_buf) { audioEl.pause(); return; }
  const now = qms(getNowAccurate());
  stopAccurate();
  AC_startOffset = now;
  previewTimeSec = now;          // ⟵ 프리뷰 고정
  curTimeEl.textContent = now.toFixed(3);
  window.getPreviewNowSec = () => now;
  redrawBeat();
  drawWave();
}

function seekAccurate(toSec){
  if (!AC_enabled || !AC_buf){
    const d = getDuration();
    const t = qms(Math.max(0, Math.min(toSec, d)));
    audioEl.currentTime = t;
    // 정지 중이면 프리뷰 갱신
    if (!isPlaying()){
      previewTimeSec = t;
      curTimeEl.textContent = t.toFixed(3);
      window.getPreviewNowSec = () => t;
    }
    redrawBeat();
    drawWave();
    return;
  }
  const t = qms(Math.max(0, Math.min(toSec, AC_buf.duration)));
  if (AC_src) {
    playAccurate(t);             // 재생 중엔 즉시 점프
  } else {
    AC_startOffset = t;          // 정지 상태면 위치만 설정
    previewTimeSec = t;
    curTimeEl.textContent = t.toFixed(3);
    window.getPreviewNowSec = () => t;
    redrawBeat();
    drawWave();
  }
}

function setRateAccurate(r) {
  AC_rate = (r && isFinite(r)) ? r : 1;

  // HTMLAudio 모드
  if (!AC_enabled || !AC_buf) {
    setPlaybackRate(AC_rate);
    return;
  }

  const wasPlaying = !!AC_src;
  const pos = wasPlaying ? getNowAccurate() : (AC_startOffset || 0);
  stopAccurate();

  if (wasPlaying) {
    // 재생 중일 때만 다시 시작
    const ac = ensureAC();
    AC_src = ac.createBufferSource();
    AC_src.buffer = AC_buf;
    AC_src.playbackRate.value = AC_rate;
    AC_src.connect(ac.destination);

    const safety = Math.max(0.03, (ac.baseLatency || 0.02) + (ac.outputLatency || 0));
    const when = ac.currentTime + safety;
    AC_startCtxT = when;
    AC_startOffset = pos;
    AC_src.start(when, pos);
    requestAnimationFrame(syncUiAccurate);
  } else {
    // 정지 상태면 위치만 유지, 재생 시작 안 함
    AC_startOffset = pos;
    const tt = qms(pos);
    curTimeEl.textContent = tt.toFixed(3);
    window.getPreviewNowSec = () => tt;
    redrawBeat();
    drawWave();
  }
}

function getNowAccurate(){
  if (!AC_enabled || !AC_buf || !AC_src) return AC_startOffset||0;
  const acNow = ensureAC().currentTime;
  const t = (acNow - AC_startCtxT) * AC_rate + AC_startOffset;
  return Math.max(0, Math.min(t, AC_buf.duration));
}

function syncUiAccurate(){
  try{
    if (!AC_enabled || !AC_buf) return;
    const t = qms(getNowAccurate());
    curTimeEl.textContent = t.toFixed(3);
    const bi = beatInfoAt(t);
    curBeatEl.textContent = bi.valid ? bi.text : "-";
    window.getPreviewNowSec = () => t;   // 미리보기 타임 소스 통합
    drawWave();

    // 끝났으면 루프 종료
    if (t >= (AC_buf.duration - 1/(AC?.sampleRate||48000))) {
      stopAccurate();
      return;
    }
  }catch(err){
    console.error("[syncUiAccurate] crashed:", err);
    // 크래시한 경우에도 루프가 죽지 않도록 폴백 타이머가 커버함
  }
}

const waveCanvas=$("#wave"); const wctx=waveCanvas.getContext("2d");
const audioEl=$("#audio"); const audioFileInput=$("#audioFile");
const playBtn=$("#playBtn"), pauseBtn=$("#pauseBtn");
const curTimeEl=$("#curTime"), durTimeEl=$("#durTime"), curBeatEl=$("#curBeat");
const zoomInBtn=$("#zoomInBtn"), zoomOutBtn=$("#zoomOutBtn"), fitBtn=$("#fitBtn");
const ampScaleInput=$("#ampScale");
let audioBuffer=null, audioURL=null, viewStart=0, viewEnd=0, isPanning=false, dragStartX=0, dragStartView=0, ampScale=0.6;
let dragSelecting=false, dragT0=0, dragT1=0;
let _rafId = null;


audioEl.addEventListener("seeking", drawWave);
audioEl.addEventListener("seeked", drawWave);
audioEl.addEventListener("ratechange", drawWave);

function resizeWaveCanvas(){
  const dpr=window.devicePixelRatio||1, cssW=waveCanvas.clientWidth, cssH=waveCanvas.clientHeight;
  waveCanvas.width=Math.max(600,Math.floor(cssW*dpr)); waveCanvas.height=Math.floor(cssH*dpr);
  wctx.setTransform(dpr,0,0,dpr,0,0); drawWave();
}
window.addEventListener("resize", resizeWaveCanvas);

audioFileInput.addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if (!file) return;

  // HTMLAudio에 로드(메타/기본 길이)
  if (audioURL) { URL.revokeObjectURL(audioURL); audioURL = null; }
  audioURL = URL.createObjectURL(file);
  audioEl.src = audioURL;

  audioEl.onloadedmetadata = () => {
    const d = audioEl.duration || 0;
    durTimeEl.textContent = d.toFixed(3);
    viewStart = 0;
    viewEnd   = d;
    drawWave();
    setWaveControlsEnabled(true); // 이 함수는 반드시 위쪽에 선언
  };

  // === WebAudio로 한 번만 디코드 → 둘 다 재사용 ===
  try {
    const wa  = ensureAC();                   // ← 이름을 'ac'가 아닌 'wa'로 (충돌 방지)
    const arr = await file.arrayBuffer();
    AC_buf     = await wa.decodeAudioData(arr.slice(0)); // 정확 모드용
    audioBuffer = AC_buf;                                // 파형 그리기도 같은 버퍼 재사용
  } catch (err) {
    console.error("decodeAudioData failed", err);
    AC_buf = null;
    audioBuffer = null;
  }

  // HTMLAudio가 duration을 못 읽는 파일 대비: WebAudio 길이로 보정
  if ((!isFinite(audioEl.duration) || (audioEl.duration || 0) <= 0) && (AC_buf?.duration > 0)){
    const d = AC_buf.duration;
    durTimeEl.textContent = d.toFixed(3);
    viewStart = 0;
    viewEnd   = d;
    drawWave();
    setWaveControlsEnabled(true);
  }

  // 캔버스 DPI/크기 반영
  resizeWaveCanvas();
});


playBtn.onclick  = () => { (AC_enabled && AC_buf) ? playAccurate() : audioEl.play(); };
pauseBtn.onclick = () => { (AC_enabled && AC_buf) ? pauseAccurate() : audioEl.pause(); };
audioEl.addEventListener("timeupdate", ()=>{
  const t = qms(audioEl.currentTime || 0);
  curTimeEl.textContent = t.toFixed(3);
  window.getPreviewNowSec = () => t;
  const bi=beatInfoAt(t);
  curBeatEl.textContent = bi.valid?bi.text:"-";
  drawWave();
});

function setWaveControlsEnabled(on=true){
  [playBtn, pauseBtn, zoomInBtn, zoomOutBtn, fitBtn].forEach(b=>{
    if (b) b.disabled = !on;
  });
}


ampScaleInput.addEventListener("input",(e)=>{ ampScale=parseFloat(e.target.value||"0.6")||0.6; drawWave(); });

// 별도 RAF 루프 (안정화)
let rafId = null;
function tick() { drawWave(); rafId = requestAnimationFrame(tick); }
audioEl.addEventListener("play", () => { if (rafId) cancelAnimationFrame(rafId); tick(); });
audioEl.addEventListener("pause", () => {
  const t = qms(audioEl.currentTime || 0);
  previewTimeSec = t;
  curTimeEl.textContent = t.toFixed(3);
  window.getPreviewNowSec = () => t;
  redrawBeat();
  drawWave();
});

audioEl.addEventListener("ended", () => { if (rafId) cancelAnimationFrame(rafId); rafId = null; drawWave(); });

function getDuration(){
  return (audioEl?.duration || 0)
      || (AC_buf?.duration || 0)
      || (audioBuffer?.duration || 0)
      || 0;
}
function ensureViewBounds(){
  const D = getDuration();
  if (D <= 0){ viewStart = 0; viewEnd = 0; return; }

  const spanMin = Math.max(MIN_VIEW_SPAN_SEC, 0.001);
  let span = viewEnd - viewStart;

  if (span < spanMin){
    const c = (viewStart + viewEnd) / 2;
    viewStart = Math.max(0, c - spanMin/2);
    viewEnd   = Math.min(D, c + spanMin/2);
    span      = viewEnd - viewStart;
  }
  if (viewStart < 0){ viewEnd -= viewStart; viewStart = 0; }
  if (viewEnd > D){
    const over = viewEnd - D;
    viewStart = Math.max(0, viewStart - over);
    viewEnd   = D;
  }
}
function timeToX(t){ const span=(viewEnd-viewStart)||1; return ((t-viewStart)/span)*waveCanvas.clientWidth; }
function xToTime(x){ const span=(viewEnd-viewStart)||1; return viewStart+(x/waveCanvas.clientWidth)*span; }

zoomInBtn.onclick = () => {
  const c = (typeof getPreviewNowSec === "function") ? getPreviewNowSec()
            : (audioEl.currentTime || (viewStart+viewEnd)/2);
  zoomAt(c, 0.7);
};
zoomOutBtn.onclick = () => {
  const c = (typeof getPreviewNowSec === "function") ? getPreviewNowSec()
            : (audioEl.currentTime || (viewStart+viewEnd)/2);
  zoomAt(c, 1.4);
};
fitBtn.onclick = () => { const D = getDuration(); viewStart=0; viewEnd=D; drawWave(); };
function zoomAt(c, f){
  const D = getDuration(); if (D <= 0) return;
  const span   = (viewEnd - viewStart) || D;
  const ns     = clamp(span * f, MIN_VIEW_SPAN_SEC, D);
  const lr     = (c - viewStart) / span;

  viewStart = c - ns * lr;
  viewEnd   = viewStart + ns;

  ensureViewBounds();
  drawWave();
}

let waveHover = false;
waveCanvas.addEventListener("mouseenter", ()=> waveHover = true);
waveCanvas.addEventListener("mouseleave", ()=> waveHover = false);

window.addEventListener("keydown", (e)=>{
  // 텍스트 입력 중엔 무시
  const tag = (document.activeElement && document.activeElement.tagName) || "";
  if (tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT") return;

  // 좌/우 키만 처리
  if (e.key !== "ArrowLeft" && e.key !== "ArrowRight") return;

  // 슬라이더 편집 충돌 방지: 슬라이더 편집 중이면 Alt 눌렀을 때만 시점이동
  const sliderEditing = ($("#noteType")?.value === "Slider") && (pathPtsAbs?.length > 0);
  if (sliderEditing && !e.altKey) return;

  // 파형 위에서만 동작하게 하거나, Alt 키로 강제 동작
  if (!waveHover && !e.altKey) return;

  const D = getDuration(); if (D <= 0) return;

  const span = Math.max(MIN_VIEW_SPAN_SEC, (viewEnd - viewStart));
  const frac = e.ctrlKey ? KEY_PAN_FRAC_SLOW : (e.altKey ? KEY_PAN_FRAC_FAST : KEY_PAN_FRAC);
  const step = span * frac * (e.key === "ArrowLeft" ? -1 : +1);

  // 시점만 이동(구간 길이 유지)
  const newStart = Math.max(0, Math.min(viewStart + step, D - span));
  viewStart = newStart;
  viewEnd   = newStart + span;

  drawWave();
  e.preventDefault();
});



waveCanvas.addEventListener("click", (e) => {
  if (isPanning || dragSelecting) return;

  const rect = waveCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  const hit = [...waveBlocks].reverse().find(
    b => x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h
  );
  if (hit) {
    startEdit(hit.idx);
    return;
  }

  const dur = getDuration();
  if (dur <= 0) return;

  const t = clamp(xToTime(x), 0, dur);
  applyTimeFromWave(t, null);     // 시킹 + 입력칸 채우기
  const tt = qms(t);

  // 정지 중일 때는 프리뷰 커서도 즉시 갱신
  if (!isPlaying()) {
    previewTimeSec = tt;
    curTimeEl.textContent = tt.toFixed(3);
    window.getPreviewNowSec = () => tt;  // (기존 코드와의 호환용)
    redrawBeat();
    drawWave();
  }
});


waveCanvas.addEventListener("mousemove",(e)=>{
  if(isPanning||dragSelecting) return;
  const rect=waveCanvas.getBoundingClientRect();
  const x=(e.clientX-rect.left), y=(e.clientY-rect.top);
  const hit = waveBlocks.find(b => x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h);
  waveCanvas.style.cursor = hit ? "pointer" : "default";
});



window.addEventListener("mousemove",(e)=>{
  if(isPanning){
    const rect=waveCanvas.getBoundingClientRect(); const x=e.clientX-rect.left; const dx=x-dragStartX;
    const dt=dx*(viewEnd-viewStart)/waveCanvas.clientWidth; viewStart=dragStartView-dt; viewEnd=viewStart+(viewEnd-dragStartView);
    ensureViewBounds(); drawWave();
  } else if(dragSelecting){
    const rect=waveCanvas.getBoundingClientRect(); const x=e.clientX-rect.left; dragT1=xToTime(x); drawWave();
    const x0=timeToX(Math.min(dragT0,dragT1)), x1=timeToX(Math.max(dragT0,dragT1));
    wctx.fillStyle="rgba(102,217,239,0.15)"; wctx.fillRect(x0,0,x1-x0,waveCanvas.clientHeight);
    wctx.strokeStyle="#66d9ef"; wctx.strokeRect(x0+0.5,0.5,x1-x0-1,waveCanvas.clientHeight-1);
  }
});
window.addEventListener("mouseup",()=>{ if(isPanning) isPanning=false; if(dragSelecting){ dragSelecting=false; const a=Math.min(dragT0,dragT1), b=Math.max(dragT0,dragT1); applyTimeFromWave(a,b); } });

waveCanvas.addEventListener("wheel",(e)=>{
  const t=xToTime(e.offsetX);
  if(e.ctrlKey){ e.preventDefault(); const f=(e.deltaY<0)?0.9:1.1; zoomAt(t,f); }
  else{ const dt=(viewEnd-viewStart)*(e.deltaY>0?0.05:-0.05); viewStart+=dt; viewEnd+=dt; ensureViewBounds(); drawWave(); }
},{passive:false});



function drawWave(){
  const w=waveCanvas.clientWidth, h=waveCanvas.clientHeight;
  wctx.clearRect(0,0,w,h); wctx.fillStyle="#0b0f1c"; wctx.fillRect(0,0,w,h);
  if(audioBuffer){ drawPeaksRange(wctx,w,h,audioBuffer,viewStart,viewEnd,ampScale); }
  else{ wctx.fillStyle="#9aa4bb"; wctx.fillText("오디오 파일을 선택하세요.", 10, h/2); }
  const bpm=num($("#bpm").value); const duration=getDuration(), offset=computeOffsetSeconds();
  drawTimeGrid(wctx,w,h,viewStart,viewEnd);
  if(bpm>0 && duration>0){ drawBeatGrid(wctx,w,h,viewStart,viewEnd,bpm,offset,parseInt($("#subdiv").value||"8")); }
  // 기존: const t = nowSecQms();
  const t = isPlaying() ? nowSecQms() : qms(previewTimeSec);

  if(t>=viewStart && t<=viewEnd){
    const x=timeToX(t); wctx.strokeStyle="#ffd48a"; wctx.lineWidth=2; wctx.beginPath(); wctx.moveTo(x,0); wctx.lineTo(x,h); wctx.stroke();
    if(audioEl.paused){
      const bi=beatInfoAt(t);
      const label=`${t.toFixed(3)}s | ${bi.valid?bi.text:"-"}`;
      const pad=6, textW=wctx.measureText(label).width, boxW=textW+pad*2, boxH=20;
      let bx=x+8, by=8; if(bx+boxW>w-4) bx=x-8-boxW; if(bx<4) bx=4;
      wctx.fillStyle="rgba(17,32,51,0.9)"; wctx.fillRect(bx,by,boxW,boxH);
      wctx.strokeStyle="#264463"; wctx.strokeRect(bx+0.5,by+0.5,boxW-1,boxH-1);
      wctx.fillStyle="#dfe7ff"; wctx.fillText(label, bx+pad, by+boxH-6);
    }
  }
  drawNoteBlocks();
}
function drawPeaksRange(ctx,w,h,buffer,vStart,vEnd,scale){
  const sr=buffer.sampleRate, ch0=buffer.getChannelData(0), ch1=(buffer.numberOfChannels>1?buffer.getChannelData(1):null);
  const iStart=Math.max(0,Math.floor(vStart*sr)), iEnd=Math.min(ch0.length,Math.ceil(vEnd*sr)); if(iEnd<=iStart) return;
  const samples=iEnd-iStart, spp=Math.max(1,Math.floor(samples/w)), cy=h/2; ctx.fillStyle="#6ee7b7";
  for(let x=0;x<w;x++){
    const start=iStart+x*spp, end=Math.min(iEnd,start+spp);
    let min=1,max=-1;
    for(let i=start;i<end;i++){
      const a0=ch0[i], a1=ch1?ch1[i]:0, a=ch1?((a0+a1)*0.5):a0;
      if(a<min)min=a; if(a>max)max=a;
    }
    const y1=cy+min*cy*scale, y2=cy+max*cy*scale;
    ctx.fillRect(x,y1,1,Math.max(1,y2-y1));
  }
}
function drawTimeGrid(ctx,w,h,vStart,vEnd){
  const span=vEnd-vStart; if(span<=0) return;
  const targetPx=80; const secPerPx=span/w; const raw=targetPx*secPerPx;
  const mag=Math.pow(10,Math.floor(Math.log10(raw))); const cand=[1,2,5,10]; let step=cand[0]*mag;
  for(const c of cand){ const s=c*mag; if(s>=raw){step=s;break;} }
  const startTick=Math.ceil(vStart/step)*step;
  for(let s=startTick;s<=vEnd+1e-6;s+=step){
    const x=timeToX(s); const major=(Math.round(s/step)%5===0);
    ctx.strokeStyle=major?"#2d3653":"#1e2744"; ctx.lineWidth=major?1.5:1;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
    if(major){ ctx.fillStyle="#9aa4bb"; ctx.fillText(`${s.toFixed(0)}s`, Math.max(2,x+2), 12); }
  }
}
function drawBeatGrid(ctx,w,h,vStart,vEnd,bpm,off,subdiv){
  const spb=60/bpm; let bi=Math.floor((vStart-off)/spb)-1;
  for(;;bi++){
    const t=off+bi*spb; if(t>vEnd) break;
    if(t>=vStart){
      const x=timeToX(t); const bar=(bi%4===0);
      ctx.strokeStyle=bar?"#66d9ef":"#265a6d"; ctx.lineWidth=bar?2:1;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
      if(bar){ ctx.fillStyle="#b9c2d9"; ctx.fillText(`M${Math.floor(bi/4)+1}`, Math.max(2,x+2), h-6); }
    }
    if(subdiv && subdiv>1){
      for(let k=1;k<subdiv;k++){
        const tk=t+k*spb/subdiv; if(tk<vStart||tk>vEnd) continue;
        const xk=timeToX(tk); ctx.strokeStyle="#1e3a4f"; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(xk,0); ctx.lineTo(xk,h); ctx.stroke();
      }
    }
  }
}

// === Beat/Sec conversion helpers (추가) ===
function spb(){                 // 1 beat = ? sec
  const bpm = num($("#bpm").value);
  return bpm > 0 ? 60 / bpm : 0;
}
function beatsToSec(beats){ return beats * spb(); }
function secToBeats(sec){ const s = spb(); return s>0 ? sec / s : 0; }

// === Lead seconds resolver (추가) ===
// Circle/Slider 리드는 timeMode에 따라 beats 또는 seconds 해석
function resolveCircleLeadSec(){
  if ($("#timeMode").value === "Beats") {
    const b = num($("#circleLeadBeats").value);
    if (b > 0) return beatsToSec(b);
  }
  return num($("#circleLead").value); // seconds fallback
}
function resolveSliderLeadSec(){
  if ($("#timeMode").value === "Beats") {
    const b = num($("#sliderLeadBeats").value);
    if (b > 0) return beatsToSec(b);
  }
  return num($("#sliderLead").value); // seconds fallback
}

// === Grid grow speed resolver (추가) ===
// gridGrowUnit=pxps → 그대로(px/s)
// gridGrowUnit=pxpbeat → px/s 로 변환(px/beat × BPM/60)
function resolveGridGrowPxPerSec(){
  const grow = num($("#gridGrow").value);
  const unit = $("#gridGrowUnit")?.value || "pxps";
  if (unit === "pxpbeat") {
    const bpm = num($("#bpm").value);
    return grow * (bpm / 60); // px/s
  }
  return grow; // px/s
}

// === Grid 타깃 해석: 모드에 따라 px로 환산 ===
function resolveGridTargetPx(){
  const mode = $("#gridTargetMode")?.value || "px";
  if (mode === "spacingX") return GRID_CELL;  // 216px
  if (mode === "spacingY") return GRID_CELL;  // 216px
  return num($("#gridTarget").value);         // absolute px
}


// === Grid 타깃 해석: 모드에 따라 px로 환산 (추가) ===
function cellToAbsPos(c, r) {
  const centerX = GRID_LEFT + GRID_CELL * (0.5 + c);        // 756, 972, 1188
  const centerY = 1080 - (GRID_TOP  + GRID_CELL * (0.5 + (2 - r)));  // r=0→아래, r=2→위
  return { x: centerX, y: centerY };
}

function beatInfoAt(t){
  const bpm=num($("#bpm").value); if(bpm<=0) return {valid:false,text:"-"};
  const spb=60/bpm, off=computeOffsetSeconds(); const beats=(t-off)/spb;
  const bar=Math.floor(beats/4)+1, inBar=beats-(bar-1)*4, bnum=Math.floor(inBar)+1, frac=inBar-Math.floor(inBar);
  return {valid:true, text:`${beats.toFixed(3)} (M${bar}, B${bnum}${frac>0?`+${frac.toFixed(3)}`:""})`};
}
function computeOffsetSeconds(){
  const bpm=num($("#bpm").value); const byBeats=$("#timeMode").value==="Beats";
  if(byBeats && bpm>0){ const beats=num($("#startOffsetBeats").value); return beats*(60/bpm); }
  return num($("#startOffsetSec").value);
}
function applyTimeFromWave(t0, t1){
  console.debug("[DBG] applyTimeFromWave.in", {t0, t1});
  if (!Number.isFinite(t0)) return;

  const S   = spb();                     // sec per beat
  const off = computeOffsetSeconds();    // chart offset (sec)

  const toBeatsUI = (secPlayback) => (S > 0 ? (secPlayback - off) / S : 0);
  const snap1ms   = (t) => qms(t);       // 1ms 양자화

  // ✅ 인자 이름과 본문 변수 통일 (secPlayback 사용)
  function fillSingleTime(secPlayback){
    const typ = $("#noteType").value;
    const secMusical = secPlayback - off;                // UI의 "sec"은 음악적 시각으로 표기
    const secStr     = qms(secMusical).toFixed(3);
    const beatStr    = (S>0 ? qms(toBeatsUI(secPlayback)).toFixed(3) : "0.000");

    if (typ === "Grid") {
      $("#judgeTimeSec").value = secStr;
      if (S>0) $("#judgeBeat").value = beatStr;
    } else if (typ === "CircleTap") {
      $("#circleJudgeSec").value = secStr;
      if (S>0) $("#circleJudgeBeat").value = beatStr;
    } else if (typ === "Slider") {
      $("#sliderStartSec").value = secStr;
      if (S>0) $("#sliderStartBeat").value = beatStr;
    } else if (typ === "Bullet") {
      $("#bulletStartSec").value = secStr;
      if (S>0) $("#bulletStartBeat").value = beatStr;
    } else if (typ === "Camera") {
      $("#camStartSec").value = secStr;
      if (S>0) $("#camStartBeat").value = beatStr;
    }
  }

  function fillRange(secA, secB){
    const aS = snap1ms(Math.min(secA, secB));   // playback sec
    const bS = snap1ms(Math.max(secA, secB));
    const dS = qms(Math.max(0, bS - aS));       // duration in sec (offset 무관)
    const aMus = aS - off;                      // 음악적 시작 sec

    const typ = $("#noteType").value;
    if (typ === "Slider") {
      $("#sliderStartSec").value = aMus.toFixed(3);
      $("#sliderDurSec").value   = dS.toFixed(3);
      if (S>0){
        $("#sliderStartBeat").value = qms(toBeatsUI(aS)).toFixed(3);
        $("#sliderDurBeats").value  = qms(dS / S).toFixed(3);
      }
    } else if (typ === "Camera") {
      $("#camStartSec").value = aMus.toFixed(3);
      $("#camDurSec").value   = dS.toFixed(3);
      if (S>0){
        $("#camStartBeat").value = qms(toBeatsUI(aS)).toFixed(3);
        $("#camDurBeats").value  = qms(dS / S).toFixed(3);
      }
    } else {
      // 나머지 타입은 단일 시점 → 위 함수 재사용
      fillSingleTime(aS);
    }
    return aS;
  }

  if (t1 == null) {
    const t = snap1ms(t0);
    fillSingleTime(t);
    if (typeof seekAccurate === "function") seekAccurate(t);
    else audioEl.currentTime = t;
  } else {
    const startSec = fillRange(t0, t1);
    if (typeof seekAccurate === "function") seekAccurate(startSec);
    else audioEl.currentTime = startSec;
  }

  redrawBeat();
  drawWave();
}
function snapTime(t){
  if(!$("#snap").checked) return t; const bpm=num($("#bpm").value); if(bpm<=0) return t;
  const subdiv=parseInt($("#subdiv").value||"8"); const spb=60/bpm; const off=computeOffsetSeconds();
  const rel=(t-off)/spb; const snapped=Math.round(rel*subdiv)/subdiv; return off+snapped*spb;
}
function redrawBeat(){ const t=audioEl.currentTime||0; const bi=beatInfoAt(t); curBeatEl.textContent=bi.valid?bi.text:"-"; drawWave(); }

const rateSelect = $("#playbackRate");

// 일부 브라우저는 피치 보존 플래그가 다릅니다.
function applyPreservePitch(audio, on=true){
  try {
    if ('preservesPitch' in audio) audio.preservesPitch = on;
    if ('mozPreservesPitch' in audio) audio.mozPreservesPitch = on;
    if ('webkitPreservesPitch' in audio) audio.webkitPreservesPitch = on;
  } catch {}
}
// === [CAMERA PREVIEW] helpers: badge, label, guides ===========================
function camLabel(n, t0, t1){
  const parts = [];
  if (n.camAffectHeight) parts.push(`H=${Math.round(n.camHeightPx)}px`);
  if (n.camAffectAngle)  parts.push(`A=${fmt(n.camAngleDegZ)}°`);
  if (n.camAffectCenter) parts.push(`C=(${Math.round(n.camCenterPx?.x||960)},${Math.round(n.camCenterPx?.y||540)})`);
  const ease = (n.camEase && n.camEase.length) ? ` | ${n.camEase}` : "";
  return `CAM ${parts.join(" · ")}  |  ${fmt(t0)}→${fmt(t1)}s${ease}`;
}

function drawBadge(ctx, x, y, text, prog=NaN, maxW=300){
  ctx.save();
  ctx.font = "12px system-ui, sans-serif";
  const padX = 8, padY = 6;
  const textW = Math.min(ctx.measureText(text).width, maxW - padX*2);
  const w = textW + padX*2, h = 22;
  // 배경
  ctx.fillStyle = "rgba(17,32,51,0.92)";
  ctx.strokeStyle = "#264463";
  ctx.lineWidth = 1;
  roundRect(ctx, x, y, w, h, 6, true, true);
  // 텍스트 (overflow 시 잘라서 표시)
  ctx.save();
  ctx.beginPath(); ctx.rect(x+padX, y, w-padX*2, h); ctx.clip();
  ctx.fillStyle = "#dfe7ff";
  ctx.fillText(text, x+padX, y + h - 7);
  ctx.restore();
  // 진행바
  if (!isNaN(prog)){
    const barY = y + h - 3, barH = 2, barW = w - 2;
    ctx.fillStyle = "#1b2f47"; ctx.fillRect(x+1, barY, barW, barH);
    ctx.fillStyle = "#66d9ef"; ctx.fillRect(x+1, barY, Math.max(0, Math.min(barW, barW*prog)), barH);
  }
  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r, fill, stroke){
  if (w<2*r) r=w/2; if (h<2*r) r=h/2;
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y,   x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x,   y+h, r);
  ctx.arcTo(x,   y+h, x,   y,   r);
  ctx.arcTo(x,   y,   x+w, y,   r);
  if (fill) ctx.fill(); if (stroke) ctx.stroke();
}

// (옵션) 센터 가이드 크로스헤어
function drawCenterGuide(ctx, abs, sizePx=28){
  const a = toCXabs(abs);
  const s = (getAR().w / REF_W);
  const half = sizePx * 0.5 * s;
  ctx.save();
  ctx.strokeStyle = "rgba(147,197,253,0.9)";
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(a.x-half, a.y); ctx.lineTo(a.x+half, a.y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(a.x, a.y-half); ctx.lineTo(a.x, a.y+half); ctx.stroke();
  ctx.restore();
}

// === [CAMERA PREVIEW] renderer ===============================================
function drawCameraBadges(nowSec){
  const ar = getAR();
  const PAD = 8, maxW = Math.min(360, ar.w * 0.6);
  let row = 0;

  for (const n of chart.notes){
    if (n.type !== "Camera") continue;

    const t0 = getCameraStartSec(n);
    const d  = Math.max(0, getCameraDurSec(n));
    const t1 = t0 + d;

    // 약간의 패드로 근처에서도 보이게
    if (nowSec < t0 - 0.2 || nowSec > t1 + 0.2) continue;

    const prog = (d > 1e-6) ? clamp01((nowSec - t0) / d) : 1.0;
    const text = camLabel(n, t0, t1);

    // 상단 좌측부터 여러 개면 스택
    const x = ar.x + PAD;
    const y = ar.y + PAD + row * 26; // 배지 높이(22) + 간격(4)
    drawBadge(ctx, x, y, text, prog, maxW);
    if (n.camAffectCenter && n.camCenterPx) {
      drawCenterGuide(ctx, n.camCenterPx);
    }
    row++;
  }
}

function offsetSec(){ return computeOffsetSeconds() || 0; }

function chartTimeToPlaybackSec({sec=null, beat=null}) {
  const byBeats = ($("#timeMode").value === "Beats");
  const S = spb(); // sec per beat
  const present = v => v != null && isFinite(v);

  // timeMode에 따라 “우선값”을 정하고, 없으면 다른 축을 환산
  let baseSec;
  if (byBeats) {
    if (present(beat)) baseSec = beatsToSec(beat);
    else if (present(sec)) baseSec = sec;
    else baseSec = 0;
  } else {
    if (present(sec)) baseSec = sec;
    else if (present(beat)) baseSec = beatsToSec(beat);
    else baseSec = 0;
  }
  // ★ 오프셋 보정
  return baseSec + offsetSec();
}

function setPlaybackRate(r){
  const rate = (r && isFinite(r)) ? r : 1;
  audioEl.playbackRate = rate;
  // 편집용: 음정은 그대로, 속도만 변경 (가능한 브라우저에서)
  applyPreservePitch(audioEl, true);
  // 필요하면 배속 표기 갱신용 배지 등을 업데이트
  // (예) document.querySelector("#rateBadge")?.textContent = `${rate.toFixed(2)}×`;
}

rateSelect?.addEventListener("change", e => {
  const r = parseFloat(e.target.value) || 1;
  (AC_enabled && AC_buf) ? setRateAccurate(r) : setPlaybackRate(r);
});

// 오디오 로드되면 기본 배속 1.0으로 초기화
audioFileInput.addEventListener("change", ()=>{
  // 파일 설정은 기존 onloadedmetadata에서 처리되므로 여기서는 배속만 초기화
  setPlaybackRate(parseFloat(rateSelect?.value || "1") || 1);
});

// 초기 세팅(페이지 로드 직후)
setPlaybackRate(1);

// --- 1 ms time grid ---
const MS_GRID = 0.001;
const qms = (t) => Math.round(t / MS_GRID) * MS_GRID;    // 최근접 1ms
const qmsFloor = (t) => Math.floor(t / MS_GRID) * MS_GRID;
/* ---------- Utils ---------- */
/* ───────── Camera frame preview ───────── */

// 기본 카메라 상태 (Unity Fixed16x9Camera 기준)
const CAM_BASE = {
  heightPx: 1080,            // orthographicSize = height/2
  angleDegZ: 0,
  centerPx: { x: 960, y: 540 }
};

// 카메라 노트의 시작/지속(초) 환산
function getCameraStartSec(n){
  return chartTimeToPlaybackSec({ sec: n.startTime, beat: n.startBeat });
}
function getCameraDurationSec(n){
  const byBeats = ($("#timeMode").value === "Beats");
  if (byBeats) return isFinite(n.durationBeats) ? beatsToSec(n.durationBeats) : (n.duration || 0);
  return isFinite(n.duration) ? n.duration : (isFinite(n.durationBeats) ? beatsToSec(n.durationBeats) : 0);
}

// nowSec 시점의 카메라 상태를 순차 시뮬로 계산 (이벤트 체이닝 반영)
function computeCameraState(nowSec){
  let h = CAM_BASE.heightPx;
  let a = CAM_BASE.angleDegZ;
  let c = { ...CAM_BASE.centerPx };

  // 카메라 노트만 추출 후 시작시간 오름차순
  const cams = (chart.notes || []).filter(n => n.type === "Camera")
    .map(n => ({ n, t0: getCameraStartSec(n), dur: Math.max(0, getCameraDurationSec(n)) }))
    .sort((x,y)=> x.t0 - y.t0);

  // 이징(간단 버전)
  const easeFn = (name) => {
    name = (name || "").toLowerCase();
    if (name.includes("inout")) {
      return t => (t<0.5)? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;
    }
    return t => t; // Linear
  };

  for (const it of cams){
    const n = it.n, t0 = it.t0, d = it.dur, t1 = t0 + d;
    const eh = !!n.camAffectHeight, ea = !!n.camAffectAngle, ec = !!n.camAffectCenter;
    const toH = isFinite(n.camHeightPx) && n.camHeightPx>0 ? n.camHeightPx : h;
    const toA = isFinite(n.camAngleDegZ) ? n.camAngleDegZ : a;
    const toC = (n.camCenterPx && isFinite(n.camCenterPx.x) && isFinite(n.camCenterPx.y)) ? n.camCenterPx : c;
    const ease = easeFn(n.camEase);

    if (nowSec < t0) break;             // 아직 시작 전 → 현 상태 반환
    if (d <= 1e-6 || nowSec >= t1){     // 즉시/완료 상태 → 목표로 스냅
      if (eh) h = toH;
      if (ea) a = toA;
      if (ec) c = { x: toC.x, y: toC.y };
      continue;
    }
    // 진행 중이면 보간 후 바로 반환
    const r = ease(clamp01((nowSec - t0) / d));
    const H = eh ? (h + (toH - h) * r) : h;
    const A = ea ? (a + (toA - a) * r) : a;
    const C = ec ? { x: c.x + (toC.x - c.x) * r, y: c.y + (toC.y - c.y) * r } : c;
    return { heightPx: H, angleDegZ: A, centerPx: C };
  }

  return { heightPx: h, angleDegZ: a, centerPx: c };
}

// 회전 사각형(절대 px) 테두리만 그리기
function drawRotatedRectAbs(ctx, centerAbs, widthPx, heightPx, angleDeg, stroke="#ffd48a", lineW=2, dash=[6,4]){
  const s = (getAR().w / REF_W);              // px → 캔버스 스케일
  const cx = toCXabs(centerAbs).x;
  const cy = toCXabs(centerAbs).y;
  const w = widthPx * s, h = heightPx * s;
  const r = (angleDeg || 0) * Math.PI/180;

  // 사각형 4꼭짓점(로컬 → 회전 → 월드)
  const pts = [
    {x: -w/2, y: -h/2},
    {x:  w/2, y: -h/2},
    {x:  w/2, y:  h/2},
    {x: -w/2, y:  h/2},
  ].map(p => {
    const xr = p.x * Math.cos(r) - p.y * Math.sin(r) + cx;
    const yr = p.x * Math.sin(r) + p.y * Math.cos(r) + cy;
    return {x:xr, y:yr};
  });

  ctx.save();
  ctx.lineWidth = lineW;
  ctx.strokeStyle = stroke;
  if (dash) ctx.setLineDash(dash);
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}

// 미니 배지(선택)
function drawCamBadge(ctx, text, px, py){
  ctx.save();
  ctx.font = "12px system-ui, sans-serif";
  const pad = 6;
  const w = ctx.measureText(text).width + pad*2;
  const h = 20;
  ctx.fillStyle = "rgba(17,32,51,0.9)";
  ctx.fillRect(px, py, w, h);
  ctx.strokeStyle = "#264463";
  ctx.strokeRect(px+0.5, py+0.5, w-1, h-1);
  ctx.fillStyle = "#dfe7ff";
  ctx.fillText(text, px+pad, py+h-6);
  ctx.restore();
}

// 현재 시점 nowSec의 카메라 프레임을 그리기
function drawCameraFrame(nowSec){
  const show = document.querySelector("#showCamFrame")?.checked ?? true;
  if (!show) return;

  const st = computeCameraState(nowSec);
  const height = Math.max(1, st.heightPx);
  const width  = height * (16/9);        // Fixed16x9Camera 기준

  // 테두리
  drawRotatedRectAbs(ctx, st.centerPx, width, height, st.angleDegZ, "#ffd48a", 2, [8,5]);

  // 미니 배지 (좌상단)
  const label = `CAM ${Math.round(width)}×${Math.round(height)} @ (${Math.round(st.centerPx.x)},${Math.round(st.centerPx.y)})  rot ${Math.round(st.angleDegZ)}°`;
  drawCamBadge(ctx, label, 10, 10);
}

let rafAcc = null, accTimer = null;

function scheduleAccurateUiLoop(){
  // 1) RAF가 돌고 있지 않으면 시작
  if (!rafAcc){
    const step = () => {
      rafAcc = null;
      try { syncUiAccurate(); } catch(e){ console.error("[syncUiAccurate]", e); }
      if (AC_src) rafAcc = requestAnimationFrame(step);
    };
    rafAcc = requestAnimationFrame(step);
  }
  // 2) 혹시 백그라운드 탭 등으로 RAF가 멈출 수 있으니 30Hz 폴백
  if (!accTimer){
    accTimer = setInterval(()=>{
      try { syncUiAccurate(); } catch(e){ console.error("[syncUiAccurate-interval]", e); }
      if (!AC_src){ clearInterval(accTimer); accTimer = null; }
    }, 33);
  }
}

function stopAccurate(){
  if (AC_src){
    try { AC_src.stop(); } catch {}
    try { AC_src.disconnect(); } catch {}
  }
  AC_src = null;
  if (rafAcc){ cancelAnimationFrame(rafAcc); rafAcc = null; }
  if (accTimer){ clearInterval(accTimer); accTimer = null; }
}

function num(v){ const x=parseFloat(v||"0"); return isNaN(x)?0:x; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function r3(v){ return Math.round(v*1000)/1000; }
function fmt(v){ return (v==null)?"-":r3(v); }
function parseAbsXY(s,def){ const [xs,ys]=(s||def).split(","); return {x:clamp(parseFloat(xs||"960"),0,REF_W), y:clamp(parseFloat(ys||"540"),0,REF_H)}; }

/* ---------- Slider 포인트 리스트 UI ---------- */
(function(){
  const listBox = document.querySelector("#sliderPointList");
  const idxInput = document.querySelector("#ptIndex");
  const xyInput  = document.querySelector("#ptXY");
  if(!listBox || !idxInput || !xyInput) return;

  const getSel = () => Math.max(0, Math.min((pathPtsAbs?.length||1)-1, parseInt(idxInput.value||"0")));
  const setSel = (i) => { idxInput.value = String(Math.max(0, Math.min((pathPtsAbs?.length||1)-1, i))); syncXYFromSel(); renderPointList(); drawView(); };
  function syncXYFromSel(){
    const i = getSel(); const p = pathPtsAbs?.[i];
    if(p) xyInput.value = `${Math.round(p.x)},${Math.round(p.y)}`;
  }

  window.renderPointList = function renderPointList(){
    if(!listBox) return;
    const sel = getSel();
    if(!pathPtsAbs || pathPtsAbs.length===0){
      listBox.innerHTML = '<div class="muted">(no points)</div>';
      return;
    }
    let html = "";
    pathPtsAbs.forEach((p,i)=>{
      const active = (i===sel) ? "active" : "";
      html += `
        <div class="ptrow ${active}" data-i="${i}" style="display:flex;gap:8px;align-items:center;padding:4px 6px;">
          <span class="pill">${i}</span>
          <span>(${Math.round(p.x)}, ${Math.round(p.y)})</span>
          <span style="margin-left:auto;display:flex;gap:6px">
            <button type="button" data-act="sel"  data-i="${i}">Sel</button>
            <button type="button" data-act="edit" data-i="${i}">Edit</button>
          </span>
        </div>`;
    });
    listBox.innerHTML = html;

    listBox.onclick = (e)=>{
      const btn = e.target.closest("button");
      const row = e.target.closest(".ptrow");
      if(btn){
        const act = btn.dataset.act;
        const i   = parseInt(btn.dataset.i,10);
        if(Number.isFinite(i)){
          if(act==="sel"){ setSel(i); }
          else if(act==="edit"){ setSel(i); xyInput.value = `${Math.round(pathPtsAbs[i].x)},${Math.round(pathPtsAbs[i].y)}`; }
        }
      }else if(row){
        const i = parseInt(row.dataset.i,10);
        if(Number.isFinite(i)) setSel(i);
      }
    };
  };

  document.querySelector("#ptPrevBtn")?.addEventListener("click", ()=> setSel(getSel()-1));
  document.querySelector("#ptNextBtn")?.addEventListener("click", ()=> setSel(getSel()+1));

  xyInput.addEventListener("keydown", (e)=>{
    if(e.key === "Enter"){
      const i = getSel();
      const [xs,ys] = (xyInput.value||"960,540").split(",");
      const x = clamp(parseFloat(xs||"960"),0,REF_W);
      const y = clamp(parseFloat(ys||"540"),0,REF_H);
      if(!pathPtsAbs || pathPtsAbs.length===0){
        pathPtsAbs.push({x,y});
      }else{
        pathPtsAbs[i] = {x,y};
      }
      renderPointList(); drawView();
    }
  });

  window.addEventListener("keydown", (e)=>{
    if(document.querySelector("#noteType")?.value !== "Slider") return;
    if(!pathPtsAbs || pathPtsAbs.length===0) return;
    let i = getSel();
    const step = e.shiftKey ? 20 : 5;
    let moved = false;

    if(e.key==="ArrowLeft"){ pathPtsAbs[i].x = clamp(pathPtsAbs[i].x - step, 0, REF_W); moved=true; }
    if(e.key==="ArrowRight"){ pathPtsAbs[i].x = clamp(pathPtsAbs[i].x + step, 0, REF_W); moved=true; }
    if(e.key==="ArrowUp"){ pathPtsAbs[i].y = clamp(pathPtsAbs[i].y + step, 0, REF_H); moved=true; }
    if(e.key==="ArrowDown"){ pathPtsAbs[i].y = clamp(pathPtsAbs[i].y - step, 0, REF_H); moved=true; }
    if(moved){
      xyInput.value = `${Math.round(pathPtsAbs[i].x)},${Math.round(pathPtsAbs[i].y)}`;
      renderPointList(); drawView();
      e.preventDefault();
    }

    if(e.key==="PageUp"){ setSel(i-1); e.preventDefault(); }
    if(e.key==="PageDown"){ setSel(i+1); e.preventDefault(); }
  });

  renderPointList();
})();

// Clear All
function clearAll(){ chart.notes=[]; renderNotes(); drawView(); }

/* ---------- Init ---------- */
function firstLayout(){
  const rect=view.getBoundingClientRect(); const dpr=window.devicePixelRatio||1;
  view.width=Math.floor(rect.width*dpr); view.height=Math.floor(rect.width*dpr); ctx.setTransform(dpr,0,0,dpr,0,0);
  buildGrid(); drawView(); renderNotes(); resizeWaveCanvas(); updateBulletStageLabel();
}
window.addEventListener("load", firstLayout);
setInterval(drawView, 100);
</script>
</body>
</html>






