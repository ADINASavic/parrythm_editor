<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8">
<title>Rhythm Chart Editor (Absolute 1920×1080)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<!-- (필수) JSZip 로드 -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<style>
  :root{--bg:#0f1115;--panel:#171b27;--muted:#8a94aa;--text:#e6e9f2;--accent:#66d9ef;--ok:#6ee7b7;--warn:#fbbf24;--bad:#f87171;--line:#26304a;}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,Segoe UI,Apple SD Gothic Neo,Malgun Gothic,sans-serif}
  header{padding:12px 16px;border-bottom:1px solid var(--line);background:#0b0d12;position:sticky;top:0;z-index:5}
  header h1{margin:0;font-size:16px}
  .wrap{display:grid;grid-template-columns:340px 1fr;gap:12px;padding:12px}
  .card{background:var(--panel);border:1px solid var(--line);border-radius:10px;padding:12px}
  .row{display:flex;gap:8px;align-items:center;margin:6px 0}
  .row label{width:130px;color:var(--muted)}
  input[type="number"],input[type="text"],select{width:100%;background:#0e1220;color:var(--text);border:1px solid #273047;border-radius:8px;padding:8px}
  button{background:#1b2235;color:#e9ecf5;border:1px solid #2d3653;border-radius:8px;padding:8px 10px;cursor:pointer}
  button.primary{background:#163a4a;border-color:#265a6d;color:#dff6ff}
  button.warn{background:#3a2a13;border-color:#6e4f1a;color:#ffd48a}
  button.bad{background:#3a1616;border-color:#6e1c1c;color:#ffd2d2}
  button:disabled{opacity:.5;cursor:not-allowed}
  .grid{display:grid;grid-template-columns:repeat(3,1fr);grid-auto-rows:80px;gap:6px}
  .cell{border:1px dashed #2a314a;border-radius:8px;display:flex;align-items:center;justify-content:center;cursor:pointer}
  .cell.active{outline:2px solid var(--accent)}
  .canvasWrap{display:flex;gap:12px;flex-wrap:wrap}
  /* 캔버스는 반드시 클릭을 받는다 */
  #view { pointer-events: auto; display:block; }
  /* 혹시 뷰 상단에 떠 있는 디버그 배지/오버레이가 있다면 */
  #dbgBadge { pointer-events: none; }

  canvas{background:#0b0f1c;border:1px solid #233;border-radius:8px}
  table{width:100%;border-collapse:collapse;margin-top:8px}
  th,td{border-bottom:1px solid var(--line);padding:8px;font-size:13px}
  th{color:#a5b0c6;text-align:left}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;font-size:11px;border:1px solid #2d3653;color:#b9c2d9}
  .muted{color:var(--muted)}
  .hint{font-size:12px;color:#9aa4bb;margin-top:4px}
  .editbar{display:none;gap:8px;align-items:center;margin:10px 0;padding:8px;border-radius:8px;background:#112033;border:1px solid #264463}
  .editbar.active{display:flex}
  .editrow{background:rgba(102,217,239,0.08)}
  .fullrow{grid-column:1 / -1}
  .wave-toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .timebadge{font-variant-numeric:tabular-nums}
  .sep{width:1px;height:22px;background:#2d3653;margin:0 4px}
  .mini{width:auto}
  #orderToolbar{gap:8px;align-items:center;margin:6px 0}
  .two{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .collapseBtn{background:transparent;border:1px solid #2d3653;color:var(--muted);padding:2px 6px;border-radius:6px;font-size:12px;cursor:pointer}
</style>
</head>
<body>
<header><h1>Rhythm Chart Editor (Absolute 1920×1080)</h1></header>

<div class="wrap">
  <!-- 왼쪽 패널 -->
  <section class="card">

    <hr style="border:none;border-top:1px solid var(--line);margin:10px 0">
    <h3 style="margin:4px 0 8px">Add/Edit Note</h3>
    <div class="row"><label>Type</label>
      <select id="noteType">
        <option value="Grid">Grid</option>
        <option value="Trail">Trail</option>
        <option value="Long">Long</option>
        <option value="CircleTap">CircleTap</option>
        <option value="Slider">Slider</option>
        <option value="Bullet">Bullet</option>
        <option value="Camera">Camera</option>
        <option value="Line">Line</option>
        <option value="Voice">Voice</option>
        <option value="Image">Image</option>
      </select>
    </div>

    <!-- Grid -->
    <div id="gridInputs">
      <div class="hint">오른쪽 3x3 Grid를 클릭해도 설정됩니다.</div>
      <div class="row"><label>Cell (c,r)</label><input id="cellCR" type="text" value="1,1"></div>
      <div class="row"><label>Time (sec)</label><input id="judgeTimeSec" type="number" step="0.001" value="1.000"></div>
      <div class="row"><label>Time (beats)</label><input id="judgeBeat" type="number" step="0.001" value="1.000"></div>
      <div id="longInputs" style="display:none">
        <div class="hint">Longnote: 지속시간을 입력하면 홀드 길이가 결정됩니다.</div>
        <div class="row"><label>Duration (sec)</label><input id="longDurSec" type="number" step="0.001" value="1.000"></div>
        <div class="row"><label>Duration (beats)</label><input id="longDurBeats" type="number" step="0.001" value="1.000"></div>
      </div>
      <button id="btnAddGrid" class="primary" onclick="addGrid()">Add Grid</button>
    </div>

    <!-- Circle -->
    <div id="circleInputs" style="display:none">
      <div class="hint">Absolute 캔버스를 클릭해 좌표를 잡을 수 있습니다. (1920×1080)</div>
      <div class="row"><label>Pos (x,y)</label><input id="circlePos" type="text" value="960,540"></div>
      <div class="row"><label>Time (sec)</label><input id="circleJudgeSec" type="number" step="0.001" value="1.000"></div>
      <div class="row"><label>Time (beats)</label><input id="circleJudgeBeat" type="number" step="0.001" value="1.000"></div>
      <button id="btnAddCircle" class="primary" onclick="addCircle()">Add CircleTap</button>
    </div>

    <!-- Slider -->
    <div id="sliderInputs" style="display:none">
      <div class="hint">Absolute 캔버스에서 점을 찍어 경로를 만듭니다. 숫자로도 수정 가능.</div>
      <div class="row"><label>Start (sec)</label><input id="sliderStartSec" type="number" step="0.001" value="2.000"></div>
      <div class="row"><label>Start (beats)</label><input id="sliderStartBeat" type="number" step="0.001" value="2.000"></div>
      <div class="row"><label>Duration (sec)</label><input id="sliderDurSec" type="number" step="0.001" value="0.800"></div>
      <div class="row"><label>Duration (beats)</label><input id="sliderDurBeats" type="number" step="0.001" value="0.800"></div>
      <label class="mini">
  <input id="sliderCurved" type="checkbox">
  Curve (Bezier)
</label>

      <div class="row two">
        <div><label>Point Index</label><input id="ptIndex" type="number" value="0" step="1"></div>
        <div><label>Point (x,y)</label><input id="ptXY" type="text" value="960,540"></div>
      </div>
      <div class="row" style="gap:6px;flex-wrap:wrap">
        <button onclick="finishPath()">Finish Path</button>
        <button class="warn" onclick="clearPath()">Clear Path</button>
        <button onclick="applyPointXY()">Set Point XY</button>
        <button onclick="insertPointAfter()">Insert After</button>
        <button class="bad" onclick="removePoint()">Remove Point</button>
        <span class="hint">Path pts: <span id="pathCount">0</span></span>
        <div class="row" style="align-items:flex-start">
        <label>Points</label>
        <div style="flex:1">
            <div id="sliderPointList"
                style="max-height:160px;overflow:auto;border:1px solid #2d3653;border-radius:8px;padding:6px;font-size:12px"></div>
            <div style="display:flex;gap:6px;margin-top:6px">
            <button type="button" id="ptPrevBtn">Prev (PgUp)</button>
            <button type="button" id="ptNextBtn">Next (PgDn)</button>
            <span class="muted" style="margin-left:auto">Keys: ← → ↑ ↓ (Shift=20px), PgUp/PgDn, Enter=Apply</span>
            </div>
        </div>
        </div>
      </div>
      <div class="hint">키보드: Arrow = 선택 점 미세이동 (기본 5px, Shift=20px)</div>
      <button id="btnAddSlider" class="primary" onclick="addSlider()">Add Slider</button>
    </div>

    <!-- Bullet -->
    <div id="bulletInputs" style="display:none">
      <div class="row"><label>Spawn (x,y)</label><input id="bulletSpawn" type="text" value="192,540"></div>
      <div class="row"><label>Dock (x,y)</label><input id="bulletDock" type="text" value="960,540"></div>
      <div class="row"><label>Despawn (x,y)</label><input id="bulletDespawn" type="text" value="1728,540"></div>
      <div class="row"><label>Start (sec)</label><input id="bulletStartSec" type="number" step="0.001" value="3.000"></div>
      <div class="row"><label>Start (beats)</label><input id="bulletStartBeat" type="number" step="0.001" value="3.000"></div>
      <div class="row"><label>ToDock (sec)</label><input id="bulletToDockSec" type="number" step="0.001" value="1.000"></div>
      <div class="row"><label>ToDock (beats)</label><input id="bulletToDockBeats" type="number" step="0.001" value="1.000"></div>
      <div class="row"><label>DockToDespawn (sec)</label><input id="bulletDockToDespawnSec" type="number" step="0.001" value="1.000"></div>
      <div class="row"><label>DockToDespawn (beats)</label><input id="bulletDockToDespawnBeats" type="number" step="0.001" value="1.000"></div>
      <div class="row"><label>Canvas click target</label>
        <select id="bulletClickTarget">
          <option value="spawn">Spawn</option>
          <option value="dock">Dock</option>
          <option value="despawn">Despawn</option>
        </select>
      </div>
      <div class="row">
        <label class="mini">
    <input id="bulletCurved" type="checkbox">
    Curve (Bezier)
  </label>
        <label class="mini">
          <input id="bullet3Click" type="checkbox" checked>
          3-Click 배치 (Spawn→Dock→Despawn)
        </label>
        <label class="mini" style="margin-left:12px">
          <input id="bulletAutoAdd" type="checkbox">
          3점 완료 시 자동 Add
        </label>
      </div>
      <div class="hint">
        <span id="bulletStageLabel">Stage: Spawn을 클릭하세요</span>
      </div>
      <button id="btnAddBullet" class="primary" onclick="addBullet()">Add Bullet</button>
      <div class="hint">Absolute 캔버스 클릭으로 선택된 target 좌표를 세팅할 수 있습니다.</div>
    </div>

    <!-- [CAMERA] -->
<div id="cameraInputs" style="display:none">
  <div class="hint">카메라 트윈: 절대 높이(px) / 각도(도) / 센터(px). 비트/초 중 원하는 축만 체크.</div>

  <div class="row two">
    <div><label>Start (sec)</label><input id="camStartSec" type="number" step="0.001" value="5.000"></div>
    <div><label>Duration (sec)</label><input id="camDurSec" type="number" step="0.001" value="0.500"></div>
  </div>
  <div class="row two">
    <div><label>Start (beats)</label><input id="camStartBeat" type="number" step="0.001" value="0.000"></div>
    <div><label>Duration (beats)</label><input id="camDurBeats" type="number" step="0.001" value="0.000"></div>
  </div>

  <div class="row"><label class="mini"><input id="camAffectHeight" type="checkbox" checked> Height(px)</label>
    <input id="camHeightPx" type="number" step="1" value="720">
  </div>
  <div class="row"><label class="mini"><input id="camAffectAngle" type="checkbox"> AngleZ(deg)</label>
    <input id="camAngleDegZ" type="number" step="0.1" value="0">
  </div>
  <div class="row"><label class="mini"><input id="camAffectCenter" type="checkbox"> Center (x,y)</label>
    <input id="camCenterPx" type="text" value="960,540">
  </div>

  <div class="row two">
    <div><label>Ease</label>
      <select id="camEase">
        <option value="">(default)</option>
        <option>linear</option>
        <option>easeInOut</option>
        <option>quadInOut</option>
      </select>
    </div>
    <div style="display:flex;gap:10px;align-items:center">
      <label class="mini"><input id="camUseBeats" type="checkbox"> Use Beats</label>
      <label class="mini"><input id="camUseUIScaling" type="checkbox"> UI Scaling</label>
    </div>
  </div>

  <button id="btnAddCamera" class="primary" onclick="addCamera()">Add Camera</button>
</div>

<div id="voiceInputs" style="display:none">
  <div class="hint">FMOD 이벤트 경로를 그대로 씁니다. 예) <code>event:/ui/voice/line_01</code></div>

  <div class="row"><label>FMOD Event</label>
    <input id="voiceEventPath" type="text" placeholder="event:/...">
  </div>

  <div class="row"><label>Start (sec)</label>
    <input id="voiceStartSec" type="number" step="0.001" value="0.000">
  </div>
  <div class="row"><label>Start (beats)</label>
    <input id="voiceStartBeat" type="number" step="0.001" value="0.000">
  </div>

  <div class="row two">
    <div><label>Fade In (sec)</label><input id="voiceFadeInSec" type="number" step="0.01" value="0.00"></div>
    <div><label>Fade Out (sec)</label><input id="voiceFadeOutSec" type="number" step="0.01" value="0.00"></div>
  </div>

  <div class="row two">
    <div><label>Volume (0~1)</label><input id="voiceVolume" type="number" step="0.01" min="0" max="1" value="1.00"></div>
    <div><label>Pitch</label><input id="voicePitch" type="number" step="0.01" value="1.00"></div>
  </div>

  <button class="primary" onclick="addVoice()">Add Voice</button>
</div>

<!-- Image (overlay sprite) -->
<div id="imageInputs" style="display:none">
  <div class="hint">이미지 에셋 키(또는 리소스 경로)를 지정해서 화면에 띄웁니다.</div>

  <div class="row"><label>Asset Key</label>
    <input id="imgKey" type="text" placeholder="ui/portrait_01">
  </div>

  <div class="row two">
    <div><label>Start (sec)</label><input id="imgStartSec" type="number" step="0.001" value="0.000"></div>
    <div><label>Start (beats)</label><input id="imgStartBeat" type="number" step="0.001" value="0.000"></div>
  </div>
  <div class="row two">
    <div><label>Duration (sec)</label><input id="imgDurSec" type="number" step="0.001" value="2.000"></div>
    <div><label>Duration (beats)</label><input id="imgDurBeats" type="number" step="0.001" value="0.000"></div>
  </div>

  <div class="row two">
    <div><label>Pos (x,y)</label><input id="imgPos" type="text" value="960,540"></div>
    <div><label>Size (w,h px)</label><input id="imgSize" type="text" value="512,512"></div>
  </div>

  <div class="row two">
    <div><label>Alpha (0~1)</label><input id="imgAlpha" type="number" step="0.01" min="0" max="1" value="1.00"></div>
    <div><label>Rotation (deg)</label><input id="imgRotDeg" type="number" step="0.1" value="0.0"></div>
  </div>

  <div class="row two">
    <div><label>Fade In (sec)</label><input id="imgFadeInSec" type="number" step="0.01" value="0.00"></div>
    <div><label>Fade Out (sec)</label><input id="imgFadeOutSec" type="number" step="0.01" value="0.00"></div>
  </div>

  <button class="primary" onclick="addImage()">Add Image</button>
</div>

<div id="styleInputs" style="display:none">
  <div class="hint">Grid 색상 이벤트. Beat/Seconds 중 사용 중인 모드로 채우세요.</div>

  <div class="row">
    <label>Target</label>
    <select id="stTarget">
      <option value="grid-all">grid-all</option>
      <option value="grid-line">grid-line</option>
    </select>

    <label>Index</label>
    <input id="stIndex" type="number" min="0" step="1" value="0" style="width:80px">
  </div>

  <div class="row">
    <label>Time (sec)</label>
    <input id="stTimeSec" type="number" step="0.001" value="0.000" style="width:120px">

    <label>Time (beats)</label>
    <input id="stTimeBeat" type="number" step="0.001" value="0.000" style="width:120px">
  </div>

<div class="row">
  <label>Fade (beats)</label>
  <input id="stFadeBeats" type="number" min="0" step="0.01" value="0.000" style="width:100px">

  <label>Fade (sec)</label>
  <input id="stFadeSec" type="number" min="0" step="0.05" value="0.25" style="width:100px">
</div>


  <div class="row">

    <label>Color</label>
    <input id="stColorText" type="text" value="#ff4444ff" style="width:140px" spellcheck="false">
    <input id="stColorPick" type="color" value="#ff4444" title="RGB picker">
    <label class="mini" style="width:auto">Alpha</label>
    <input id="stAlpha" type="range" min="0" max="255" step="1" value="255" style="width:120px">
    <span id="stAlphaVal" class="muted" style="width:auto">255</span>
  </div>

  <button id="stAddBtn" class="primary">Add Style</button>
</div>


    <div id="editBar" class="editbar">
      <span class="pill">Editing <span id="editLabel" style="font-weight:700"></span></span>
      <button class="primary" onclick="saveEdit()">Save</button>
      <button class="bad" onclick="deleteEdit()">Delete</button>
      <button class="warn" onclick="cancelEdit()">Cancel</button>
    </div>

        <h3 style="margin:4px 0 8px">Chart <button id="chartToggle" class="mini" style="margin-left:8px;padding:2px 6px">▾</button></h3>
    <div id="chartSettings">
    <div class="row"><label>FMOD Event</label>
  <input id="fmodEvent" type="text" placeholder="event:/your/path/here">
</div>
    <div class="row"><label>Title</label><input id="title" type="text" value="New Chart"></div>
    <div class="row"><label>BPM</label><input id="bpm" type="number" value="120" step="0.01"></div>
    <div class="row"><label>Time Mode</label>
      <select id="timeMode"><option value="Seconds">Seconds</option><option value="Beats">Beats</option></select>
    </div>
<div class="row"><label>Song Duration (sec)</label>
  <input id="durationSec" type="number" value="0" step="0.001">
</div>

    <div class="row"><label>Start Offset (sec)</label><input id="startOffsetSec" type="number" value="0" step="0.001"></div>
    <div class="row"><label>Start Offset (beats)</label><input id="startOffsetBeats" type="number" value="0" step="0.001"></div>
    <div class="row"><label>Artist</label><input id="artist" type="text" value="Unknown"></div>
  <div class="row"><label>Preview Start</label><input id="previewStart" type="number" value="5.0" step="0.01"></div>
  <div class="row"><label>Preview Duration</label><input id="previewDuration" type="number" value="10.0" step="0.01"></div>
  <div class="row"><label>Tags (comma)</label><input id="tags" type="text" value="demo"></div>
  <div class="row"><label>Cover</label><input id="coverFile" type="file" accept="image/*"></div>

    <hr style="border:none;border-top:1px solid var(--line);margin:10px 0">
    </div><!-- /chartSettings -->
    <h3 style="margin:4px 0 8px">Spawn Calc Settings <button id="spawnToggle" class="mini" style="margin-left:8px;padding:2px 6px">▾</button></h3>
    <div id="spawnSettings">
    <div class="row"><label>Circle Lead (s)</label><input id="circleLead" type="number" step="0.001" value="1.2"></div>
    <div class="row"><label>Slider Lead (s)</label><input id="sliderLead" type="number" step="0.001" value="1.0"></div>
    <div class="row"><label>Grid Target Size</label><input id="gridTarget" type="number" step="0.001" value="216"></div>
    <div class="row"><label>Grid Grow Speed</label><input id="gridGrow" type="number" step="0.001" value="324"></div>
    <div class="hint">Grid spawn = judge - (targetSize / growSpeed), Circle = judge - circleLead, Slider = start - sliderLead</div>
    <div class="row"><label>Grid Grow Unit</label>
  <select id="gridGrowUnit">
    <option value="pxps" selected>px/sec</option>
    <option value="pxpbeat">px/beat</option>
  </select>
</div>
<div class="row"><label>Circle Lead (beats)</label>
  <input id="circleLeadBeats" type="number" step="0.001" value="0.0">
</div>
<div class="row"><label>Slider Lead (beats)</label>
  <input id="sliderLeadBeats" type="number" step="0.001" value="0.0">
</div>

<!-- Grid 타깃을 픽셀/간격 모드로 선택 -->
<div class="row"><label>Grid Target Mode</label>
  <select id="gridTargetMode">
    <option value="px" selected>Absolute px</option>
    <option value="spacingX">Touch centers (Horizontal)</option>
    <option value="spacingY">Touch centers (Vertical)</option>
  </select>
</div>

<!-- Bullet 크기 설정 (지름 px) -->
<div class="row"><label>Bullet Size (px, diameter)</label>
  <input id="bulletSize" type="number" step="1" value="64">
</div>



    <!-- [ADD] Circle/Slider/Bullet 시뮬 크기 설정 -->
    <div class="row"><label>Circle Target (radius px)</label><input id="circleTargetRadius" type="number" step="1" value="100"></div> <!-- [ADD] -->

    </div><!-- /spawnSettings -->

    <hr style="border:none;border-top:1px solid var(--line);margin:10px 0">
    <div class="row" style="gap:6px">
      <button onclick="downloadJSON()" class="primary">Download JSON</button>
      <button onclick="exportSongZip()" class="primary">Export Song Folder (.zip)</button>
      <label class="pill">LevelChart (schemaVersion=2)</label>
    </div>
    <div class="row" style="gap:6px">
      <input id="importFile" type="file" accept=".json">
      <button class="bad" onclick="clearAll()">Clear All</button>
    </div>
  </section>

  <!-- 오른쪽 작업영역 -->
<section class="card">
  <h3 style="margin:4px 0 12px">Workspace</h3>

  <div class="canvasWrap">

    <!-- 왼쪽: 그리드 -->
    <div>
      <div class="row" style="margin-top:0">
        <span class="pill">3x3 Grid</span>
      </div>
      <div id="grid" class="grid"></div>
    </div>

    <!-- 오른쪽: 미리보기 + 노트 리스트 -->
    <div style="min-width:460px">

      <!-- 상단 툴바 -->
      <div class="row"
           style="margin-top:0;justify-content:space-between;align-items:center">
        <span class="pill">Absolute (1920×1080)</span>

        <div style="display:flex;gap:8px;align-items:center">
          <label class="mini">Aspect
            <select id="aspect">
              <option value="1">1:1</option>
              <option value="1.7777777778" selected>16:9</option>
            </select>
          </label>

          <label class="mini" style="display:flex;gap:6px;align-items:center">
            <input id="showCamFrame" type="checkbox" checked>
            Cam Frame
          </label>

          <span class="muted">
            Click: set pos / path / bullet point
          </span>
        </div>
      </div>

      <!-- ⭐ 핵심 레이아웃 -->
      <div style="
        display:flex;
        gap:12px;
        align-items:flex-start;
      ">

        <!-- 미리보기 -->
        <canvas
          id="view"
          width="440"
          height="440"
          style="
            border:1px solid #26304a;
            border-radius:8px;
            background:#0b1020;
          ">
        </canvas>

        <!-- mini notes (겹침 없음) -->
        <div
          id="miniNotes"
          style="
            width:220px;
            max-height:440px;
            overflow:auto;
            padding:8px;
            background:rgba(10,14,22,0.95);
            border:1px solid #26304a;
            border-radius:8px;
            font-size:12px;
          ">

          <div
            style="
              display:flex;
              justify-content:space-between;
              align-items:center;
              margin-bottom:6px;
            ">
            <strong style="font-size:12px">Notes</strong>

            <select
              id="miniSort"
              style="
                background:transparent;
                color:var(--muted);
                border:none;
                font-size:12px;
              ">
              <option value="time">By Time</option>
              <option value="spawn">By Spawn</option>
            </select>
          </div>

          <div id="miniList"></div>
        </div>

      </div>
    </div>

  </div>

      <section class="card fullrow">
    <h3 style="margin:4px 0 12px">Audio Reference (Waveform & Beat Grid)</h3>
    <div class="wave-toolbar">
      <input id="audioFile" type="file" accept="audio/*">
      <button id="playBtn" disabled>Play</button>
      <button id="pauseBtn" disabled>Pause</button>
      <button id="undoBtn" title="Undo (Ctrl+Z)" disabled>Undo</button>
      <button id="redoBtn" title="Redo (Ctrl+Y)" disabled>Redo</button>
      <span class="pill timebadge">Time: <span id="curTime">0.000</span> / <span id="durTime">0.000</span> s</span>
      <span class="pill timebadge">Beat: <span id="curBeat">-</span></span>
      <span class="sep"></span>
      <label class="mini">Subdivision
        <select id="subdiv">
          <option value="4">1/4</option>
          <option value="8" selected>1/8</option>
          <option value="16">1/16</option>
          <option value="24">1/24</option>
          <option value="32">1/32</option>
          <option value="64">1/64</option>
        </select>
      </label>
      <label class="mini">Speed
  <select id="playbackRate">
    <option value="0.25">0.25×</option>
    <option value="0.5">0.5×</option>
    <option value="1" selected>1.0×</option>
    <option value="1.5">1.5×</option>
    <option value="2">2.0×</option>
  </select>
</label>

      <label class="mini"><input id="snap" type="checkbox" checked> Snap</label>
      <span class="sep"></span>
      <button id="zoomInBtn" disabled>Zoom+</button>
      <button id="zoomOutBtn" disabled>Zoom-</button>
      <button id="fitBtn" disabled>Fit</button>
      <span class="sep"></span>
      <label class="mini">Amp <input id="ampScale" type="range" min="0.2" max="1.0" value="0.6" step="0.05"></label>
      <span class="muted">Click: seek/set time / Drag: pan / Shift+Drag: select / Ctrl+Wheel: zoom</span>
    </div>
    <div style="margin-top:8px">
      <canvas id="wave" height="120" style="width:98%"></canvas>
      <audio id="audio" style="display:none" preload="metadata" crossorigin="anonymous"></audio>
    </div>
  </section>
</div>

    <div class="row" id="orderToolbar">
      <span class="pill">Order</span>
      <button onclick="sortByCreation()">By Creation</button>
      <button onclick="sortByTimeSec()">By Time (sec)</button>
      <button onclick="sortByTimeBeats()">By Time (beats)</button>
      <button onclick="sortBySpawn()">By Spawn</button>
      <button class="primary" onclick="reindexNotes()">Reindex</button>
      <span class="muted">Tip: drag table rows to reorder</span>
    </div>

    <h4 style="margin:8px 0 6px">Notes</h4>
    <table id="notesTable">
      <thead>
        <tr>
          <th>#</th><th>Type</th><th>Data</th><th>Time</th><th>Spawn(s)</th><th></th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <!-- 파형/재생/박자 -->


<script>

const STYLE_TYPE = "Line";

const WAVE_ROW_H   = 18; // 서브레인 한 칸 높이
const WAVE_ROW_GAP = 4;
const WAVE_TYPES = ["Grid","Long","CircleTap","Slider","Bullet","Camera","Line","Voice","Image"];
let waveBlocks = [];     // [{x,y,w,h, idx, type, row, t0,t1}]

const GRID_LEFT   = 648;
const GRID_RIGHT  = 1296;            // inclusive boundary for area end
const GRID_TOP    = 216;
const GRID_BOTTOM = 1080 - 216;      // 864
const GRID_W = GRID_RIGHT - GRID_LEFT;   // 648
const GRID_H = GRID_BOTTOM - GRID_TOP;   // 648
const GRID_CELL = GRID_W / 3;      

const $ = s => document.querySelector(s);
const view = $("#view"); const ctx = view.getContext("2d");
/* ---------- 절대좌표 기준 ---------- */
const REF_W = 1920;
const REF_H = 1080;
// ====== [FIX] missing globals ======
let mouseAbs = { x: REF_W/2, y: REF_H/2 };

// canvas hover -> mouseAbs 갱신
view.addEventListener("pointermove", (e)=>{
  const rect = view.getBoundingClientRect();
  const sx = rect.width  ? (view.width  / rect.width)  : 1;
  const sy = rect.height ? (view.height / rect.height) : 1;
  const mx = (e.clientX - rect.left) * sx;
  const my = (e.clientY - rect.top)  * sy;

  const ar = getAR();
  if (mx < ar.x || mx > ar.x + ar.w || my < ar.y || my > ar.y + ar.h) return;
  mouseAbs = fromCXabs(mx, my);
}, {passive:true});

let styleRuntime = {
  currentColor: rgba(255,255,255,255),
  targetColor: rgba(255,255,255,255),
  fadeStart: 0,
  fadeDur: 0,
  active: false
};

let gridColor = "rgba(255,255,255,1)";
/* ---------- 상태 ---------- */

window.onerror = (msg, src, line, col, err) => {
  console.groupCollapsed("[onerror]", msg);
  console.log("src", src, "line", line, "col", col);
  console.error(err);
  console.groupEnd();
};
window.onunhandledrejection = (e) => {
  console.groupCollapsed("[unhandledrejection]");
  console.error(e.reason || e);
  console.groupEnd();
};

let DBG = true; // 필요시 false
function dlog(tag, obj){ if(!DBG) return; console.log(`[DBG] ${tag}`, obj||""); }

// ─────────────────────────────────────────────────────────────
// [Style] 이벤트 추가(폼 입력 → 차트에 push)
// 요구 id: stTarget, stIndex, stTimeSec, stTimeBeat, stFadeSec, stColorText, stAddBtn
// ─────────────────────────────────────────────────────────────

// 가벼운 보조: Hex를 항상 #rrggbbaa 로 정규화
function normalizeHex8(s){
  if (!s) return '#ffffffff';
  s = s.trim(); if (s[0] !== '#') s = '#'+s;
  if (s.length === 4){ // #rgb
    const r=s[1], g=s[2], b=s[3];
    return `#${r}${r}${g}${g}${b}${b}ff`.toLowerCase();
  }
  if (s.length === 5){ // #rgba
    const r=s[1], g=s[2], b=s[3], a=s[4];
    return `#${r}${r}${g}${g}${b}${b}${a}${a}`.toLowerCase();
  }
  if (s.length === 7)  return (s+'ff').toLowerCase(); // #rrggbb -> #rrggbbaa
  if (s.length === 9)  return s.toLowerCase();        // #rrggbbaa
  return '#ffffffff';
}

// ---- Color RGBA sync (color input + alpha slider + hex8 text) ----
function toHex2(v){ v = Math.max(0, Math.min(255, v|0)); return v.toString(16).padStart(2,'0'); }

function syncFromText(){
  const $t = document.getElementById('stColorText');
  const $p = document.getElementById('stColorPick');
  const $a = document.getElementById('stAlpha');
  const $av = document.getElementById('stAlphaVal');
  if (!$t || !$p || !$a) return;

  const n = normalizeHex8($t.value);
  $t.value = n;                           // 보정된 #rrggbbaa
  $p.value = '#' + n.slice(1,7);          // RGB만
  const a = parseInt(n.slice(7,9), 16);   // 0..255
  $a.value = a;
  if ($av) $av.textContent = String(a);
}

function syncFromPicker(){
  const $t = document.getElementById('stColorText');
  const $p = document.getElementById('stColorPick');
  const $a = document.getElementById('stAlpha');
  const $av = document.getElementById('stAlphaVal');
  if (!$t || !$p || !$a) return;

  const rgb = ($p.value || '#000000').toLowerCase(); // #rrggbb
  const a = Math.max(0, Math.min(255, parseInt($a.value||'255',10)||0));
  $t.value = (rgb + toHex2(a)).toLowerCase();
  if ($av) $av.textContent = String(a);
}

function syncFromAlpha(){
  const $t = document.getElementById('stColorText');
  const $p = document.getElementById('stColorPick');
  const $a = document.getElementById('stAlpha');
  const $av = document.getElementById('stAlphaVal');
  if (!$t || !$p || !$a) return;

  const rgb = ($p.value || '#000000').toLowerCase();
  const a = Math.max(0, Math.min(255, parseInt($a.value||'255',10)||0));
  $t.value = (rgb + toHex2(a)).toLowerCase();
  if ($av) $av.textContent = String(a);
}

// 이벤트 바인딩 (DOM 준비 후 한 번만)
(function initColorSync(){
  const t = document.getElementById('stColorText');
  const p = document.getElementById('stColorPick');
  const a = document.getElementById('stAlpha');
  if (!t || !p || !a) return; // 아직 없으면 패스

  // 입력 이벤트
  p.addEventListener('input',  syncFromPicker);
  a.addEventListener('input',  syncFromAlpha);
  t.addEventListener('change', syncFromText);
  t.addEventListener('blur',   syncFromText);
  // 초기 동기화
  syncFromText();
})();


function addStyleEventFromUI(){
  const target = (document.getElementById('stTarget')?.value) || 'grid-all';
  const index  = parseInt(document.getElementById('stIndex')?.value ?? '0', 10) || 0;
  const fadeBeatsEl = document.getElementById('stFadeBeats');
  // 시간: 사용자가 쓴 값을 "그대로" 저장 (빈칸은 null)
  const timeSecStr  = document.getElementById('stTimeSec')?.value;
  const timeBeatStr = document.getElementById('stTimeBeat')?.value;
  const timeSec  = (timeSecStr  !== '' && timeSecStr  != null) ? Number(timeSecStr)  : null;
  const timeBeat = (timeBeatStr !== '' && timeBeatStr != null) ? Number(timeBeatStr) : null;

  // 페이드: 둘 다 "그대로" 저장 (빈칸은 0으로)
  const fadeSecStr  = document.getElementById('stFadeSec')?.value;
  const fadeBeatStr = document.getElementById('stFadeBeats')?.value;
  const fadeBeat = Number(fadeBeatsEl?.value ?? 0);
  const fadeSec  = Number(document.getElementById('stFadeSec').value ?? 0);

  // 색상은 텍스트 박스 그대로
  const color = (document.getElementById('stColorText')?.value || '#ffffffff').trim().toLowerCase();

  addStyleEvent({
    timeSec, timeBeat,
    target, index,
    color,
    // ⬇️ 단 하나도 변환하지 말고 둘 다 저장
    fadeSec,
    fadeBeat
  });

  if (typeof buildStyleSchedule === 'function') buildStyleSchedule();
  if (typeof drawWave === 'function') drawWave();
  if (typeof renderNotes === 'function') renderNotes(); // 리스트 즉시 갱신
}


function getLineTriggerSec(n){
  const S = spb(); // sec per beat
  const byBeats = (chart.timeMode === "Beats");
  // UI에서 채운 축을 우선 사용 (없으면 다른 축 환산)
  let baseSec = null;
  if (!byBeats) {
    baseSec = Number.isFinite(n.timeSec) ? n.timeSec
              : (Number.isFinite(n.timeBeat) ? (n.timeBeat * (S||1)) : 0);
  } else {
    baseSec = Number.isFinite(n.timeBeat) ? (n.timeBeat * (S||1))
              : (Number.isFinite(n.timeSec) ? n.timeSec : 0);
  }
  return (baseSec || 0) + computeOffsetSeconds(); // ← 오프셋을 항상 초로 더함
}

// 버튼 클릭으로 추가
const _stAddBtn = document.getElementById('stAddBtn');
if (_stAddBtn) {
  _stAddBtn.addEventListener('click', (e)=>{ e.preventDefault(); addStyleEventFromUI(); });
}

function getStyleStartSec(n){
  // Line: timeMode에 따라 timeSec/timeBeat를 환산 + offset 적용
  return chartTimeToPlaybackSec({ sec: n.timeSec, beat: n.timeBeat });
}

// Enter 및 Ctrl+Enter로도 추가(키보드만으로 가능)
window.addEventListener('keydown', (e)=>{
  if (e.key === 'Enter' && !e.ctrlKey && !e.metaKey) {
    const a = document.activeElement;
    if (a && a.closest && a.closest('#styleInputs')) {
      e.preventDefault();
      addStyleEventFromUI();
    }
  }

  // 어디서든 Ctrl/Cmd+Enter → 추가
  if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
    e.preventDefault();
    addStyleEventFromUI();
  }
});


// 화면 우상단에 디버그 배지
(function(){
  const div = document.createElement("div");
  div.id = "dbgBadge";
  div.style.cssText = "position:fixed;right:8px;top:8px;z-index:9999;background:#111a30;color:#cfe4ff;border:1px solid #264463;border-radius:6px;padding:6px 8px;font:12px/1.2 system-ui;white-space:pre;";
  div.textContent = "dbg: init…";
  document.addEventListener("DOMContentLoaded", ()=> document.body.appendChild(div));
})();
function setDbg(text){
  const el = document.getElementById("dbgBadge");
  if (el) el.textContent = text;
}

  // Toggle collapsible sections
  function toggleSection(id, btnId){
    const el = document.getElementById(id);
    const btn = document.getElementById(btnId);
    if(!el) return;
    if(el.style.display === 'none'){
      el.style.display = '';
      if(btn) btn.textContent = '▾';
    }else{
      el.style.display = 'none';
      if(btn) btn.textContent = '▸';
    }
  }
  document.addEventListener('DOMContentLoaded', ()=>{
    const cb = document.getElementById('chartToggle'); if(cb) cb.addEventListener('click', ()=> toggleSection('chartSettings','chartToggle'));
    const sb = document.getElementById('spawnToggle'); if(sb) sb.addEventListener('click', ()=> toggleSection('spawnSettings','spawnToggle'));
  });

  // Prevent numpad from causing window scroll: intercept numpad-originated arrow/page keys
  window.addEventListener('keydown', (e)=>{
    const ae = document.activeElement; const tag = ae && ae.tagName ? ae.tagName.toUpperCase() : '';
    // allow typing in inputs
    if(tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || (ae && ae.isContentEditable)) return;
    try{
      // KeyboardEvent.DOM_KEY_LOCATION_NUMPAD === 3
      if (e.location === 3){
        const preventKeys = ['ArrowUp','ArrowDown','PageUp','PageDown','Home','End','ArrowLeft','ArrowRight'];
        if (preventKeys.includes(e.key) || (e.code && e.code.startsWith('Numpad'))){
          e.preventDefault();
        }
      }
    }catch(err){}
  },{passive:false});

function parseHexColor(hex) {
  // "#RRGGBB" or "#RRGGBBAA"
  if (!hex || hex[0] !== "#") return rgba(255,255,255,255);
  const v = hex.replace("#","");
  const r = parseInt(v.slice(0,2),16);
  const g = parseInt(v.slice(2,4),16);
  const b = parseInt(v.slice(4,6),16);
  const a = v.length >= 8 ? parseInt(v.slice(6,8),16) : 255;
  return rgba(r,g,b,a);
}

function rgba(r,g,b,a255){ return {r,g,b,a:a255}; }
function rgbaLerp(a,b,t){
  return rgba(
    Math.round(a.r + (b.r - a.r)*t),
    Math.round(a.g + (b.g - a.g)*t),
    Math.round(a.b + (b.b - a.b)*t),
    Math.round(a.a + (b.a - a.a)*t)
  );
}

function rgbaToCSS(c){ return `rgba(${c.r},${c.g},${c.b},${(c.a/255).toFixed(3)})`; }

let styleEvents = []; // {tSec, color, fadeSec, target, index, _ref}
function buildStyleSchedule(){
  styleEvents = [];
  const off = computeOffsetSeconds() || 0;

  for (const n of chart.notes || []) {
    if (n.type !== STYLE_TYPE) continue;

    // ▶ timeBeat가 있으면 beats→sec 후 오프셋 더하고,
    //    없으면 timeSec에 오프셋을 더한다.
    const tSec = (isFinite(n.timeBeat))
      ? (beatsToSec(n.timeBeat) + off)
      : ((n.timeSec ?? 0) + off);

    const fadeSec = (n.fadeBeat != null && isFinite(n.fadeBeat))
      ? beatsToSec(n.fadeBeat)
      : (n.fadeSec || 0);

    styleEvents.push({
      tSec,
      fadeSec: Math.max(0, fadeSec),
      color: n.color || "#FFFFFF",
      target: n.target || "grid-all",
      index: n.index|0,
      _ref: n
    });
  }
  styleEvents.sort((a,b)=>a.tSec-b.tSec);
}

let nextStyleIdx = 0;        // 이미 있으면 유지
let _lastStyleNow = -1;


const HEX = "0123456789abcdef";
const to2hex = (n) => {
  n = Math.max(0, Math.min(255, n|0));
  return HEX[(n>>4)&15] + HEX[n&15];
};
function readAlpha(hexOrEmpty){
  const s = (hexOrEmpty||"").trim().toLowerCase();
  if (s.startsWith("#") && s.length === 9) {
    return parseInt(s.slice(7,9), 16); // #rrggbbaa
  }
  return null; // 없으면 null
}

// ── UI elements
const _txt = document.getElementById("stColorText");
const _pick = document.getElementById("stColorPick");

// 픽커 → 텍스트 (알파 유지)
if (_pick && _txt){
  _pick.addEventListener("input", () => {
    const alpha = readAlpha(_txt.value);
    const a = (alpha == null) ? 255 : alpha;   // 알파 없으면 255로
    const hex6 = (_pick.value || "#ffffff").toLowerCase(); // #rrggbb
    _txt.value = (hex6 + to2hex(a));           // #rrggbbaa로 강제
  });

  // 텍스트 → 픽커 (첫 7자리만 적용, 알파는 텍스트에만)
  _txt.addEventListener("input", () => {
    const norm = normalizeHex8(_txt.value);    // 이미 있는 함수
    _txt.value = norm;                          // #rrggbbaa로 정규화
    // color input은 #rrggbb만 받음
    try { _pick.value = norm.slice(0,7); } catch {}
  });
}

// 현재 gridColor를 RGBA 객체로 환산
function currentGridRGBA(){
  // gridColor가 rgba(...) 문자열일 때 파싱 (간단 파서)
  const m = /rgba\((\d+),(\d+),(\d+),([0-1]?\.?\d*)\)/.exec(gridColor);
  if (m) return rgba(+m[1],+m[2],+m[3], Math.round((+m[4])*255));
  // 기본값
  return rgba(255,255,255,255);
}

// 실제 그리드 색 반영
function setGridColor(cRGBA){
  gridColor = rgbaToCSS(cRGBA);
}

function snapshotState(extra={}){
  const span = (viewEnd - viewStart);
  return {
    span, viewStart, viewEnd,
    audioEl_dur: audioEl?.duration || 0,
    AC_buf_dur: (typeof AC_buf !== "undefined" && AC_buf) ? AC_buf.duration : 0,
    audioBuffer_dur: audioBuffer?.duration || 0,
    audioEl_ct: audioEl?.currentTime || 0,
    nowAccurate: (typeof getNowAccurate === "function") ? getNowAccurate() : null,
    isPanning, dragSelecting,
    ...extra
  };
}

function evalStyleColorAt(t){
  let c = _styleBaseColor;
  for (const ev of styleEvents){
    if (ev.tSec > t) break;
    const to   = parseHexColor(ev.color);
    const dur  = Math.max(0, ev.fadeSec || 0);
    const t0   = ev.tSec;
    const t1   = t0 + dur;

    if (dur <= 1e-9 || t >= t1){
      // 페이드 완료(또는 즉시 변경): 목표색으로 스냅
      c = to;
    } else if (t >= t0){
      // 페이드 중: c → to 선형 보간
      const u = (t - t0) / dur;
      c = rgbaLerp(c, to, clamp01(u));
    }
  }
  return c;
}

let chart = {
  schemaVersion: 2,
  title:"New Chart", bpm:120, timeMode:"Seconds",
  startOffset:0, startOffsetBeats:0,
  notes:[]
};
// --- Undo/Redo history
const UNDO_LIMIT = 200;
let undoStack = [];
let redoStack = [];
let historyLock = false; // prevent recording during undo/redo

function pushHistory(){
  if (historyLock) return;
  try{
    const snap = JSON.stringify(chart);
    undoStack.push(snap);
    if (undoStack.length > UNDO_LIMIT) undoStack.shift();
    // new action clears redo
    redoStack = [];
  }catch(err){ console.warn('pushHistory failed', err); }
  if (typeof updateHistoryButtons === 'function') updateHistoryButtons();
}

function applySnapshot(snap){
  if (!snap) return;
  historyLock = true;
  try{
    const obj = JSON.parse(snap);
    chart = obj;
    // sync some UI fields
    try{ if (document.getElementById('title')) document.getElementById('title').value = chart.title || ''; }catch(e){}
    try{ if (document.getElementById('bpm')) document.getElementById('bpm').value = chart.bpm || 120; }catch(e){}
    try{ if (document.getElementById('timeMode')) document.getElementById('timeMode').value = chart.timeMode || 'Seconds'; }catch(e){}
    try{ if (document.getElementById('startOffsetSec')) document.getElementById('startOffsetSec').value = chart.startOffset || 0; }catch(e){}
    try{ if (document.getElementById('startOffsetBeats')) document.getElementById('startOffsetBeats').value = chart.startOffsetBeats || 0; }catch(e){}
    ensureCreatedAt(); renderNotes(); if(typeof buildStyleSchedule==='function') buildStyleSchedule(); resetStyleCursor(getPreviewNowSec()); drawWave(); drawView();
  }catch(err){ console.warn('applySnapshot failed', err); }
  historyLock = false;
}

function undo(){
  if (undoStack.length <= 1) return; // keep current
  const cur = undoStack.pop();
  redoStack.push(cur);
  const prev = undoStack[undoStack.length-1];
  applySnapshot(prev);
}

function redo(){
  if (redoStack.length === 0) return;
  const snap = redoStack.pop();
  undoStack.push(snap);
  applySnapshot(snap);
}

// initial snapshot
pushHistory();
let selectedCell = {c:1,r:1};
let circlePosAbs = {x:REF_W/2,y:REF_H/2};
let pathPtsAbs = []; let pathFinished = false;
let editIndex = null; let editType = null;
let aspect = 1.7777777778;
// Bullet 3-Click 상태
let bulletStage = 0; // 0:spawn, 1:dock, 2:despawn
let bulletTemp = { spawn:null, dock:null, despawn:null };

/* ---------- 좌측 입력 바인딩 ---------- */
$("#title").addEventListener("input", e=> chart.title = e.target.value );
$("#bpm").addEventListener("input", e=> { chart.bpm = num(e.target.value); redrawBeat(); });
$("#timeMode").addEventListener("change", e=> { chart.timeMode = e.target.value; redrawBeat(); });
$("#startOffsetSec").addEventListener("input", e=> { chart.startOffset = num(e.target.value); redrawBeat(); });
$("#startOffsetBeats").addEventListener("input", e=> { chart.startOffsetBeats = num(e.target.value); redrawBeat(); });

$("#noteType").addEventListener("change", e=>{
  const t = e.target.value;
  const isGridFamily = (t==="Grid" || t==="Trail" || t==="Long");
  $("#gridInputs").style.display   = isGridFamily ? "block":"none";
  $("#circleInputs").style.display = (t==="CircleTap") ? "block":"none";
  $("#sliderInputs").style.display = (t==="Slider") ? "block":"none";
  $("#bulletInputs").style.display = (t==="Bullet") ? "block":"none";
  $("#cameraInputs").style.display = (t==="Camera") ? "block":"none";
  $("#styleInputs").style.display  = (t === "Line")       ? "block" : "none";
  $("#voiceInputs").style.display = (t==="Voice") ? "block" : "none";
  $("#imageInputs").style.display = (t==="Image") ? "block" : "none";

  const longInputs = $("#longInputs");
  if (longInputs) longInputs.style.display = (t==="Long") ? "block" : "none";

  const gridBtn = $("#btnAddGrid");
  if (gridBtn) {
    if (t === "Trail") gridBtn.textContent = "Add Trail";
    else if (t === "Long") gridBtn.textContent = "Add Longnote";
    else gridBtn.textContent = "Add Grid";
  }

  refreshAddButtons();
  updateBulletStageLabel();
});

/* ---------- Grid UI ---------- */
function addStyleEvent({ type="Line", timeSec=null, timeBeat=null, target="grid-all", index=0, color="#ffffffff", fadeSec=0, fadeBeat=0 }){
  (chart.notes || (chart.notes=[])).push({
    type: "Line",
    timeSec,
    timeBeat,
    target,
    index,
    color,
    fadeSec,
    fadeBeat   // ← 카멜케이스 정확히
  });
  renderNotes?.();  // 리스트 갱신
  drawWave?.();     // 파형 막대 갱신
}


const gridEl = $("#grid");
function buildGrid(){
  gridEl.innerHTML = "";
  for(let ui_r=0;ui_r<3;ui_r++){
    for(let c=0;c<3;c++){
      const r = 2 - ui_r;
      const div = document.createElement("div");
      div.className = "cell";
      div.textContent = `${c},${r}`;
      div.addEventListener("click", ()=>{
        selectedCell = {c,r};
        $("#cellCR").value = `${c},${r}`;
        refreshGridActive();
      });
      gridEl.appendChild(div);
    }
  }
  $("#cellCR").value = "1,1";
  refreshGridActive();
}
function refreshGridActive(){
  [...gridEl.children].forEach((el,i)=>{
    const c = i%3, ui_r = Math.floor(i/3), r = 2-ui_r;
    el.classList.toggle("active", c===selectedCell.c && r===selectedCell.r);
    el.textContent = `${c},${r}`;
  });
}

/* ---------- Viewport ---------- */

$("#aspect").addEventListener("change", e=>{ aspect = parseFloat(e.target.value)||1; drawView(); });

function getAR(){
  const w=view.width,h=view.height,t=aspect;
  let cw=Math.min(w,h*t), ch=cw/t;
  if(ch>h){ch=h;cw=ch*t}
  return {x:(w-cw)/2,y:(h-ch)/2,w:cw,h:ch};
}
// absolute → canvas pixel
function toCXabs(p){
  const ar=getAR();
  return {
    x: ar.x + (p.x/REF_W) * ar.w,
    y: ar.y + (1 - (p.y/REF_H)) * ar.h
  };
}
// canvas pixel → absolute
function fromCXabs(mx,my){
  const ar=getAR();
  const nx = clamp((mx - ar.x) / ar.w, 0, 1);
  const ny = clamp(1 - (my - ar.y) / ar.h, 0, 1);
  return { x: nx * REF_W, y: ny * REF_H };
}

// ... 기존 변수/함수 선언들 위·아래 상관없이 동일 스코프에 들어가면 됨

// 안전: 캔버스가 꼭 클릭을 받도록
view.style.pointerEvents = 'auto';
view.tabIndex = 0;

// 클릭/터치 모두 커버
view.addEventListener("pointerdown", onViewPointerDown, {passive:true});

function onViewPointerDown(e){
  if (!view) return;
  const rect = view.getBoundingClientRect();
  // DPR 보정 (width/height는 devicePixel 크기)
  const sx = (rect.width  > 0) ? (view.width  / rect.width)  : 1;
  const sy = (rect.height > 0) ? (view.height / rect.height) : 1;
  const mx = (e.clientX - rect.left) * sx;
  const my = (e.clientY - rect.top)  * sy;

  const ar = getAR();
  // AR 영역 밖 클릭은 무시 (의도치 않은 가장자리 클릭 방지)
  if (mx < ar.x || mx > ar.x + ar.w || my < ar.y || my > ar.y + ar.h) return;

  const p = fromCXabs(mx, my);           // 절대 좌표(1920x1080)
  const t = $("#noteType").value;

  // 디버그 배지에 마지막 클릭 정보 표시 (유용)
  setDbg(`click: ${t}\nabs=(${Math.round(p.x)},${Math.round(p.y)})`);

  if (t === "CircleTap"){
    circlePosAbs = p;
    $("#circlePos").value = `${Math.round(p.x)},${Math.round(p.y)}`;
    drawView();
    return;
  }

  if (t === "Slider"){
    // pathFinished 상태면 추가 클릭이 막히므로, 편집 시작 시 자동 해제 옵션
  if (pathFinished && (pathPtsAbs?.length ?? 0) >= 2){
    // 기존 경로 비우고 새로 시작
    pathPtsAbs = [];
    pathFinished = false;
  }
    if (!pathPtsAbs) pathPtsAbs = [];
    pathPtsAbs.push({x:p.x, y:p.y});
    $("#pathCount").textContent = String(pathPtsAbs.length);
    renderPointList();
    drawView();
    return;
  }

  if (t === "Bullet"){
    const three = $("#bullet3Click").checked;
    if (three){
      if (bulletStage === 0){
        bulletTemp.spawn = p;
        $("#bulletSpawn").value = `${Math.round(p.x)},${Math.round(p.y)}`;
        bulletStage = 1;
      } else if (bulletStage === 1){
        bulletTemp.dock = p;
        $("#bulletDock").value = `${Math.round(p.x)},${Math.round(p.y)}`;
        bulletStage = 2;
      } else {
        bulletTemp.despawn = p;
        $("#bulletDespawn").value = `${Math.round(p.x)},${Math.round(p.y)}`;
        bulletStage = 0;
        if ($("#bulletAutoAdd").checked){
          addBullet();
          bulletTemp = { spawn:null, dock:null, despawn:null };
        }
      }
    } else {
      const target = $("#bulletClickTarget").value;
      const s = `${Math.round(p.x)},${Math.round(p.y)}`;
      if      (target === "spawn")   $("#bulletSpawn").value   = s;
      else if (target === "dock")    $("#bulletDock").value    = s;
      else if (target === "despawn") $("#bulletDespawn").value = s;
    }
    updateBulletStageLabel();
    drawView();
    return;
  }
}

function distAbs(a, b){
  return Math.hypot(a.x - b.x, a.y - b.y);
}
// =======================
// Catmull-Rom (Unity와 동일한 클램프 방식)
// =======================
function catmullRom(p0, p1, p2, p3, t){
  const t2 = t*t;
  const t3 = t2*t;
  return {
    x: 0.5 * ((2*p1.x) + (-p0.x + p2.x)*t + (2*p0.x - 5*p1.x + 4*p2.x - p3.x)*t2 + (-p0.x + 3*p1.x - 3*p2.x + p3.x)*t3),
    y: 0.5 * ((2*p1.y) + (-p0.y + p2.y)*t + (2*p0.y - 5*p1.y + 4*p2.y - p3.y)*t2 + (-p0.y + 3*p1.y - 3*p2.y + p3.y)*t3)
  };
}

// ptsAbs: [{x,y}, ...]  (ABS 1920x1080)
// return: 샘플링된 polyline points (ABS)
function sampleCatmullPathAbs(ptsAbs, stepsPerSeg = 16){
  if (!ptsAbs || ptsAbs.length === 0) return [];
  if (ptsAbs.length === 1) return [{ x: ptsAbs[0].x, y: ptsAbs[0].y }];
  if (ptsAbs.length === 2) return [{ x: ptsAbs[0].x, y: ptsAbs[0].y }, { x: ptsAbs[1].x, y: ptsAbs[1].y }];

  const out = [];
  out.push({ x: ptsAbs[0].x, y: ptsAbs[0].y });

  const n = ptsAbs.length;
  for (let i = 0; i < n - 1; i++){
    const p0 = ptsAbs[Math.max(0, i - 1)];
    const p1 = ptsAbs[i];
    const p2 = ptsAbs[i + 1];
    const p3 = ptsAbs[Math.min(n - 1, i + 2)];

    for (let s = 1; s <= stepsPerSeg; s++){
      const t = s / stepsPerSeg;
      out.push(catmullRom(p0, p1, p2, p3, t));
    }
  }
  return out;
}

function drawPolylineAbs(ctx, ptsAbs, stroke, lineW, dash){
  if (!ptsAbs || ptsAbs.length < 2) return;
  ctx.save();
  ctx.strokeStyle = stroke;
  ctx.lineWidth = lineW;
  ctx.setLineDash(dash || []);
  const p0 = toCXabs(ptsAbs[0]);
  ctx.beginPath();
  ctx.moveTo(p0.x, p0.y);
  for (let i = 1; i < ptsAbs.length; i++){
    const p = toCXabs(ptsAbs[i]);
    ctx.lineTo(p.x, p.y);
  }
  ctx.stroke();
  ctx.restore();
}

// curved=true면 (pts>=3) Catmull 샘플링, 아니면 원본 polyline
function drawPathAbs(ctx, ptsAbs, curved, stroke, lineW, dash, stepsPerSeg = 16){
  const pts = (curved && ptsAbs && ptsAbs.length >= 3)
    ? sampleCatmullPathAbs(ptsAbs, stepsPerSeg)
    : ptsAbs;
  drawPolylineAbs(ctx, pts, stroke, lineW, dash);
  return pts; // (필요하면 길이 계산 등에 재사용)
}


function drawBulletPathPreview(ctx){
  if ($("#noteType").value !== "Bullet") return;

  const three = $("#bullet3Click")?.checked === true;
  const curved = $("#bulletCurved")?.checked === true;

  const S = parseAbsXY($("#bulletSpawn")?.value,   null);
  const D = parseAbsXY($("#bulletDock")?.value,    null);
  const E = parseAbsXY($("#bulletDespawn")?.value, null);

  // 3-click이면 bulletStage를 따르고, 아니면 dropdown 타겟 기준으로 stage 계산
  const stage = three
    ? bulletStage
    : ({"spawn":0,"dock":1,"despawn":2}[$("#bulletClickTarget")?.value] ?? 0);

  const ACTIVE   = "rgba(255,180,80,0.85)";
  const INACTIVE = "rgba(255,180,80,0.25)";
  const PREVIEW  = "rgba(255,210,140,0.65)";

  // ---- 확정 경로 ----
  // stage==0: Spawn만 찍는 단계 (아직 선 없음)
  // stage==1: S,D 확정 (S->D 선)
  // stage==2: S,D 확정 + E 찍기 직전/혹은 확정 (3점 경로)
  if (stage >= 1 && S && D){
    // 2점만으로는 Catmull 의미 없으니 그냥 직선
    drawPathAbs(ctx, [S, D], false, ACTIVE, 3, [], 16);
  }

  if (stage >= 2 && S && D && E){
    // 3점이면 curved 토글에 따라 Catmull/Polyline
    drawPathAbs(ctx, [S, D, E], curved, ACTIVE, 3, [], 16);
  }

  // ---- 마우스 프리뷰 ----
  // stage==1: S->mouse (직선)
  if (stage === 1 && S){
    drawPathAbs(ctx, [S, mouseAbs], false, PREVIEW, 2, [4,4], 16);
  }
  // stage==2: S->D->mouse (curved면 Catmull)
  if (stage === 2 && S && D){
    drawPathAbs(ctx, [S, D, mouseAbs], curved, PREVIEW, 2, [4,4], 16);
  }

  // ---- 포인트 표시 ----
  if (S){
    drawCircleAbs(ctx, S, 6, stage===0 ? "#67e8f9" : "#6ee7b7", "rgba(110,231,183,0.15)", 2);
    if (stage===0) drawCircleAbs(ctx, S, 10, "rgba(103,232,249,0.9)", null, 2);
  }
  if (D){
    drawCircleAbs(ctx, D, 6, stage===1 ? "#67e8f9" : "#facc15", "rgba(250,204,21,0.15)", 2);
    if (stage===1) drawCircleAbs(ctx, D, 10, "rgba(103,232,249,0.9)", null, 2);
  }
  if (E){
    drawCircleAbs(ctx, E, 6, stage===2 ? "#67e8f9" : "#f87171", "rgba(248,113,113,0.15)", 2);
    if (stage===2) drawCircleAbs(ctx, E, 10, "rgba(103,232,249,0.9)", null, 2);
  }

  // ---- 안내 텍스트 / 경고 (기존 로직 유지) ----
  const STAGE_TEXT = ["Spawn 위치 클릭","Dock 위치 클릭","Despawn 위치 클릭"];
  ctx.fillStyle = "#e5e7eb";
  ctx.font = "14px monospace";
  ctx.fillText(`Bullet 생성: ${STAGE_TEXT[stage]}`, 16, 24);

  ctx.fillStyle = "#f87171";
  if (S && E && distAbs(S, E) < 20) ctx.fillText("⚠ Spawn과 Despawn이 너무 가까움", 16, 44);
  if (S && D && distAbs(S, D) < 12) ctx.fillText("⚠ Spawn–Dock 거리 너무 짧음", 16, 60);
  if (D && E && distAbs(D, E) < 12) ctx.fillText("⚠ Dock–Despawn 거리 너무 짧음", 16, 76);
}



function drawView(){
  const w=view.width,h=view.height; ctx.clearRect(0,0,w,h);
  ctx.fillStyle="#0b0f1c"; ctx.fillRect(0,0,w,h);
  const ar=getAR(); ctx.fillStyle="#0c1324"; ctx.fillRect(ar.x,ar.y,ar.w,ar.h);
  ctx.strokeStyle="#233"; ctx.strokeRect(ar.x+0.5,ar.y+0.5,ar.w-1,ar.h-1);
  // grid lines (4×4 보조)
  ctx.strokeStyle="#1e2744"; ctx.lineWidth=1;
  for(let i=1;i<4;i++){
    const x=ar.x+i*ar.w/4, y=ar.y+i*ar.h/4;
    ctx.beginPath();ctx.moveTo(x,ar.y);ctx.lineTo(x,ar.y+ar.h);ctx.stroke();
    ctx.beginPath();ctx.moveTo(ar.x,y);ctx.lineTo(ar.x+ar.w,y);ctx.stroke();
  }



  // slider path (editing preview)  [polyline OR catmull]
  if (pathPtsAbs.length >= 2) {
    const curved = $("#sliderCurved")?.checked === true;
    drawPathAbs(ctx, pathPtsAbs, curved, "#6ee7b7", 2, [], 16);
  }




/* ---------- [ADD] Ingame Preview helpers ---------- */

  // 인게임 “지금만” 시뮬 미리보기
  const now = getPreviewNowSec();
  drawIngamePreview(now);
  drawCameraFrame(now);
  drawGridOverlay();

  // bullet edit overlay(현재는 drawBulletPathPreview로 통합됐지만, 호출해도 무해)
  drawBulletEditPreview();


}
function drawBulletEditPreview(){
  drawBulletPathPreview(ctx);
}
function lerp(a,b,t){ return a + (b - a) * t; }
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function within(t,a,b,pad=0){ return t >= (a - pad) && t <= (b + pad); }
// c: 0~2 (왼→오), r: 0~2 (아래=0, 위=2)  ← 기존 인덱싱을 유지
function cellToAbsPos(c, r) {
  const centerX = GRID_LEFT + GRID_CELL * (0.5 + c);        // 648 + 108 + 216*c → 756, 972, 1188
  const centerY = GRID_TOP  + GRID_CELL * (0.5 + (2 - r));  // r=2(위): 324, r=1: 540, r=0: 756
  return { x: centerX, y: centerY };
}
// 교체: px 그대로 받고 내부에서만 스케일
function drawCircleAbs(ctx, abs, radiusPx, stroke="#fff", fill=null, lineW=2){
  const p = toCXabs(abs);
  const s = (getAR().w / REF_W);
  ctx.save();
  ctx.lineWidth = lineW;
  ctx.strokeStyle = stroke;
  if (fill) ctx.fillStyle = fill;
  ctx.beginPath();
  ctx.arc(p.x, p.y, Math.max(0.5, radiusPx * s), 0, Math.PI*2);
  if (fill) ctx.fill();
  ctx.stroke();
  ctx.restore();
}

function addVoice(){
  if (editIndex!==null) return;
  // prefer current preview/playhead time for new notes
  const nowPlayback = qms((typeof getPreviewNowSec === 'function') ? getPreviewNowSec() : 0);
  const musicalNow = nowPlayback - computeOffsetSeconds();
  const beatNow = (spb() > 0) ? snappedBeatsFromSec(nowPlayback) : 0;

  const note = {
    type: "Voice",
    fmodEvent: ($("#voiceEventPath").value || "").trim(),

    startTime:  musicalNow,
    startBeat:  beatNow,

    fadeInSec:  num($("#voiceFadeInSec").value),
    fadeOutSec: num($("#voiceFadeOutSec").value),

    volume: Math.max(0, Math.min(1, num($("#voiceVolume").value))),
    pitch:  num($("#voicePitch").value) || 1
  };
  pushNote(note);
}

function addImage(){
  if (editIndex!==null) return;

  const pos = parseAbsXY($("#imgPos").value, "960,540");
  const size = (function(s){
    const [ws,hs] = (s||"512,512").split(",");
    return { w: Math.max(1, parseFloat(ws)||512), h: Math.max(1, parseFloat(hs)||512) };
  })($("#imgSize").value);

  const nowPlayback = qms((typeof getPreviewNowSec === 'function') ? getPreviewNowSec() : 0);
  const musicalNow = nowPlayback - computeOffsetSeconds();
  const beatNow = (spb() > 0) ? snappedBeatsFromSec(nowPlayback) : 0;

  const note = {
    type: "Image",
    key: ($("#imgKey").value || "").trim(),
    startTime:    musicalNow,
    startBeat:    beatNow,
    duration:     num($("#imgDurSec").value),
    durationBeats:num($("#imgDurBeats").value),

    absPos: { x: clamp(pos.x,0,REF_W), y: clamp(pos.y,0,REF_H) },
    sizePx: { w: size.w, h: size.h },

    alpha:  Math.max(0, Math.min(1, num($("#imgAlpha").value))),
    rotDeg: num($("#imgRotDeg").value) || 0,

    fadeInSec:  num($("#imgFadeInSec").value),
    fadeOutSec: num($("#imgFadeOutSec").value)
  };
  pushNote(note);
}


// 교체: sizePx 그대로 받고 내부에서만 스케일
function drawRectAbs(ctx, centerAbs, sizePx, stroke="#fff", fill=null, lineW=2, radius=8){
  const p = toCXabs(centerAbs);
  const s = (getAR().w / REF_W);
  const w = sizePx * s, h = sizePx * s;
  const x = p.x - w/2, y = p.y - h/2;
  const r = Math.min(radius*s, Math.min(w,h)/2);
  ctx.save();
  ctx.lineWidth = lineW;
  ctx.strokeStyle = stroke;
  if (fill) ctx.fillStyle = fill;
  if (r>0){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,  x+w,y+h, r);
    ctx.arcTo(x+w,y+h,x,  y+h, r);
    ctx.arcTo(x,  y+h,x,  y,   r);
    ctx.arcTo(x,  y,  x+w,y,   r);
    ctx.closePath();
    if (fill) ctx.fill();
    ctx.stroke();
  }else{
    if (fill) ctx.fillRect(x,y,w,h);
    ctx.strokeRect(x,y,w,h);
  }
  ctx.restore();
}

function drawLineAbs(ctx, aAbs, bAbs, stroke="#fff", lineW=2, dash=null){
  const a=toCXabs(aAbs), b=toCXabs(bAbs);
  ctx.save();
  ctx.lineWidth=lineW; ctx.strokeStyle=stroke; if(dash) ctx.setLineDash(dash);
  ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
  ctx.restore();
}
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function polyLengths(pts){ const L=[0]; let acc=0; for(let i=1;i<pts.length;i++){ acc+=dist(pts[i-1],pts[i]); L.push(acc);} return { total:acc, prefix:L }; }
function pointOnPolyline(pts, ratio){
  if(!pts || pts.length===0) return {x:0,y:0};
  if(pts.length===1) return pts[0];
  const { total, prefix } = polyLengths(pts);
  const target = total * clamp01(ratio);
  let i=1; while(i<prefix.length && prefix[i] < target) i++;
  const i0 = Math.max(1, i);
  const segStart = pts[i0-1], segEnd = pts[i0];
  const segBase = prefix[i0-1], segLen = Math.max(1e-6, prefix[i0]-prefix[i0-1]);
  const t = (target - segBase) / segLen;
  return { x: lerp(segStart.x, segEnd.x, t), y: lerp(segStart.y, segEnd.y, t) };
}
function getPreviewNowSec(){
  // 오디오가 로드되어 있고 재생·정지 상관없이 currentTime이 유효하면 그것을 사용
  if (window.audio && isFinite(audio.currentTime) && (audio.duration||0) > 0) {
    return audio.currentTime;
  }
  // 아니면 파형/스크럽에서 관리하는 커서값(없다면 0)
  const t = parseFloat(document.querySelector("#timeScrub")?.value || "0");
  return isFinite(t) ? t : 0;
}


// 교체: drawIngamePreview 내부 Grid/Circle/Slider/Bullet 분기
function drawIngamePreview(nowSec){
  const s = (getAR().w / REF_W);

  const gridTargetPx = resolveGridTargetPx();
  const gridGrowSec  = resolveGridGrowPxPerSec();        // px/s
  const gridLeadSec  = gridTargetPx / gridGrowSec;       // s

  const circleLeadSec = resolveCircleLeadSec();
  const sliderLeadSec = resolveSliderLeadSec();
  const circleR       = Math.max(1, num($("#circleTargetRadius").value));
  drawCameraBadges(nowSec);
  for (const n of chart.notes){

    const isTrail = (n.type === "Grid" && !!n.isTrail);
    const isLongNote = (n.type === "Long") || (n.type === "Grid" && !!n.isLong);

    // --- GRID & TRAIL ---
    if (n.type === "Grid" && !isLongNote){
      const tJ = getNoteTimeSec(n), tS = tJ - gridLeadSec;
      if (nowSec < tS-0.2 || nowSec > tJ+0.2) continue;

      const pos  = cellToAbsPos(n.cell.x, n.cell.y);
      const size = clamp((nowSec - tS) * gridGrowSec, 0, gridTargetPx); // px
      const baseStroke = isTrail ? "#fbbf24" : "#6ee7b7";
      const baseFill   = isTrail ? "rgba(251,191,36,0.24)" : "rgba(110,231,183,0.35)";
      const hiStroke   = isTrail ? "#fcd34d" : "#66d9ef";
      const hiFill     = isTrail ? "rgba(252,211,77,0.16)" : "rgba(102,217,239,0.10)";

      drawRectAbs(ctx, pos, size, baseStroke, null, 3*s, 8);
      drawRectAbs(ctx, pos, gridTargetPx, baseStroke, baseFill, 1.5*s, 8);
      if (Math.abs(nowSec - tJ) < 0.05){
        drawRectAbs(ctx, pos, gridTargetPx*1.06, hiStroke, hiFill, 3*s, 10);
      }
    }

    // --- LONG ---
    else if (isLongNote){
      const cell = n.cell || {x:1,y:1};
      const pos = cellToAbsPos(cell.x, cell.y);
      const tStart = getLongStartSec(n);
      const tEnd   = getLongEndSec(n);
      const tSpawn = tStart - gridLeadSec;
      if (nowSec < tSpawn-0.2 || nowSec > tEnd+0.2) continue;

      const baseStroke = "#6ee7b7";
      const baseFill   = "rgba(110,231,183,0.25)";
      const hiStroke   = "#66d9ef";
      const hiFill     = "rgba(102,217,239,0.12)";

      if (nowSec < tStart){
        const size = clamp((nowSec - tSpawn) * gridGrowSec, 0, gridTargetPx);
        drawRectAbs(ctx, pos, size, baseStroke, null, 3*s, 8);
        drawRectAbs(ctx, pos, gridTargetPx, baseStroke, "rgba(110,231,183,0.18)", 1.5*s, 8);
      } else {
        drawRectAbs(ctx, pos, gridTargetPx, baseStroke, baseFill, 2.5*s, 8);

        const span = Math.max(1e-6, tEnd - tStart);
        const prog = clamp01((nowSec - tStart) / span);
        const half = gridTargetPx * 0.5;
        const blAbs = { x: pos.x - half, y: pos.y - half };
        const trAbs = { x: pos.x + half, y: pos.y + half };
        const bl = toCXabs(blAbs);
        const tr = toCXabs(trAbs);
        const x = Math.min(bl.x, tr.x);
        const width = Math.abs(tr.x - bl.x);
        const yBottom = Math.max(bl.y, tr.y);
        const height = Math.abs(tr.y - bl.y);
        const filled = height * prog;
        if (width > 0 && height > 0){
          ctx.save();
          ctx.fillStyle = "rgba(110,231,183,0.35)";
          ctx.fillRect(x, yBottom - filled, width, filled);
          ctx.restore();
        }

        if (Math.abs(nowSec - tEnd) < 0.05){
          drawRectAbs(ctx, pos, gridTargetPx*1.08, hiStroke, hiFill, 3*s, 10);
        }
      }
    }

    // --- CIRCLE: 반지름(px) 기준, 접근 링 → 판정 ---
    else if (n.type === "CircleTap"){
      const tJ = getNoteTimeSec(n), tS = tJ - circleLeadSec;
      if (nowSec < tS-0.2 || nowSec > tJ+0.2) continue;

      const pos  = n.absPos || {x:REF_W/2,y:REF_H/2};
      const prog = clamp((nowSec - tS)/Math.max(1e-6, circleLeadSec), 0, 1);
      const ringR = lerp(circleR*1.6, circleR, prog);

      drawCircleAbs(ctx, pos, ringR,   "#fbbf24", null, 2*s);
      drawCircleAbs(ctx, pos, circleR, "#6ee7b7", "rgba(110,231,183,0.12)", 2*s);
      if (Math.abs(nowSec - tJ) < 0.05){
        drawCircleAbs(ctx, pos, circleR*1.12, "#66d9ef", "rgba(102,217,239,0.08)", 3*s);
      }
    }

    // --- SLIDER: 리드 동안 헤드 고정 → 시작 이후 진행, 헤드 크기 = Circle과 동일 ---
    else if (n.type === "Slider"){
      const basePts = n.absPath || [];
      if (basePts.length < 2) continue;

      const curved = !!n.sliderCurved;
      const pts = (curved && basePts.length >= 3)
        ? sampleCatmullPathAbs(basePts, 16)
        : basePts;


      const durSec = getSliderDurationSec(n);
      const tStart = getSliderStartSec(n);
      const tEnd   = tStart + durSec;
      const tSpawn = tStart - sliderLeadSec;
      if (nowSec < tSpawn-0.2 || nowSec > tEnd+0.2) continue;

      drawPolylineAbs(ctx, pts, "rgba(185,194,217,0.25)", 4*s, []);


           if (nowSec < tStart) {
       const head0 = pts[0];
       const leadDur = Math.max(1e-6, sliderLeadSec);
       const progLead = clamp((nowSec - tSpawn) / leadDur, 0, 1); // 0→1
      const ringR   = lerp(circleR * 1.8, circleR, progLead);    // 큰 원 → 타깃 반경
       // 바깥(접근) 링
       drawCircleAbs(ctx, head0, ringR,   "rgba(251,191,36,0.85)", null, 2*s);
       // 타깃(정박) 링 희미하게
       drawCircleAbs(ctx, head0, circleR, "rgba(110,231,183,0.7)", "rgba(110,231,183,0.10)", 2*s);
     }



           // === [NEW] 리드(접근) 구간: 테두리가 "다가오는" 효과 ===


      let head = pts[0];
      if (nowSec >= tStart){
        const r = clamp((nowSec - tStart)/Math.max(1e-6, durSec), 0, 1);
        head = pointOnPolyline(pts, r);

        // 진행 강조
        const { total, prefix } = polyLengths(pts);
        const target = total * r;
        ctx.save(); ctx.lineWidth=6*s; ctx.strokeStyle="#6ee7b7"; ctx.beginPath(); let moved=false;
        for (let i=1;i<pts.length;i++){
          const a=pts[i-1], b=pts[i], segS=prefix[i-1], segE=prefix[i];
          const aC=toCXabs(a), bC=toCXabs(b);
          if (segE <= target){ if(!moved){ ctx.moveTo(aC.x,aC.y); moved=true; } ctx.lineTo(bC.x,bC.y); }
          else if (segS < target && segE > target){
            const t=(target-segS)/Math.max(1e-6, segE-segS);
            const mid={x:lerp(a.x,b.x,t), y:lerp(a.y,b.y,t)}, midC=toCXabs(mid);
            if(!moved){ ctx.moveTo(aC.x,aC.y); moved=true; } ctx.lineTo(midC.x,midC.y); break;
          }
        }
        ctx.stroke(); ctx.restore();
      }
      // 헤드(리드 중엔 시작점 고정, 시작 후엔 진행 위치). 크기 = circleR
      drawCircleAbs(ctx, head, circleR, "#66d9ef", "rgba(102,217,239,0.25)", 3*s);
    }

    // --- BULLET: 크기 설정 가능(기본 64px 지름) ---
    else if (n.type === "Bullet"){
      const t0 = getBulletSpawnSec(n);
      const toDock = getBulletToDockSec(n);
      const dockToDespawn = getBulletDockToDespawnSec(n);
      const t1 = t0 + toDock;
      const t2 = t1 + dockToDespawn;

      if (nowSec < t0-0.2 || nowSec > t2+0.2) continue;

      const S = n.bulletSpawnPos;
      const D = n.bulletDockPos;
      const E = n.bulletDespawnPos;

      const curved = !!n.bulletCurved;

      const bulletDiameter = Math.max(1, num($("#bulletSize")?.value || "64")); // px
      const bulletR = bulletDiameter * 0.5;

      // =========================
      // PATH (배경 경로 표시)
      // =========================
      if (!curved){
        // 직선
        drawLineAbs(ctx, S, D, "rgba(217,188,90,0.25)", 2*s, [6,6]);
        drawLineAbs(ctx, D, E, "rgba(217,188,90,0.18)", 2*s, [6,6]);
      } else {
        // Catmull-Rom
        const pathPts = sampleCatmullPathAbs([S, D, E], 24);
        drawPolylineAbs(ctx, pathPts, "rgba(217,188,90,0.22)", 2*s, [6,6]);
      }

      // =========================
      // POSITION (시간 → 위치)
      // =========================
      let cur;

      if (!curved){
        // ---- 기존 선형 보간 ----
        if (nowSec < t1){
          const r = clamp((nowSec - t0)/Math.max(1e-6, t1-t0), 0, 1);
          cur = { x: lerp(S.x, D.x, r), y: lerp(S.y, D.y, r) };
        } else {
          const r = clamp((nowSec - t1)/Math.max(1e-6, t2-t1), 0, 1);
          cur = { x: lerp(D.x, E.x, r), y: lerp(D.y, E.y, r) };
        }
      } else {
        // ---- Catmull 경로 따라 이동 ----
        const steps = 24;
        const sampled = sampleCatmullPathAbs([S, D, E], steps);

        // sampleCatmullPathAbs([S,D,E],steps)는:
        // 0 ~ steps   : S -> D
        // steps ~ end : D -> E
        const seg1 = sampled.slice(0, steps + 1);
        const seg2 = sampled.slice(steps);

        if (nowSec < t1){
          const r = clamp((nowSec - t0)/Math.max(1e-6, t1-t0), 0, 1);
          cur = pointOnPolyline(seg1, r);
        } else {
          const r = clamp((nowSec - t1)/Math.max(1e-6, t2-t1), 0, 1);
          cur = pointOnPolyline(seg2, r);
        }
      }

      // =========================
      // DRAW BULLET
      // =========================
      drawCircleAbs(ctx, cur, bulletR, "#fbbf24", "rgba(251,191,36,0.25)", 2*s);

      // Dock 타이밍 강조
      if (Math.abs(nowSec - t1) < 0.05){
        drawCircleAbs(ctx, D, bulletR*1.3, "#ffd48a", "rgba(255,212,138,0.15)", 3*s);
      }
    }

  }
}

// 정확 모드면 WebAudio 시계, 아니면 HTMLAudio 시계
function nowSec(){
  return (AC_enabled && AC_buf && AC_src)
    ? getNowAccurate()
    : (audioEl.currentTime || 0);
}

function nowSecQms(){
  const t = nowSec();
  return (typeof qms === "function") ? qms(t) : t;
}


function getCameraDurSec(n){  // ← 호환용 별칭
  return getCameraDurationSec(n);
}



function noteTimeWindowSec(n){
  if ((n.type === "Grid" && n.isLong) || n.type === "Long"){
    const t0 = getLongStartSec(n);
    const t1 = getLongEndSec(n);
    return { t0, t1: Math.max(t0 + 0.02, t1) };
  }
  if(n.type==="Camera"){
    const t0 = getCameraStartSec(n);
    const d  = Math.max(0, getCameraDurSec(n));
    const span = Math.max(d, 0.02); // 최소 폭
    return { t0, t1: t0 + span };
  }
  if(n.type==="Slider"){
    const t0 = getSliderStartSec(n);
    const d  = Math.max(0, getSliderDurationSec(n));
    return {t0, t1: t0 + d};
  }
  if(n.type==="Bullet"){
    const t0 = getBulletSpawnSec(n);
    const t1 = t0 + getBulletToDockSec(n) + getBulletDockToDespawnSec(n);
    return {t0, t1};
  } if(n.type==="Voice"){
  const t0 = chartTimeToPlaybackSec({ sec: n.startTime, beat: n.startBeat });
  // 고정 폭(시각화용 최소 폭)
  const spanSec = 0.1;
  return { t0, t1: t0 + spanSec };
  }
  if(n.type==="Image"){
    const t0 = chartTimeToPlaybackSec({ sec: n.startTime, beat: n.startBeat });
    // 지속시간: sec 우선, 없으면 beats 환산
    const byBeats = ($("#timeMode").value === "Beats");
    let dur = 0;
    if (isFinite(n.duration) && n.duration > 0) dur = n.duration;
    else if (isFinite(n.durationBeats) && n.durationBeats > 0) dur = beatsToSec(n.durationBeats, chart.bpm);
    // 최소폭 보장
    const span = Math.max(dur, 0.1);
    return { t0, t1: t0 + span };
  }
    // Grid / CircleTap : 한 점 → 화면에서 보이도록 최소폭 부여
    const t = getNoteTimeSec(n); // 기존 함수 그대로 사용
    const span = Math.max( (viewEnd-viewStart)||1, 1e-3 );
    const minPx = 6; // 최소 시각화 폭(px)
    const minSec = (minPx / (waveCanvas.clientWidth||1)) * span;
    return {t0: t, t1: t + minSec};
  }
function drawNoteBlocks(){
  const lanesTop = 6;
  const STYLE_TYPE = "Line";     // 스타일/색 이벤트(점)
  const LINE_PIXEL_W = 8;        // Line 표시 최소 폭(px)
  const MIN_BOX_PX   = 6;        // 구간 길이 없을 때 최소 시각화 폭(px)
  const VOICE_MIN_PX = 18;    // Voice는 더 두껍게(클릭 편의)
  const IMAGE_MIN_PX = 12;    // Image 최소 폭

  waveBlocks = [];

  // 타입 바스켓 준비
  const typeList = (WAVE_TYPES && WAVE_TYPES.length) ? WAVE_TYPES : ["Grid","Long","CircleTap","Slider","Bullet","Camera","Line","Voice","Image"];
  const allByType = Object.fromEntries(typeList.map(t => [t, []]));

  // 작은 헬퍼들
  const beatsToSecLocal = (b) => (typeof beatsToSec === "function")
    ? beatsToSec(b, chart?.bpm)
    : (b||0) * (60 / (chart?.bpm || 120));

  const durSecGeneric = (n) => {
    // duration 우선, 없으면 durationBeats 환산, 둘 다 없으면 0
    if (Number.isFinite(n?.duration))       return Math.max(0, n.duration);
    if (Number.isFinite(n?.durationBeats))  return Math.max(0, beatsToSecLocal(n.durationBeats));
    return 0;
  };

  const minSecFor1px = ((viewEnd - viewStart) || 1) / Math.max(1, (waveCanvas?.clientWidth || waveCanvas?.width || 1000));
  const minBlockSec  = MIN_BOX_PX * minSecFor1px;

  // 1) 수집
  (chart.notes || []).forEach((n, idx) => {
    const baseType = (n.type === "Grid" && n.isLong) ? "Long" : (n.type || "Grid");
    const t = baseType;

    // Line = 점 이벤트
    if (t === STYLE_TYPE){
      const tSec = getNoteTimeSec(n);  // Line/Voice/Image도 여기서 통일
      if (tSec < viewStart || tSec > viewEnd) return;

      const xc = timeToX(tSec);
      const x0 = xc;
      const x1 = xc + LINE_PIXEL_W*2;
      const color = n.color || "#ffffff";

      allByType[t].push({
        x0, x1, idx, type: t,
        t0: tSec, t1: tSec,
        isPoint: true,
        color
      });
      return;
    }

    // Voice / Image = startBeat(또는 startTime)에서 시작하는 구간형
    if (t === "Voice" || t === "Image"){
      const t0 = getNoteTimeSec(n);     // startBeat / startTime 기반
      const d  = durSecGeneric(n);      // 없으면 0
      const t1 = t0 + LINE_PIXEL_W/5;   // ← 최소 폭 강제!

      const a = Math.max(t0, viewStart);
      const b = Math.min(t1, viewEnd);
      if (b <= a) return;

      const x0 = timeToX(a);
      const x1 = timeToX(b);
      allByType[t].push({ x0, x1, idx, type: t, t0: a, t1: b });
      return;
    }


    // 그 외 기존 노트(구간형 계산은 기존 함수 사용)
    const win = noteTimeWindowSec(n);
    if (!win) return;
    const a = Math.max(win.t0, viewStart);
    const b = Math.min(win.t1, viewEnd);
    if (b <= a) return;

    const x0 = timeToX(a);
    const x1 = timeToX(b);
    allByType[t].push({ x0, x1, idx, type: t, t0: a, t1: b });
  });

  // 2) 타입별 패킹
  const packedByType = {};
  const rowsByType   = {};
  for (const t of typeList){
    const src = allByType[t] || [];
    const { placed, rowCount } = packIntoRows(src);
    packedByType[t] = placed;
    rowsByType[t]   = rowCount;
  }

  // 3) 타입별 베이스 Y
  let yCursor = lanesTop;
  const baseYByType = {};
  for (const t of typeList){
    baseYByType[t] = yCursor;
    const rows = Math.max(1, rowsByType[t] || 0);
    yCursor += rows * (WAVE_ROW_H + WAVE_ROW_GAP) + 6;
  }

  // 4) 그리기 & waveBlocks 적재
  for (const t of typeList){
    const items = packedByType[t] || [];
    for (const it of items){
      const rowY = baseYByType[t] + it.row * (WAVE_ROW_H + WAVE_ROW_GAP);
      const w    = Math.max(2, it.x1 - it.x0);

      // 기본 팔레트
      let fill="rgba(102,217,239,0.18)", stroke="#66d9ef";
      if (t==="Grid"){       fill="rgba(110,231,183,0.20)"; stroke="#6ee7b7"; }
      if (t==="Long"){       fill="rgba(110,231,183,0.28)"; stroke="#6ee7b7"; }
      if (t==="CircleTap"){  fill="rgba(66,180,255,0.20)";  stroke="#44aaff"; }
      if (t==="Slider"){     fill="rgba(102,217,239,0.22)"; stroke="#66d9ef"; }
      if (t==="Bullet"){     fill="rgba(251,191,36,0.24)";  stroke="#fbbf24"; }
      if (t==="Camera"){     fill="rgba(147,197,253,0.20)"; stroke="#93c5fd"; }
      if (t==="Voice"){      fill="rgba(196,181,253,0.22)"; stroke="#a78bfa"; } // purple
      if (t==="Image"){      fill="rgba(244,114,182,0.22)"; stroke="#f472b6"; } // pink

      const noteRef = chart.notes?.[it.idx];
      if (t==="Grid" && noteRef?.isTrail){
        stroke = "#fbbf24";
        fill   = "rgba(251,191,36,0.24)";
      }

      // Line 색상 우선
      if (t===STYLE_TYPE && it.color){
        stroke = it.color;
        fill   = stroke;
      }

      // 박스
      wctx.save();
      if (t===STYLE_TYPE && it.isPoint){
        wctx.globalAlpha = 0.20;
        wctx.fillStyle = fill;
        wctx.fillRect(it.x0, rowY, w, WAVE_ROW_H);
        wctx.globalAlpha = 1.0;
        wctx.strokeStyle = stroke;
        wctx.lineWidth = 2;
        wctx.strokeRect(it.x0+0.5, rowY+0.5, w-1, WAVE_ROW_H-1);
      } else {
        wctx.fillStyle = fill;
        wctx.strokeStyle = stroke;
        wctx.lineWidth = 1;
        wctx.fillRect(it.x0, rowY, w, WAVE_ROW_H);
        wctx.strokeRect(it.x0+0.5, rowY+0.5, w-1, WAVE_ROW_H-1);
      }

      // 라벨
      const label = (() => {
        if (t===STYLE_TYPE) {
          return `#${it.idx+1} ${t}${it.color ? ` ${it.color}` : ""}`;
        }
        if (t==="Grid" && noteRef?.isTrail) {
          return `#${it.idx+1} Trail`;
        }
        if (t==="Long") {
          return `#${it.idx+1} Long`;
        }
        if (t==="Voice") {
          const ev = chart.notes?.[it.idx]?.fmodEvent || "";
          const short = ev ? ev.split('/').slice(-2).join('/') : "Voice";
          return `#${it.idx+1} Voice ${short}`;
        }
        if (t==="Image") {
          const key = chart.notes?.[it.idx]?.imageKey || chart.notes?.[it.idx]?.src || "";
          return `#${it.idx+1} Image ${key}`;
        }
        return `#${it.idx+1} ${t}`;
      })();

      wctx.fillStyle = "#dfe7ff";
      wctx.font = "12px system-ui, sans-serif";
      wctx.fillText(label, it.x0+4, rowY + WAVE_ROW_H - 5);
      wctx.restore();

      // 히트테스트용
      waveBlocks.push({
        x: it.x0, y: rowY, w, h: WAVE_ROW_H,
        idx: it.idx, type: t, row: it.row,
        t0: it.t0, t1: it.t1,
        isPoint: !!it.isPoint,
        color: it.color
      });
    }
  }
}


function beatsToSec(b){ return b * spb(); }

function strokeRectAbs(ctx, x0, y0, x1, y1, stroke="#2d3653", lineW=1){
  const a = toCXabs({x:x0,y:y0});
  const b = toCXabs({x:x1,y:y1});
  const x = Math.min(a.x,b.x), y = Math.min(a.y,b.y);
  const w = Math.abs(a.x-b.x), h = Math.abs(a.y-b.y);
  ctx.save();
  ctx.lineWidth = lineW;
  ctx.strokeStyle = stroke;
  ctx.strokeRect(x+0.5, y+0.5, Math.max(0,w-1), Math.max(0,h-1));
  ctx.restore();
}

function drawGridOverlay(){
  // 런타임 그리드 색 (applyStyleEvents가 갱신)
  const strokeMain = (typeof gridColor === "string" && gridColor.length) ? gridColor : "rgba(255,255,255,1)";

  // ── 1) 외곽 테두리: 약한 글로우 + 메인 스트로크 두 겹
  // 글로우
  ctx.save();
  ctx.globalAlpha = 0.22;
  strokeRectAbs(ctx, GRID_LEFT, GRID_TOP, GRID_RIGHT, GRID_BOTTOM, strokeMain, 4);
  ctx.restore();
  // 메인
  strokeRectAbs(ctx, GRID_LEFT, GRID_TOP, GRID_RIGHT, GRID_BOTTOM, strokeMain, 2);

  // ── 2) 셀 경계선 (수직 2, 수평 2) : 메인색보다 살짝 옅게
  ctx.save();
  ctx.globalAlpha = 0.75;
  for(let i=1;i<3;i++){
    const x = GRID_LEFT + GRID_CELL * i;
    drawLineAbs(ctx, {x, y:GRID_TOP}, {x, y:GRID_BOTTOM}, strokeMain, 1);
    const y = GRID_TOP + GRID_CELL * i;
    drawLineAbs(ctx, {x:GRID_LEFT, y}, {x:GRID_RIGHT, y}, strokeMain, 1);
  }
  ctx.restore();

  // ── 3) 셀 라벨 (c,r) — (0,0)=왼아래 ~ (2,2)=오른위
  ctx.save();
  ctx.font = "12px system-ui, sans-serif";
  ctx.fillStyle = "#9fb3d9";         // 고정 톤(가독성 유지)
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  for(let r=0;r<3;r++){
    for(let c=0;c<3;c++){
      const p = cellToAbsPos(c, r);
      const pc = toCXabs(p);
      ctx.fillText(`${c},${r}`, pc.x, pc.y);
    }
  }
  ctx.restore();
}


function getSliderStartSec(n){
  return chartTimeToPlaybackSec({ sec: n.startTime, beat: n.startBeat });
}
function getSliderDurationSec(n){
  // 지속시간은 오프셋과 무관 → mode 우선순위만 유지
  const byBeats = ($("#timeMode").value === "Beats");
  if (byBeats) return isFinite(n.durationBeats) ? beatsToSec(n.durationBeats) : (n.duration || 0);
  return isFinite(n.duration) ? n.duration : (isFinite(n.durationBeats) ? beatsToSec(n.durationBeats) : 0);
}

function getLongStartSec(n){
  return chartTimeToPlaybackSec({ sec: n.startTime, beat: n.startBeat });
}

function getLongDurationSec(n){
  const byBeats = ($("#timeMode").value === "Beats");
  const durSec = isFinite(n.duration) ? n.duration : undefined;
  const durBeatSec = isFinite(n.durationBeats) ? beatsToSec(n.durationBeats) : undefined;
  let d;
  if (byBeats) d = (durBeatSec != null && durBeatSec > 0) ? durBeatSec : durSec;
  else d = (durSec != null && durSec > 0) ? durSec : durBeatSec;

  if (!isFinite(d) || d <= 0){
    const start = getLongStartSec(n);
    const release = chartTimeToPlaybackSec({ sec: n.judgeTime, beat: n.judgeBeat });
    const diff = release - start;
    if (isFinite(diff) && diff > 0) d = diff; else d = 0;
  }
  return Math.max(0, d || 0);
}

function getLongEndSec(n){
  const start = getLongStartSec(n);
  const dur = getLongDurationSec(n);
  if (dur > 0) return start + dur;
  const release = chartTimeToPlaybackSec({ sec: n.judgeTime, beat: n.judgeBeat });
  return Math.max(start, release);
}

// 불릿 구간도 동일하게 초로 환산
function getBulletSpawnSec(n){
  return chartTimeToPlaybackSec({ sec: n.bulletSpawnTime, beat: n.bulletSpawnBeat });
}
function getBulletToDockSec(n){
  const byBeats = $("#timeMode").value === "Beats";
  if (byBeats) return (isFinite(n.bulletToDockBeats) ? beatsToSec(n.bulletToDockBeats) : (n.bulletToDockDuration||0));
  return (isFinite(n.bulletToDockDuration) ? n.bulletToDockDuration : (isFinite(n.bulletToDockBeats) ? beatsToSec(n.bulletToDockBeats) : 0));
}
function getBulletDockToDespawnSec(n){
  const byBeats = $("#timeMode").value === "Beats";
  if (byBeats) return (isFinite(n.bulletDockToDespawnBeats) ? beatsToSec(n.bulletDockToDespawnBeats) : (n.bulletDockToDespawnDuration||0));
  return (isFinite(n.bulletDockToDespawnDuration) ? n.bulletDockToDespawnDuration : (isFinite(n.bulletDockToDespawnBeats) ? beatsToSec(n.bulletDockToDespawnBeats) : 0));
}

/* ---------- Slider path helpers ---------- */
function finishPath(){ pathFinished=true; }
function clearPath(){ pathPtsAbs=[]; pathFinished=false; $("#pathCount").textContent="0"; renderPointList(); drawView(); }
function applyPointXY(){
  const i = Math.max(0, Math.min(pathPtsAbs.length-1, parseInt($("#ptIndex").value||"0")));
  const [xs,ys] = ($("#ptXY").value||"960,540").split(",");
  const x=clamp(parseFloat(xs||"960"),0,REF_W), y=clamp(parseFloat(ys||"540"),0,REF_H);
  if(pathPtsAbs.length===0){ pathPtsAbs.push({x,y}); } else { pathPtsAbs[i]={x,y}; }
  $("#ptIndex").value = String(i); renderPointList(); drawView();
}
function insertPointAfter(){
  if(pathPtsAbs.length===0){ applyPointXY(); $("#pathCount").textContent="1"; return; }
  const i = Math.max(0, Math.min(pathPtsAbs.length-1, parseInt($("#ptIndex").value||"0")));
  const [xs,ys] = ($("#ptXY").value||"960,540").split(",");
  const x=clamp(parseFloat(xs||"960"),0,REF_W), y=clamp(parseFloat(ys||"540"),0,REF_H);
  pathPtsAbs.splice(i+1,0,{x,y}); $("#ptIndex").value=String(i+1);
  $("#pathCount").textContent=String(pathPtsAbs.length); renderPointList(); drawView();
}
function removePoint(){
  if(pathPtsAbs.length===0) return;
  const i = Math.max(0, Math.min(pathPtsAbs.length-1, parseInt($("#ptIndex").value||"0")));
  pathPtsAbs.splice(i,1);
  $("#ptIndex").value=String(Math.max(0,i-1));
  $("#pathCount").textContent=String(pathPtsAbs.length); renderPointList(); drawView();
}

/* ---------- 통합 키다운 핸들러 ---------- */
window.addEventListener("keydown",(e)=>{
  // Slider: 화살표로 선택 점 미세 이동
  if($("#noteType").value==="Slider" && pathPtsAbs.length>0){
    let i = Math.max(0, Math.min(pathPtsAbs.length-1, parseInt($("#ptIndex").value||"0")));
    let step = e.shiftKey ? 20 : 5; // px
    let p = pathPtsAbs[i];
    let moved = false;
    if(e.key==="ArrowLeft"){ p.x=clamp(p.x-step,0,REF_W); moved=true; }
    if(e.key==="ArrowRight"){ p.x=clamp(p.x+step,0,REF_W); moved=true; }
    if(e.key==="ArrowUp"){ p.y=clamp(p.y+step,0,REF_H); moved=true; }
    if(e.key==="ArrowDown"){ p.y=clamp(p.y-step,0,REF_H); moved=true; }
    if(moved){ $("#ptXY").value = `${Math.round(p.x)},${Math.round(p.y)}`; renderPointList(); drawView(); e.preventDefault(); }
  }
});

function updateBulletStageLabel(){
  const el = $("#bulletStageLabel"); if(!el) return;
  const names = ["Spawn", "Dock", "Despawn"];
  const done = (p)=> p?`(${Math.round(p.x)},${Math.round(p.y)})`:"(미정)";
  const s = bulletStage;
  el.textContent = `Stage: ${names[s]}을 클릭하세요  |  S${done(bulletTemp.spawn)}  →  Dk${done(bulletTemp.dock)}  →  De${done(bulletTemp.despawn)}`;
}

/* ---------- Add Note ---------- */
function addGrid(){
  if(editIndex!==null) return;
  const [cs,rs] = ($("#cellCR").value||"1,1").split(",");
  const c=parseInt(cs||"1"), r=parseInt(rs||"1");
  // use preview/playhead time to set timing so note follows playhead
  const nowPlayback = qms((typeof getPreviewNowSec === 'function') ? getPreviewNowSec() : 0);
  const judgeTime = nowPlayback - computeOffsetSeconds();
  const judgeBeat = (spb() > 0) ? snappedBeatsFromSec(nowPlayback) : num($("#judgeBeat").value);
  const noteType = $("#noteType").value;

  if (noteType === "Trail") {
    pushNote({
      type:"Grid",
      cell:{x:c,y:r},
      judgeTime,
      judgeBeat,
      isTrail:true,
      isLong:false
    });
    return;
  }

  if (noteType === "Long") {
    let duration = Math.max(0, num($("#longDurSec").value));
    let durationBeats = Math.max(0, num($("#longDurBeats").value));

    if (duration <= 0 && durationBeats > 0) {
      duration = beatsToSec(durationBeats);
    }
    if (durationBeats <= 0 && duration > 0) {
      const spbVal = spb();
      if (spbVal > 0) durationBeats = duration / spbVal;
    }

    const pressTime = isFinite(judgeTime) ? judgeTime : 0;
    const pressBeat = isFinite(judgeBeat) ? judgeBeat : 0;

    pushNote({
      type:"Long",
      cell:{x:c,y:r},
      startTime: pressTime,
      startBeat: pressBeat,
      duration: Math.max(0, duration),
      durationBeats: Math.max(0, durationBeats),
      judgeTime: pressTime,
      judgeBeat: pressBeat,
      isLong:true,
      isTrail:false
    });
    return;
  }

  pushNote({type:"Grid", cell:{x:c,y:r}, judgeTime, judgeBeat, isTrail:false, isLong:false});
}
function addCircle(){
  if(editIndex!==null) return;
  const nowPlayback = qms((typeof getPreviewNowSec === 'function') ? getPreviewNowSec() : 0);
  const judgeTime = nowPlayback - computeOffsetSeconds();
  const judgeBeat = (spb() > 0) ? snappedBeatsFromSec(nowPlayback) : num($("#circleJudgeBeat").value);
  const [xs,ys] = ($("#circlePos").value||"960,540").split(",");
  const x=clamp(parseFloat(xs||"960"),0,REF_W), y=clamp(parseFloat(ys||"540"),0,REF_H);
  pushNote({type:"CircleTap", absPos:{x,y}, judgeTime, judgeBeat});
}
function addSlider(){
  if(editIndex!==null) return;
  if(pathPtsAbs.length<2){ alert("Slider path needs at least 2 points"); return; }
  const nowPlayback = qms((typeof getPreviewNowSec === 'function') ? getPreviewNowSec() : 0);
  const startTime = nowPlayback - computeOffsetSeconds();
  const startBeat = (spb() > 0) ? snappedBeatsFromSec(nowPlayback) : num($("#sliderStartBeat").value);
  const duration=num($("#sliderDurSec").value), durationBeats=num($("#sliderDurBeats").value);
  pushNote({type:"Slider", absPath: pathPtsAbs.map(p=>({x:Math.round(p.x),y:Math.round(p.y)})),
            startTime, startBeat, duration, durationBeats, sliderCurved: $("#sliderCurved")?.checked === true
});
  clearPath();
}
function evalBulletSegment(A, C, B, r, curved){
  if (!curved) {
    return {
      x: lerp(A.x, B.x, r),
      y: lerp(A.y, B.y, r)
    };
  }
  // quadratic bezier
  const u = 1 - r;
  return {
    x: u*u*A.x + 2*u*r*C.x + r*r*B.x,
    y: u*u*A.y + 2*u*r*C.y + r*r*B.y
  };
}

function addBullet(){
  if(editIndex!==null) return;
  const spawn = parseAbsXY($("#bulletSpawn").value,"192,540");
  const dock  = parseAbsXY($("#bulletDock").value,"960,540");
  const desp  = parseAbsXY($("#bulletDespawn").value,"1728,540");
  const nowPlayback = qms((typeof getPreviewNowSec === 'function') ? getPreviewNowSec() : 0);
  const startSec = nowPlayback - computeOffsetSeconds();
  const startBeat = (spb() > 0) ? snappedBeatsFromSec(nowPlayback) : num($("#bulletStartBeat").value);
  const toDockSec=num($("#bulletToDockSec").value), toDockBeats=num($("#bulletToDockBeats").value);
  const dockToDespawnSec=num($("#bulletDockToDespawnSec").value), dockToDespawnBeats=num($("#bulletDockToDespawnBeats").value);
    pushNote({
        type:"Bullet",

        bulletSpawnPos:{x:spawn.x, y:spawn.y},
        bulletDockPos:{x:dock.x, y:dock.y},
        bulletDespawnPos:{x:desp.x, y:desp.y},

        bulletSpawnTime:startSec,
        bulletSpawnBeat:startBeat,

        bulletToDockDuration:toDockSec,
        bulletToDockBeats:toDockBeats,

        bulletDockToDespawnDuration:dockToDespawnSec,
        bulletDockToDespawnBeats:dockToDespawnBeats,

        // 추가
        bulletCurved: $("#bulletCurved")?.checked === true
    });

  if($("#bullet3Click").checked){ bulletStage = 0; bulletTemp = { spawn:null, dock:null, despawn:null }; updateBulletStageLabel(); drawView(); }
}

function addCamera(){
  if(editIndex!==null) return;
  // Use preview/playhead time as default start for newly added camera notes
  const nowPlayback = qms((typeof getPreviewNowSec === 'function') ? getPreviewNowSec() : 0);
  const startTime = nowPlayback - computeOffsetSeconds();
  const startBeat = (spb() > 0) ? snappedBeatsFromSec(nowPlayback) : num($("#camStartBeat").value);
  const duration  = num($("#camDurSec").value);
  const durationBeats = num($("#camDurBeats").value);

  const camAffectHeight = $("#camAffectHeight").checked;
  const camAffectAngle  = $("#camAffectAngle").checked;
  const camAffectCenter = $("#camAffectCenter").checked;

  const camHeightPx  = num($("#camHeightPx").value);
  const camAngleDegZ = num($("#camAngleDegZ").value);
  const [xs,ys] = ($("#camCenterPx").value||"960,540").split(",");
  const camCenterPx = { x: clamp(parseFloat(xs||"960"),0,REF_W),
                        y: clamp(parseFloat(ys||"540"),0,REF_H) };

  const camEase = ($("#camEase").value||"").trim();
  const camUseBeats = $("#camUseBeats").checked;
  const camUseUIScaling = $("#camUseUIScaling").checked;

  // 간단 검증(선택된 축만)
  if (camAffectHeight && !(camHeightPx>0)) { alert("Height(px) > 0 필요"); return; }
  if (camAffectCenter && (!isFinite(camCenterPx.x)||!isFinite(camCenterPx.y))) { alert("Center (x,y) 확인"); return; }

  pushNote({
    type:"Camera",
    startTime, startBeat, duration, durationBeats,
    camAffectHeight, camAffectAngle, camAffectCenter,
    camHeightPx, camAngleDegZ, camCenterPx,
    camEase, camUseBeats, camUseUIScaling
  });
}

function pushNote(obj){
  ensureCreatedAt(); obj._id = rid(); obj._createdAt = Date.now();
  chart.notes.push(obj); renderNotes();

  // ★ Line(스타일) 노트일 때 스케줄 갱신
  if (obj.type === STYLE_TYPE) {
    buildStyleSchedule();
    resetStyleCursor(getPreviewNowSec());
  }
  // record history
  pushHistory();
}

/* ---------- Edit ---------- */
function startEdit(i){
  const n=chart.notes[i]; editIndex=i; editType=n.type;
  const isTrail = (n.type === "Grid" && !!n.isTrail);
  const isLong  = (n.type === "Long") || (!!n.isLong && n.type === "Grid");
  const uiType  = isLong ? "Long" : (isTrail ? "Trail" : (n.type || "-"));
  editType = uiType;
  $("#editLabel").textContent = `${uiType} #${i+1}`; $("#editBar").classList.add("active");
  $("#noteType").value = uiType; $("#noteType").dispatchEvent(new Event("change"));
  if(isLong){
    const cell = n.cell || {x:1,y:1};
    selectedCell={c:cell.x,r:cell.y}; $("#cellCR").value=`${cell.x},${cell.y}`; refreshGridActive();
    const startSec = n.startTime ?? 0;
    const startBeat = n.startBeat ?? 0;
    const durSec = n.duration ?? Math.max(0, (n.judgeTime ?? 0) - (n.startTime ?? 0));
    const durBeat = n.durationBeats ?? Math.max(0, (n.judgeBeat ?? 0) - (n.startBeat ?? 0));
    $("#longDurSec").value = durSec ?? 0;
    $("#longDurBeats").value = durBeat ?? 0;
    $("#judgeTimeSec").value = n.judgeTime ?? (startSec + durSec);
    $("#judgeBeat").value = n.judgeBeat ?? (startBeat + durBeat);

  }else if(n.type==="Grid"){
    selectedCell={c:n.cell.x,r:n.cell.y}; $("#cellCR").value=`${n.cell.x},${n.cell.y}`;
    $("#judgeTimeSec").value = n.judgeTime??0; $("#judgeBeat").value = n.judgeBeat??0; refreshGridActive();
  }else if(n.type==="CircleTap"){
    const p = n.absPos || {x:REF_W/2,y:REF_H/2};
    $("#circlePos").value = `${Math.round(p.x)},${Math.round(p.y)}`;
    $("#circleJudgeSec").value = n.judgeTime??0; $("#circleJudgeBeat").value = n.judgeBeat??0;
  }else if(n.type==="Slider"){
    pathPtsAbs = (n.absPath||[]).map(p=>({x:p.x,y:p.y})); $("#pathCount").textContent=String(pathPtsAbs.length); pathFinished=false;
    $("#sliderStartSec").value=n.startTime??0; $("#sliderStartBeat").value=n.startBeat??0;
    $("#sliderDurSec").value=n.duration??0; $("#sliderDurBeats").value=n.durationBeats??0;
    $("#sliderCurved").checked = !!n.sliderCurved;

    renderPointList();
  }else if(n.type==="Bullet"){
    const s = n.bulletSpawnPos || {x:192,y:540};
    const d = n.bulletDockPos  || {x:960,y:540};
    const e = n.bulletDespawnPos || {x:1728,y:540};
    $("#bulletSpawn").value = `${Math.round(s.x)},${Math.round(s.y)}`;
    $("#bulletDock").value  = `${Math.round(d.x)},${Math.round(d.y)}`;
    $("#bulletDespawn").value = `${Math.round(e.x)},${Math.round(e.y)}`;
    $("#bulletStartSec").value = n.bulletSpawnTime??0; $("#bulletStartBeat").value = n.bulletSpawnBeat??0;
    $("#bulletToDockSec").value = n.bulletToDockDuration??0; $("#bulletToDockBeats").value = n.bulletToDockBeats??0;
    $("#bulletDockToDespawnSec").value = n.bulletDockToDespawnDuration??0; $("#bulletDockToDespawnBeats").value = n.bulletDockToDespawnBeats??0;
    $("#bulletCurved").checked = !!n.bulletCurved;
  }else if(n.type==="Camera"){
    $("#camStartSec").value  = n.startTime??0;
    $("#camStartBeat").value = n.startBeat??0;
    $("#camDurSec").value    = n.duration??0;
    $("#camDurBeats").value  = n.durationBeats??0;
    $("#camAffectHeight").checked = !!n.camAffectHeight;
    $("#camAffectAngle").checked  = !!n.camAffectAngle;
    $("#camAffectCenter").checked = !!n.camAffectCenter;
    $("#camHeightPx").value  = n.camHeightPx??720;
    $("#camAngleDegZ").value = n.camAngleDegZ??0;
    const cp = n.camCenterPx || {x:960,y:540};
    $("#camCenterPx").value  = `${Math.round(cp.x)},${Math.round(cp.y)}`;
    $("#camEase").value      = n.camEase || "";
    $("#camUseBeats").checked = !!n.camUseBeats;
    $("#camUseUIScaling").checked = !!n.camUseUIScaling;
  } else if (n.type === "Line") {
  // 패널 전환
  document.getElementById("noteType").value = "Line";
  document.getElementById("noteType").dispatchEvent(new Event("change"));

  // 값 채워넣기 (undefined면 공백/0 처리)
  document.getElementById("stTarget").value     = n.target || "grid-all";
  document.getElementById("stIndex").value      = Number.isFinite(n.index) ? n.index : 0;

  document.getElementById("stTimeSec").value    = (n.timeSec  ?? "");
  document.getElementById("stTimeBeat").value   = (n.timeBeat ?? "");

  document.getElementById("stFadeSec").value    = Number.isFinite(n.fadeSec)  ? n.fadeSec  : 0;
  document.getElementById("stFadeBeats").value  = Number.isFinite(n.fadeBeat) ? n.fadeBeat : 0;

  const hex = (n.color && typeof n.color === "string") ? n.color : "#ffffffff";
  document.getElementById("stColorText").value  = hex;
  // color picker는 #RRGGBB만 받으므로 앞 7자리만
  const pick = document.getElementById("stColorPick");
  if (pick) { pick.value = /^#([0-9a-f]{6})/i.test(hex) ? hex.slice(0,7) : "#ffffff"; }
}else if(n.type==="Voice"){
  $("#voiceEventPath").value = n.fmodEvent || "";
  $("#voiceStartSec").value  = n.startTime ?? 0;
  $("#voiceStartBeat").value = n.startBeat ?? 0;
  $("#voiceFadeInSec").value  = n.fadeInSec ?? 0;
  $("#voiceFadeOutSec").value = n.fadeOutSec ?? 0;
  $("#voiceVolume").value = (n.volume ?? 1);
  $("#voicePitch").value  = (n.pitch  ?? 1);

}else if(n.type==="Image"){
  $("#imgKey").value = n.key || "";

  $("#imgStartSec").value   = n.startTime ?? 0;
  $("#imgStartBeat").value  = n.startBeat ?? 0;
  $("#imgDurSec").value     = n.duration ?? 0;
  $("#imgDurBeats").value   = n.durationBeats ?? 0;

  const p = n.absPos || {x:960,y:540};
  $("#imgPos").value = `${Math.round(p.x)},${Math.round(p.y)}`;

  const sz = n.sizePx || {w:512,h:512};
  $("#imgSize").value = `${Math.max(1,Math.round(sz.w))},${Math.max(1,Math.round(sz.h))}`;

  $("#imgAlpha").value   = (n.alpha ?? 1);
  $("#imgRotDeg").value  = (n.rotDeg ?? 0);
  $("#imgFadeInSec").value  = n.fadeInSec ?? 0;
  $("#imgFadeOutSec").value = n.fadeOutSec ?? 0;
  }

  drawView(); renderNotes(); refreshAddButtons(); updateBulletStageLabel();
  // update waveform highlight
  try{ drawWave(); }catch(e){}
}
function saveEdit(){
  if (editIndex === null) return;

  const idx = editIndex;
  const t   = editType;
  const prev = chart.notes[idx];

  if (t === "Long"){
    const [cs,rs] = ($("#cellCR").value||"1,1").split(",");
    const c = parseInt(cs||"1"), r = parseInt(rs||"1");

    let duration = Math.max(0, num($("#longDurSec").value));
    let durationBeats = Math.max(0, num($("#longDurBeats").value));
    const judgeTime = num($("#judgeTimeSec").value);
    const judgeBeat = num($("#judgeBeat").value);

    if (duration <= 0 && durationBeats > 0) duration = beatsToSec(durationBeats);
    if (durationBeats <= 0 && duration > 0) {
      const spbVal = spb();
      if (spbVal > 0) durationBeats = duration / spbVal;
    }

    const pressTime = isFinite(judgeTime) ? judgeTime : 0;
    const pressBeat = isFinite(judgeBeat) ? judgeBeat : 0;

    chart.notes[idx] = {
      ...prev,
      type: "Long",
      cell: {x:c,y:r},
      startTime: pressTime,
      startBeat: pressBeat,
      duration: Math.max(0, duration),
      durationBeats: Math.max(0, durationBeats),
      judgeTime: pressTime,
      judgeBeat: pressBeat,
      isLong: true,
      isTrail: false
    };

  } else if (t === "Grid" || t === "Trail"){ 
    const [cs,rs] = ($("#cellCR").value||"1,1").split(",");
    const c = parseInt(cs||"1"), r = parseInt(rs||"1");
    chart.notes[idx] = {
      ...prev, type:"Grid",
      cell:{x:c,y:r},
      judgeTime:num($("#judgeTimeSec").value),
      judgeBeat:num($("#judgeBeat").value),
      isTrail: (t === "Trail"),
      isLong: false
    };

  } else if (t === "CircleTap"){
    const [xs,ys] = ($("#circlePos").value||"960,540").split(",");
    const x = clamp(parseFloat(xs||"960"),0,REF_W);
    const y = clamp(parseFloat(ys||"540"),0,REF_H);
    chart.notes[idx] = {
      ...prev, type:"CircleTap",
      absPos:{x,y},
      judgeTime:num($("#circleJudgeSec").value),
      judgeBeat:num($("#circleJudgeBeat").value)
    };

  } else if (t === "Slider"){
    if (pathPtsAbs.length < 2){ alert("Path needs >= 2 points"); return; }
    chart.notes[idx] = {
      ...prev, type:"Slider",
      absPath: pathPtsAbs.map(p=>({x:Math.round(p.x),y:Math.round(p.y)})),
      startTime:num($("#sliderStartSec").value),
      startBeat:num($("#sliderStartBeat").value),
      duration:num($("#sliderDurSec").value),
      durationBeats:num($("#sliderDurBeats").value)
    };

  } else if (t === "Bullet"){
    const spawn = parseAbsXY($("#bulletSpawn").value,"192,540");
    const dock  = parseAbsXY($("#bulletDock").value,"960,540");
    const desp  = parseAbsXY($("#bulletDespawn").value,"1728,540");
    chart.notes[idx] = {
      ...prev, type:"Bullet",
      bulletSpawnPos:spawn, bulletDockPos:dock, bulletDespawnPos:desp,
      bulletSpawnTime:num($("#bulletStartSec").value),
      bulletSpawnBeat:num($("#bulletStartBeat").value),
      bulletToDockDuration:num($("#bulletToDockSec").value),
      bulletToDockBeats:num($("#bulletToDockBeats").value),
      bulletDockToDespawnDuration:num($("#bulletDockToDespawnSec").value),
      bulletDockToDespawnBeats:num($("#bulletDockToDespawnBeats").value)
    };

  } else if (t === "Camera"){
    const camAffectHeight = $("#camAffectHeight").checked;
    const camAffectAngle  = $("#camAffectAngle").checked;
    const camAffectCenter = $("#camAffectCenter").checked;
    const [xs,ys] = ($("#camCenterPx").value||"960,540").split(",");
    const camCenterPx = {
      x: clamp(parseFloat(xs||"960"),0,REF_W),
      y: clamp(parseFloat(ys||"540"),0,REF_H)
    };
    chart.notes[idx] = {
      ...prev, type:"Camera",
      startTime:num($("#camStartSec").value),
      startBeat:num($("#camStartBeat").value),
      duration:num($("#camDurSec").value),
      durationBeats:num($("#camDurBeats").value),
      camAffectHeight, camAffectAngle, camAffectCenter,
      camHeightPx:num($("#camHeightPx").value),
      camAngleDegZ:num($("#camAngleDegZ").value),
      camCenterPx,
      camEase:($("#camEase").value||"").trim(),
      camUseBeats: $("#camUseBeats").checked,
      camUseUIScaling: $("#camUseUIScaling").checked
    };

  } else if (t === "Line") {
    // —— Line 전용 (fadeBeat 반드시 보존) ——
    const target    = document.getElementById("stTarget").value || "grid-all";
    const index     = Number(document.getElementById("stIndex").value || 0);

    const timeSecV  = document.getElementById("stTimeSec").value;
    const timeBeatV = document.getElementById("stTimeBeat").value;
    const fadeSecV  = document.getElementById("stFadeSec").value;
    const fadeBeatV = document.getElementById("stFadeBeats").value;

    const timeSec   = (timeSecV  === "" ? undefined : +timeSecV);
    const timeBeat  = (timeBeatV === "" ? undefined : +timeBeatV);
    const fadeSec   = (fadeSecV  === "" ? 0 : Math.max(0, +fadeSecV));
    const fadeBeat  = (fadeBeatV === "" ? 0 : Math.max(0, +fadeBeatV));

    const colorTxt  = document.getElementById("stColorText").value;
    const color     = normalizeHex8(colorTxt);

    chart.notes[idx] = {
      ...prev,
      type: "Line",
      target,
      index,
      // 사용자가 입력한 축을 그대로 저장 (공란은 undefined 유지)
      timeSec,
      timeBeat,
      fadeSec,
      fadeBeat,   // ★ Unity 파서가 읽는 정확한 키
      color
    };
  }else if(t==="Voice"){
  const prev = chart.notes[idx] || {};
  chart.notes[idx] = {
    ...prev, type:"Voice",
    fmodEvent: ($("#voiceEventPath").value||"").trim(),
    startTime:   num($("#voiceStartSec").value),
    startBeat:   num($("#voiceStartBeat").value),
    fadeInSec:   num($("#voiceFadeInSec").value),
    fadeOutSec:  num($("#voiceFadeOutSec").value),
    volume: Math.max(0, Math.min(1, num($("#voiceVolume").value))),
    pitch:  num($("#voicePitch").value) || 1
  };

}else if(t==="Image"){
  const prev = chart.notes[idx] || {};
  const pos = parseAbsXY($("#imgPos").value, "960,540");
  const size = (function(s){
    const [ws,hs] = (s||"512,512").split(",");
    return { w: Math.max(1, parseFloat(ws)||512), h: Math.max(1, parseFloat(hs)||512) };
  })($("#imgSize").value);

    chart.notes[idx] = {
      ...prev, type:"Image",
      key: ($("#imgKey").value||"").trim(),
      startTime:    num($("#imgStartSec").value),
      startBeat:    num($("#imgStartBeat").value),
      duration:     num($("#imgDurSec").value),
      durationBeats:num($("#imgDurBeats").value),
      absPos: { x: clamp(pos.x,0,REF_W), y: clamp(pos.y,0,REF_H) },
      sizePx: { w: size.w, h: size.h },
      alpha:  Math.max(0, Math.min(1, num($("#imgAlpha").value))),
      rotDeg: num($("#imgRotDeg").value) || 0,
      fadeInSec:  num($("#imgFadeInSec").value),
      fadeOutSec: num($("#imgFadeOutSec").value)
    };
  }

  // 편집 종료/갱신
  cancelEdit(false);
  editIndex = null;
  editType  = null;
  document.getElementById("editBar").classList.remove("active");

  if (typeof buildStyleSchedule === "function") buildStyleSchedule();
  drawView?.();
  drawWave?.();
  renderNotes?.();
  // record history for edit
  pushHistory();
}


function cancelEdit(reset=true){
  editIndex=null; editType=null; $("#editBar").classList.remove("active");
  if(reset){
    $("#noteType").value="Grid"; $("#noteType").dispatchEvent(new Event("change"));
    $("#cellCR").value="1,1"; $("#judgeTimeSec").value="1.000"; $("#judgeBeat").value="1.000";
    $("#longDurSec").value="1.000"; $("#longDurBeats").value="1.000";
    $("#circlePos").value="960,540"; $("#circleJudgeSec").value="1.000"; $("#circleJudgeBeat").value="1.000";
    $("#sliderStartSec").value="2.000"; $("#sliderStartBeat").value="2.000"; $("#sliderDurSec").value="0.800"; $("#sliderDurBeats").value="0.800";
    clearPath(); circlePosAbs={x:REF_W/2,y:REF_H/2}; selectedCell={c:1,r:1}; refreshGridActive(); drawView();
  }
  refreshAddButtons(); updateBulletStageLabel();
}
function refreshAddButtons(){
  const editing=(editIndex!==null);
  const gridType = $("#noteType").value;
  $("#btnAddGrid").disabled   = editing || !["Grid","Trail","Long"].includes(gridType);
  $("#btnAddCircle").disabled = editing || $("#noteType").value!=="CircleTap";
  $("#btnAddSlider").disabled = editing || $("#noteType").value!=="Slider";
  $("#btnAddBullet").disabled = editing || $("#noteType").value!=="Bullet";
  const camBtn = $("#btnAddCamera"); if (camBtn) camBtn.disabled = editing || $("#noteType").value!=="Camera";

}

/* ---------- Notes Table / 정렬 / 드래그 ---------- */
function ensureCreatedAt(){ let t0=Date.now(); for(let n of chart.notes){ if(n._createdAt==null){ n._createdAt=t0; t0++; } if(n._id==null){ n._id = rid(); } } }
function rid(){ return (crypto.randomUUID && crypto.randomUUID()) || (Math.random().toString(36).slice(2)+Date.now().toString(36)); }

function renderNotes(){
  try{
    chart.title=$("#title")?.value ?? chart.title ?? "New Chart";
    chart.bpm=num($("#bpm")?.value ?? chart.bpm ?? 120);
    chart.timeMode=$("#timeMode")?.value ?? chart.timeMode ?? "Seconds";
    chart.startOffset=num($("#startOffsetSec")?.value ?? chart.startOffset ?? 0);
    chart.startOffsetBeats=num($("#startOffsetBeats")?.value ?? chart.startOffsetBeats ?? 0);
    ensureCreatedAt();

    const table = document.querySelector("#notesTable");
    if (!table) { console.warn("[renderNotes] #notesTable not found"); return; }

    // ★ tbody가 없으면 만들어서 붙임 (브라우저/머지 이슈 방지)
    let tbody = table.querySelector("tbody");
    if (!tbody){
      tbody = document.createElement("tbody");
      table.appendChild(tbody);
    }
    tbody.innerHTML = "";

    const notes = Array.isArray(chart.notes) ? chart.notes : [];
    notes.forEach((n,i)=>{
      const tr=document.createElement("tr"); tr.dataset.index=i; if(editIndex===i) tr.classList.add("editrow");

      const tdIdx=cel("td","muted",String(i+1));
      const displayType = (()=>{
        if ((n.type === "Grid" && n.isTrail)) return "Trail";
        if ((n.type === "Grid" && n.isLong) || n.type === "Long") return "Long";
        return n.type || "-";
      })();
      const tdType=cel("td","","<span class=\"pill\">"+displayType+"</span>",true);

      // ---- data 칸
      let data = "";
      if ((n.type==="Long") || (n.type==="Grid" && n.isLong)){
        const cell = n.cell || {x:"-",y:"-"};
        const startSec = isFinite(n.startTime) ? n.startTime : (isFinite(n.judgeTime) ? n.judgeTime : 0);
        const startBeat = isFinite(n.startBeat) ? n.startBeat : (isFinite(n.judgeBeat) ? n.judgeBeat : 0);
        const durSec = (isFinite(n.duration) && n.duration>0)
          ? n.duration
          : (isFinite(n.durationBeats) && n.durationBeats>0 ? beatsToSec(n.durationBeats) : Math.max(0, (isFinite(n.judgeTime) ? n.judgeTime : startSec) - startSec));
        const durBeat = (isFinite(n.durationBeats) && n.durationBeats>0)
          ? n.durationBeats
          : (()=>{ const spbVal = spb(); return (spbVal>0 && durSec>0) ? (durSec / spbVal) : Math.max(0, (isFinite(n.judgeBeat) ? n.judgeBeat : startBeat) - startBeat); })();
        const relSec = (durSec>0) ? (startSec + durSec) : (isFinite(n.judgeTime) ? n.judgeTime : startSec);
        const relBeat = (durBeat>0) ? (startBeat + durBeat) : (isFinite(n.judgeBeat) ? n.judgeBeat : startBeat);
        data=`cell=(${cell.x??"-"},${cell.y??"-"}) start=${fmt(startSec)}s/${fmt(startBeat)}b dur=${fmt(durSec)}s/${fmt(durBeat)}b release=${fmt(relSec)}s/${fmt(relBeat)}b`;
      } else if (n.type==="Grid"){
        data=`cell=(${n.cell?.x??"-"},${n.cell?.y??"-"})`;
        if (n.isTrail) data += " · Trail";
      } else if (n.type==="CircleTap"){
        const p = n.absPos || {x:REF_W/2,y:REF_H/2};
        data=`pos=(${Math.round(p.x)},${Math.round(p.y)})`;
      } else if (n.type==="Slider"){
        data=`pts=${(n.absPath||[]).length}`;
      } else if (n.type==="Bullet"){
        const s=n.bulletSpawnPos||{x:192,y:540}, d=n.bulletDockPos||{x:960,y:540}, e=n.bulletDespawnPos||{x:1728,y:540};
        data=`S(${Math.round(s.x)},${Math.round(s.y)}) Dk(${Math.round(d.x)},${Math.round(d.y)}) De(${Math.round(e.x)},${Math.round(e.y)})`;
      } else if (n.type==="Camera"){
        const flags = [
          n.camAffectHeight ? `H=${Math.round(n.camHeightPx||0)}px` : null,
          n.camAffectAngle  ? `A=${fmt(n.camAngleDegZ)}°` : null,
          n.camAffectCenter ? `C=(${Math.round(n.camCenterPx?.x||960)},${Math.round(n.camCenterPx?.y||540)})` : null
        ].filter(Boolean).join(" · ");
        data = flags || "(no axes)";
      } else if (n.type==="Line"){ // 스타일 이벤트
        const tgt = n.target || "grid-all";
        const idx = n.index|0;
        const col = (n.color || "").toString();
        data = `${tgt}${tgt==="grid-line" ? `#${idx}` : ""} · ${col}`;
      } else if (n.type==="Voice"){
        data = n.fmodEvent || "(event:unset)";
      }else if (n.type==="Image"){
        const p = n.absPos ? `${Math.round(n.absPos.x)},${Math.round(n.absPos.y)}` : "?,?";
        data = `${n.key||"(key unset)"} @ ${p}`;
      }
      else {
        data = "(unknown)";
      }
      const tdData=cel("td","",data);

      // ---- time 칸 (★ 선언 먼저!)
      let timeTxt="";
      if ((n.type==="Long") || (n.type==="Grid" && n.isLong)){
        const startSec = isFinite(n.startTime) ? n.startTime : (isFinite(n.judgeTime) ? n.judgeTime : 0);
        const startBeat = isFinite(n.startBeat) ? n.startBeat : (isFinite(n.judgeBeat) ? n.judgeBeat : 0);
        const durSec = (isFinite(n.duration) && n.duration>0)
          ? n.duration
          : (isFinite(n.durationBeats) && n.durationBeats>0 ? beatsToSec(n.durationBeats) : Math.max(0, (isFinite(n.judgeTime) ? n.judgeTime : startSec) - startSec));
        const durBeat = (isFinite(n.durationBeats) && n.durationBeats>0)
          ? n.durationBeats
          : (()=>{ const spbVal = spb(); return (spbVal>0 && durSec>0) ? (durSec / spbVal) : Math.max(0, (isFinite(n.judgeBeat) ? n.judgeBeat : startBeat) - startBeat); })();
        const relSec = (durSec>0) ? (startSec + durSec) : (isFinite(n.judgeTime) ? n.judgeTime : startSec);
        const relBeat = (durBeat>0) ? (startBeat + durBeat) : (isFinite(n.judgeBeat) ? n.judgeBeat : startBeat);
        timeTxt=`start=${fmt(startSec)}/${fmt(startBeat)} | dur=${fmt(durSec)}/${fmt(durBeat)} | rel=${fmt(relSec)}/${fmt(relBeat)}`;
      } else if (n.type==="Slider"){
        timeTxt=`start=${fmt(n.startTime)}/${fmt(n.startBeat)} | dur=${fmt(n.duration)}/${fmt(n.durationBeats)}`;
      } else if (n.type==="Bullet"){
        timeTxt=`start=${fmt(n.bulletSpawnTime)}/${fmt(n.bulletSpawnBeat)} | toDock=${fmt(n.bulletToDockDuration)}/${fmt(n.bulletToDockBeats)} | dockToDespawn=${fmt(n.bulletDockToDespawnDuration)}/${fmt(n.bulletDockToDespawnBeats)}`;
      } else if (n.type==="Camera"){
        timeTxt=`start=${fmt(n.startTime)}/${fmt(n.startBeat)} | dur=${fmt(n.duration)}/${fmt(n.durationBeats)}`;
      } else if (n.type==="Line"){
        timeTxt=`t=${fmt(n.timeSec)}/${fmt(n.timeBeat)} | fade=${fmt(n.fadeSec)}s`;
      } else {
        timeTxt=`t=${fmt(n.judgeTime)}/${fmt(n.judgeBeat)}`;
        if (n.type==="Voice" || n.type==="Image"){
          const tReal = J_timelineStartSec(chart, n, /*includeOffset=*/true);
          timeTxt = `start=${fmt(n.startTime)}/${fmt(n.startBeat)}`
        }
      }
      const tdTime=cel("td","muted",timeTxt);

      const isVI = (n.type==="Voice" || n.type==="Image");
      const spawnSec = spawnSecOf(n);
      const tdSpawn=cel("td","muted","spawn="+fmt(spawnSec));

      const tdAct=document.createElement("td"); tdAct.style.display="flex"; tdAct.style.gap="6px";
      tdAct.innerHTML = `<button onclick="startEdit(${i})">Edit</button>
        <button class="bad" onclick="removeNote(${i})">Del</button>
        <button onclick="moveUp(${i})">Up</button>
        <button onclick="moveDown(${i})">Down</button>`;

      tr.appendChild(tdIdx); tr.appendChild(tdType); tr.appendChild(tdData); tr.appendChild(tdTime); tr.appendChild(tdSpawn); tr.appendChild(tdAct);
      attachRowDragHandlers(tr,i);
      tbody.appendChild(tr);
    });
    // update mini list near preview
    try{ updateMiniList(); }catch(e){}

  }catch(err){
    console.error("[renderNotes] crashed:", err);
    // 화면에 디버그 메모 붙이기(선택)
    const noteArea = document.querySelector("#notesTable")?.parentElement;
    if (noteArea && !noteArea.querySelector(".notes-error")){
      const div=document.createElement("div");
      div.className="notes-error";
      div.style.cssText="margin:8px 0;padding:8px;border:1px dashed #6e1c1c;color:#ffd2d2;background:#3a161610;border-radius:8px;font-size:12px";
      div.textContent="(renderNotes 오류: 콘솔을 확인하세요)";
      noteArea.prepend(div);
    }
  }
}

function cel(tag,cls,txt,isHTML=false){ const el=document.createElement(tag); if(cls) el.className=cls; if(isHTML) el.innerHTML=txt; else el.textContent=txt; return el; }
function removeNote(i){
  if(editIndex===i) cancelEdit(); chart.notes.splice(i,1); renderNotes();

  //  삭제 후에도 재빌드
  buildStyleSchedule();
  resetStyleCursor(getPreviewNowSec());
  pushHistory();
}

// Delete the currently edited note from the edit bar
function deleteEdit(){
  const idx = editIndex;
  if (idx === null || idx === undefined) return;
  if (!confirm("Delete this note?")) return;
  // remove note
  chart.notes.splice(idx, 1);
  // hide edit UI and refresh
  cancelEdit(false);
  renderNotes();
  buildStyleSchedule();
  resetStyleCursor(getPreviewNowSec());
  drawWave();
  drawView();
  pushHistory();
}
function moveUp(i){ if(i<=0) return; const it=chart.notes.splice(i,1)[0]; chart.notes.splice(i-1,0,it); renderNotes(); pushHistory(); }
function moveDown(i){ if(i>=chart.notes.length-1) return; const it=chart.notes.splice(i,1)[0]; chart.notes.splice(i+1,0,it); renderNotes(); pushHistory(); }
let dragIndex=null; function attachRowDragHandlers(tr,idx){ tr.setAttribute("draggable","true"); tr.addEventListener("dragstart",(e)=>{ dragIndex=idx; tr.style.opacity="0.5"; }); tr.addEventListener("dragend",()=>{ tr.style.opacity=""; dragIndex=null; }); tr.addEventListener("dragover",(e)=>{ e.preventDefault(); }); tr.addEventListener("drop",(e)=>{ e.preventDefault(); const targetIdx=parseInt(tr.dataset.index,10); if(dragIndex===null || dragIndex===targetIdx) return; const item=chart.notes.splice(dragIndex,1)[0]; chart.notes.splice(targetIdx,0,item); renderNotes(); }); }

/* ---------- 정렬 & 시간 계산 ---------- */
function spb(){ const bpm = num($("#bpm").value); return bpm>0 ? 60/bpm : 0; }
function getNoteTimeSec(n){
  if ((n.type === "Grid" && n.isLong) || n.type === "Long"){
    return getLongStartSec(n);
  }
  switch (n.type) {
    case "Slider":
      return chartTimeToPlaybackSec({ sec: n.startTime,           beat: n.startBeat });

    case "Bullet":
      return chartTimeToPlaybackSec({ sec: n.bulletSpawnTime,     beat: n.bulletSpawnBeat });

    case "Camera":
      return getCameraStartSec(n); // 기존 함수

    // => timeSec/timeBeat를 쓰는 이벤트들(없으면 start*로 폴백)
    case "Line":
    case "Voice":
    case "Image":
      return chartTimeToPlaybackSec({
        sec:  (n.timeSec  ?? n.startTime ?? 0),
        beat: (n.timeBeat ?? n.startBeat ?? 0)
      });

    // Grid / CircleTap
    default:
      return chartTimeToPlaybackSec({ sec: n.judgeTime, beat: n.judgeBeat });
  }
}


function packIntoRows(intervals){
  // intervals: [{x0,x1, idx, type, t0,t1}]
  // return: [{... , row}]
  const rowsEnd = [];  // 각 row의 마지막 x1
  const out = [];
  intervals.sort((a,b)=> (a.x0 - b.x0) || (a.x1 - b.x1));
  for(const it of intervals){
    let placed = false;
    for(let r=0;r<rowsEnd.length;r++){
      if(it.x0 >= rowsEnd[r] - 0.5){  // 살짝 겹치는 경계 허용
        rowsEnd[r] = it.x1;
        out.push({...it, row:r});
        placed = true;
        break;
      }
    }
    if(!placed){
      rowsEnd.push(it.x1);
      out.push({...it, row:rowsEnd.length-1});
    }
  }
  return { placed: out, rowCount: rowsEnd.length };
}


function getNoteTimeBeats(n){
  const S = spb();
  const byBeats = $("#timeMode").value === "Beats";

  const present = v => v != null && isFinite(v);
  const beatsFromSec = (sec)=> present(sec) ? sec / (S||1) : null;
  const pick = (primary, fallback)=> present(primary) ? primary : (present(fallback) ? fallback : 0);
  if (n.type === "Line"){
    const sec = n.timeSec, beat = n.timeBeat;
    return byBeats ? pick(beat, beatsFromSec(sec)) : pick(beatsFromSec(sec), beat);
  }
  if ((n.type === "Grid" && n.isLong) || n.type === "Long"){
    const sec = n.startTime;
    const beat = n.startBeat;
    return byBeats ? pick(beat, beatsFromSec(sec)) : pick(beatsFromSec(sec), beat);
  }
  if(n.type === "Slider"){
    const sec = n.startTime;
    const beat = n.startBeat;
    return byBeats ? pick(beat, beatsFromSec(sec)) : pick(beatsFromSec(sec), beat);
  }
  if(n.type === "Bullet"){
    const sec = n.bulletSpawnTime;
    const beat = n.bulletSpawnBeat;
    return byBeats ? pick(beat, beatsFromSec(sec)) : pick(beatsFromSec(sec), beat);
  }
  const sec = n.judgeTime;
  const beat = n.judgeBeat;
  return byBeats ? pick(beat, beatsFromSec(sec)) : pick(beatsFromSec(sec), beat);
}
function spawnSecOf(n){
  const gridTargetPx = resolveGridTargetPx();
  const gridGrowSec  = resolveGridGrowPxPerSec();       // px/s
  const gridLeadSec  = gridTargetPx / gridGrowSec;      // s

  if ((n.type === "Grid" && n.isLong) || n.type === "Long")
    return getLongStartSec(n) - gridLeadSec;
  if (n.type === "Grid")      return getNoteTimeSec(n) - gridLeadSec;
 if (n.type === "CircleTap") return getNoteTimeSec(n) - resolveCircleLeadSec();
 if (n.type === "Slider")    return getNoteTimeSec(n) - resolveSliderLeadSec();
  if (n.type === "Bullet")    return getNoteTimeSec(n);
  if (n.type === "Camera") return getCameraStartSec(n);
  if (n.type === "Line")      return getStyleStartSec(n);

  return getNoteTimeSec(n);
}

// Mini note list for quick navigation beside preview
function formatShortLabel(n, idx){
  const t = getNoteTimeSec(n);
  const tt = isFinite(t) ? qms(t).toFixed(3) : "-";
  const type = n.type || "-";
  return `#${idx+1} ${type} @ ${tt}s`;
}

function updateMiniList(){
  const container = document.getElementById('miniList');
  if(!container) return;
  const sort = (document.getElementById('miniSort')?.value) || 'time';
  const notes = Array.isArray(chart.notes) ? chart.notes.slice() : [];
  if(sort === 'spawn') notes.sort((a,b)=> spawnSecOf(a) - spawnSecOf(b)); else notes.sort((a,b)=> getNoteTimeSec(a) - getNoteTimeSec(b));
  container.innerHTML = '';
  const now = (typeof getPreviewNowSec === 'function') ? getPreviewNowSec() : (audioEl.currentTime || 0);
  notes.forEach((n, i)=>{
    const idx = chart.notes.indexOf(n);
    const div = document.createElement('div');
    div.style.padding = '6px 4px';
    div.style.borderBottom = '1px solid rgba(40,50,70,0.4)';
    div.style.cursor = 'pointer';
    div.style.color = '#dfe7ff';
    div.title = (n.type||'') + ' — click to seek/edit';
    if(Math.abs(getNoteTimeSec(n) - now) < 0.08) div.style.background = 'rgba(255,215,100,0.06)';
    div.innerHTML = `<div style="display:flex;justify-content:space-between;gap:8px"><div style="flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${formatShortLabel(n, idx)}</div><div style="color:#9aa4bb;flex:0 0 auto">${n.type||''}</div></div>`;
    div.addEventListener('click', ()=>{
      const t = getNoteTimeSec(n);
      if (!isFinite(t)) return;
      if (typeof seekAccurate === 'function') seekAccurate(t); else audioEl.currentTime = Math.max(0, Math.min(getDuration(), t));
      startEdit(idx);
    });
    container.appendChild(div);
  });
}

// update mini list when sort changed
document.addEventListener('DOMContentLoaded', ()=>{
  const s = document.getElementById('miniSort'); if(s) s.addEventListener('change', updateMiniList);
});
function sortByCreation(){ ensureCreatedAt(); chart.notes.sort((a,b)=> (a._createdAt||0)-(b._createdAt||0)); renderNotes(); }
function sortByTimeSec(){ chart.notes.sort((a,b)=> getNoteTimeSec(a)-getNoteTimeSec(b)); renderNotes(); }
function sortByTimeBeats(){ chart.notes.sort((a,b)=> getNoteTimeBeats(a)-getNoteTimeBeats(b)); renderNotes(); }
function sortBySpawn(){ chart.notes.sort((a,b)=> spawnSecOf(a)-spawnSecOf(b)); renderNotes(); }
function reindexNotes(){ for(let i=0;i<chart.notes.length;i++){ chart.notes[i]._order=i; } renderNotes(); }

/* ---------- Export/Import ---------- */
function levelChartJSON(){
  const fixedNotes = (chart.notes || []).map(n=>{
    if(n.type === "Line"){
      // 소문자 키가 있으면 끌어올림
      const fb = Number.isFinite(n.fadeBeat) ? n.fadeBeat
               : (Number.isFinite(n.fadebeat) ? n.fadebeat : undefined);
      return { ...n, ...(fb !== undefined ? { fadeBeat: fb } : {}) };
    }
    return n;
  });
  const payload = {
    schemaVersion: 2,
    title: chart.title,
    bpm: chart.bpm,
    timeMode: chart.timeMode,  // "Beats"/"Seconds" 그대로
    startOffset: chart.startOffset,
    startOffsetBeats: chart.startOffsetBeats,
    notes: fixedNotes
  };
  return JSON.stringify(payload, null, 2);
}


// ───────── 시간/비트 변환 헬퍼 (기존 함수 재정의 없음) ─────────
const J_EPS = 1e-6;

function J_beatToSec(beat, bpm){ return (beat||0) * 60 / Math.max(1e-6, bpm||120); }
function J_chartOffsetSec(chart){ return (chart?.startOffset||0) + J_beatToSec(chart?.startOffsetBeats||0, chart?.bpm||120); }

// 가장 먼저 발견되는 "유효값" 반환(0은 유효로 취급)
function J_firstValid(/* ...vals */){
  for (let i=0;i<arguments.length;i++){
    const v = arguments[i];
    if (v === undefined || v === null) continue;
    if (typeof v === 'number' && Math.abs(v) <= J_EPS) return 0;
    if (typeof v === 'number') return v;
    if (v) return v;
  }
  return 0;
}

// 이벤트의 "타임라인 초" (includeOffset=true면 chart 오프셋까지 더함)
function J_timelineStartSec(chart, n, includeOffset=true){
  const bpm = chart?.bpm || 120;
  // 초 우선 → 비트로 대체
  const sec = J_firstValid(n.startTime, n.timeSec, n.judgeTime,
                           // 비트 → 초
                           (Math.abs(n.startBeat||0)  > J_EPS ? J_beatToSec(n.startBeat,  bpm):null),
                           (Math.abs(n.timeBeat||0)   > J_EPS ? J_beatToSec(n.timeBeat,   bpm):null),
                           (Math.abs(n.judgeBeat||0)  > J_EPS ? J_beatToSec(n.judgeBeat,  bpm):null),
                           0);
  return includeOffset ? sec + J_chartOffsetSec(chart) : sec;
}

// 이벤트 지속(초)
function J_durationSec(chart, n){
  const bpm = chart?.bpm || 120;
  return J_firstValid(n.duration, n.durationSec,
                      (Math.abs(n.durationBeats||0) > J_EPS ? J_beatToSec(n.durationBeats, bpm):null),
                      0);
}

// Voice/Image 페이드(초)
function J_fadeInSec(chart, n){
  const bpm = chart?.bpm || 120;
  return J_firstValid(n.fadeInSec,
                      (Math.abs(n.fadeInBeat||0) > J_EPS ? J_beatToSec(n.fadeInBeat, bpm):null),
                      0);
}
function J_fadeOutSec(chart, n){
  const bpm = chart?.bpm || 120;
  return J_firstValid(n.fadeOutSec,
                      (Math.abs(n.fadeOutBeat||0) > J_EPS ? J_beatToSec(n.fadeOutBeat, bpm):null),
                      0);
}

// Voice/Image 전용 "표시 구간" 계산 (기존 noteTimeWindowSec를 건드리지 않음)
function J_timeWindowSec_VI(chart, n){
  const t0 = J_timelineStartSec(chart, n, /*includeOffset=*/true);
  const d  = Math.max(0, J_durationSec(chart, n));
  const span = Math.max(d, 0.02); // 최소 폭 20ms
  return { t0, t1: t0 + span };
}


function downloadJSON(){
  const blob=new Blob([levelChartJSON()],{type:"application/json;charset=utf-8"});
  const url=URL.createObjectURL(blob); const a=document.createElement("a");
  a.href=url; a.download=(chart.title||"chart")+".json"; document.body.appendChild(a); a.click();
  URL.revokeObjectURL(url); a.remove();
}
$("#importFile").addEventListener("change",(e)=>{
  const f=e.target.files[0]; if(!f) return;
  const r=new FileReader();
  r.onload=()=>{
    try{
      const obj=JSON.parse(r.result);
      // 간단 마이그레이션: screenPos01/screenPath01/bullet*01 → abs*
      if(Array.isArray(obj.notes)){
        for(const n of obj.notes){
          if(n.screenPos01 && !n.absPos){
            n.absPos = { x: n.screenPos01.x * REF_W, y: n.screenPos01.y * REF_H };
          }
          if(n.screenPath01 && !n.absPath){
            n.absPath = n.screenPath01.map(p => ({ x: p.x*REF_W, y: p.y*REF_H }));
          }
          if(n.bulletSpawn01 && !n.bulletSpawnPos){
            n.bulletSpawnPos = { x: n.bulletSpawn01.x*REF_W, y: n.bulletSpawn01.y*REF_H };
            n.bulletDockPos  = { x: n.bulletDock01.x*REF_W,  y: n.bulletDock01.y*REF_H  };
            n.bulletDespawnPos = { x: n.bulletDespawn01.x*REF_W, y: n.bulletDespawn01.y*REF_H };
          }
          // schemaVersion 없으면 1로 간주
          if(!("schemaVersion" in obj)) obj.schemaVersion = 1;
        }
      }
      cancelEdit(false);
      chart.schemaVersion = obj.schemaVersion || 2;
      chart.title=obj.title||"Imported"; chart.bpm=obj.bpm||120;
      chart.timeMode=obj.timeMode||"Seconds";
      chart.startOffset=obj.startOffset||0; chart.startOffsetBeats=obj.startOffsetBeats||0;
      chart.notes=Array.isArray(obj.notes)?obj.notes:[];
      $("#title").value=chart.title; $("#bpm").value=chart.bpm; $("#timeMode").value=chart.timeMode;
      $("#startOffsetSec").value=chart.startOffset; $("#startOffsetBeats").value=chart.startOffsetBeats;
      ensureCreatedAt(); renderNotes(); drawWave();buildStyleSchedule(); resetStyleCursor(0);
    }catch(err){ alert("JSON parse failed: "+err); }
  };
  r.readAsText(f,"utf-8");
  ensureCreatedAt(); renderNotes(); drawWave();


  buildStyleSchedule();
  resetStyleCursor(0);
  // import = new state
  pushHistory();
});
function sanitizeName(s){
  // 파일/폴더명에 안 되는 문자 제거(윈도우/맥 공통)
  return (s || "Untitled")
    .replace(/[\\/:*?"<>|]/g, "_")
    .replace(/\s+/g, " ")
    .trim();
}

async function exportSongZip(){
  try{
    if (typeof JSZip === "undefined"){
      alert("JSZip이 로드되지 않았습니다. <script src=...jszip.min.js>를 추가하세요.");
      return;
    }

    const title  = ($("#title")?.value || "New Chart");
    const artist = ($("#artist")?.value || "Unknown");
    const folderName = `${sanitizeName(artist)} - ${sanitizeName(title)}`;

    const zip = new JSZip();
    const root = zip.folder(folderName);
    const chartsFolder = root.folder("charts");

    // chart json
    const chartJson = levelChartJSON();
    chartsFolder.file("Normal.chart.json", chartJson);

    // song.json
const songMeta = {
  title,
  artist,
  bpm: num($("#bpm").value),
  previewStart: num($("#previewStart")?.value || 0),
  previewDuration: num($("#previewDuration")?.value || 0),
  coverImage: "cover.jpg",
  bgVideo: "",
  fmodEvent: ($("#fmodEvent")?.value || ""), 
  durationSec: num($("#durationSec")?.value || 0),
  difficulties: [{ name:"Normal", path:"charts/Normal.chart.json", level:1 }],
  tags: ($("#tags")?.value || "").split(",").map(t=>t.trim()).filter(Boolean)
};
    root.file("song.json", JSON.stringify(songMeta, null, 2));

    // cover
    const coverFile = $("#coverFile")?.files?.[0];
    if (coverFile){
      const coverBuf = await coverFile.arrayBuffer(); // ← 이름 변경
      root.file("cover.jpg", coverBuf);
    }

    // zip 출력
    const zipBlob = await zip.generateAsync({ type:"blob" }); // ← 이름 변경
    const a = document.createElement("a");
    a.href = URL.createObjectURL(zipBlob);
    a.download = `${folderName}.zip`;
    document.body.appendChild(a); // 사파리 호환성
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
  }catch(err){
    console.error("[exportSongZip] failed:", err);
    alert("Export 중 오류가 발생했습니다. 콘솔을 확인하세요.");
  }
}

/* ---------- Waveform ---------- */
function setWaveControlsEnabled(on = true){
  [playBtn, pauseBtn, undoBtn, redoBtn, zoomInBtn, zoomOutBtn, fitBtn].forEach(b=>{
    if (b) b.disabled = !on;
  });
}
// --- Accurate transport state (WebAudio) ---
let AC = null;                 // AudioContext
let AC_buf = null;             // AudioBuffer
let AC_src = null;             // BufferSource
let AC_startCtxT = 0;          // context 기준 시작 시각
let AC_startOffset = 0;        // 곡 내 오프셋(초)
let AC_rate = 1.0;             // 배속
let AC_enabled = true;         // 정확 모드 on/off 스위치
const MIN_VIEW_SPAN_SEC   = 0.01; // 최소 가시 구간 20ms (원하면 0.005s도 가능)
const KEY_PAN_FRAC        = 0.05; // ← 기본 좌우 이동: 현재 구간의 5%
const KEY_PAN_FRAC_FAST   = 0.20; // ← Alt+Arrow: 20%
const KEY_PAN_FRAC_SLOW   = 0.01; // ← Ctrl+Arrow: 1%

let previewTimeSec = 0;  // 정지 중 커서가 보여줄 시각(초)
function isPlaying(){
  return (AC_enabled && !!AC_src) || (!AC_enabled && !audioEl.paused && !audioEl.ended);
}

function ensureAC(){
  if (AC && AC.state !== 'closed') return AC;
  AC = new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'});
  return AC;
}

function stopAccurate(){
  if (AC_src){
    try { AC_src.stop(); } catch {}
    try { AC_src.disconnect(); } catch {}
  }
  AC_src = null;
}

function playAccurate(startAtSec = null){
  dlog?.("playAccurate.in", {startAtSec});
  if (!AC_enabled || !AC_buf) { audioEl.play(); return; }

  const ac = ensureAC();

  // ★ 일부 브라우저는 첫 클릭 이후에도 suspended → 반드시 resume 시도
  if (ac.state === "suspended") {
    try { ac.resume(); } catch(e){ console.warn("AC.resume failed", e); }
  }

  if (startAtSec != null){
    AC_startOffset = qms(Math.max(0, Math.min(startAtSec, AC_buf.duration)));
  }
  stopAccurate();

  AC_src = ac.createBufferSource();
  AC_src.buffer = AC_buf;
  AC_src.playbackRate.value = AC_rate;
  AC_src.connect(ac.destination);

  const safety = Math.max(0.03, (ac.baseLatency||0.02) + (ac.outputLatency||0));
  const when = ac.currentTime + safety;

  AC_startCtxT = when;
  AC_src.start(when, AC_startOffset);

  // ★ UI 갱신 루프 보장
  scheduleAccurateUiLoop();

  dlog?.("playAccurate.out", snapshotState());
}

function pauseAccurate(){
  if (!AC_enabled || !AC_buf) { audioEl.pause(); return; }
  const now = qms(getNowAccurate());
  stopAccurate();
  AC_startOffset = now;
  previewTimeSec = now;          // ⟵ 프리뷰 고정
  curTimeEl.textContent = now.toFixed(3);
  window.getPreviewNowSec = () => now;
  applyStyleEvents(now);
  redrawBeat();
  drawWave();
}

function resetStyleCursor(nowSec){
  // styleEvents는 tSec 오름차순 정렬이라고 가정
  let lo = 0, hi = styleEvents.length;
  while (lo < hi){
    const mid = (lo + hi) >> 1;
    if (styleEvents[mid].tSec <= nowSec) lo = mid + 1;
    else hi = mid;
  }
  nextStyleIdx = lo; // 이제 다음 while에서 nowSec 이후 이벤트부터 소비
  _lastStyleNow = nowSec; 
}

function seekAccurate(toSec){
  if (!AC_enabled || !AC_buf){
    const d = getDuration();
    const t = qms(Math.max(0, Math.min(toSec, d)));
    audioEl.currentTime = t;
    // 정지 중이면 프리뷰 갱신
    if (!isPlaying()){
      previewTimeSec = t;
      curTimeEl.textContent = t.toFixed(3);
      window.getPreviewNowSec = () => t;
      applyStyleEvents(t); 
    }
    if (typeof applyStyleEvents === "function") applyStyleEvents(tt);
    redrawBeat();
    drawWave();
    return;
  }
  const t = qms(Math.max(0, Math.min(toSec, AC_buf.duration)));
  if (AC_src) {
    playAccurate(t);             // 재생 중엔 즉시 점프
  } else {
    AC_startOffset = t;          // 정지 상태면 위치만 설정
    previewTimeSec = t;
    curTimeEl.textContent = t.toFixed(3);
    window.getPreviewNowSec = () => t;
    if (typeof applyStyleEvents === "function") applyStyleEvents(t);
    redrawBeat();
    drawWave();
  }
}

function setRateAccurate(r) {
  AC_rate = (r && isFinite(r)) ? r : 1;

  // HTMLAudio 모드
  if (!AC_enabled || !AC_buf) {
    setPlaybackRate(AC_rate);
    return;
  }

  const wasPlaying = !!AC_src;
  const pos = wasPlaying ? getNowAccurate() : (AC_startOffset || 0);
  stopAccurate();

  if (wasPlaying) {
    // 재생 중일 때만 다시 시작
    const ac = ensureAC();
    AC_src = ac.createBufferSource();
    AC_src.buffer = AC_buf;
    AC_src.playbackRate.value = AC_rate;
    AC_src.connect(ac.destination);

    const safety = Math.max(0.03, (ac.baseLatency || 0.02) + (ac.outputLatency || 0));
    const when = ac.currentTime + safety;
    AC_startCtxT = when;
    AC_startOffset = pos;
    AC_src.start(when, pos);
    requestAnimationFrame(syncUiAccurate);
  } else {
    // 정지 상태면 위치만 유지, 재생 시작 안 함
    AC_startOffset = pos;
    const tt = qms(pos);
    curTimeEl.textContent = tt.toFixed(3);
    window.getPreviewNowSec = () => tt;
    redrawBeat();
    drawWave();
  }
}

function getNowAccurate(){
  if (!AC_enabled || !AC_buf || !AC_src) return AC_startOffset||0;
  const acNow = ensureAC().currentTime;
  const t = (acNow - AC_startCtxT) * AC_rate + AC_startOffset;
  return Math.max(0, Math.min(t, AC_buf.duration));
}

function syncUiAccurate(){
  try{
    if (!AC_enabled || !AC_buf) return;
    const t = qms(getNowAccurate());
    curTimeEl.textContent = t.toFixed(3);

    applyStyleEvents(t);

    const bi = beatInfoAt(t);
    curBeatEl.textContent = bi.valid ? bi.text : "-";
    window.getPreviewNowSec = () => t;   // 미리보기 타임 소스 통합
    drawWave();

    // 끝났으면 루프 종료
    if (t >= (AC_buf.duration - 1/(AC?.sampleRate||48000))) {
      stopAccurate();
      return;
    }
  }catch(err){
    console.error("[syncUiAccurate] crashed:", err);
    // 크래시한 경우에도 루프가 죽지 않도록 폴백 타이머가 커버함
  }
}

const waveCanvas=$("#wave"); const wctx=waveCanvas.getContext("2d");
const audioEl=$("#audio"); const audioFileInput=$("#audioFile");
const playBtn=$("#playBtn"), pauseBtn=$("#pauseBtn");
const undoBtn=$("#undoBtn"), redoBtn=$("#redoBtn");
const curTimeEl=$("#curTime"), durTimeEl=$("#durTime"), curBeatEl=$("#curBeat");
const zoomInBtn=$("#zoomInBtn"), zoomOutBtn=$("#zoomOutBtn"), fitBtn=$("#fitBtn");
const ampScaleInput=$("#ampScale");
let audioBuffer=null, audioURL=null, viewStart=0, viewEnd=0, isPanning=false, dragStartX=0, dragStartView=0, dragStartSpan=0, ampScale=0.6;
let dragSelecting=false, dragT0=0, dragT1=0;
let _rafId = null;


audioEl.addEventListener("seeking", drawWave);
audioEl.addEventListener("seeked", drawWave);
audioEl.addEventListener("ratechange", drawWave);

function resizeWaveCanvas(){
  const dpr=window.devicePixelRatio||1, cssW=waveCanvas.clientWidth, cssH=waveCanvas.clientHeight;
  waveCanvas.width=Math.max(600,Math.floor(cssW*dpr)); waveCanvas.height=Math.floor(cssH*dpr);
  wctx.setTransform(dpr,0,0,dpr,0,0); drawWave();
}
window.addEventListener("resize", resizeWaveCanvas);

audioFileInput.addEventListener("change", async (e)=>{
  const file = e.target.files?.[0];
  if (!file) return;

  // HTMLAudio에 로드(메타/기본 길이)
  if (audioURL) { URL.revokeObjectURL(audioURL); audioURL = null; }
  audioURL = URL.createObjectURL(file);
  audioEl.src = audioURL;

  audioEl.onloadedmetadata = () => {
    const d = audioEl.duration || 0;
    durTimeEl.textContent = d.toFixed(3);
    viewStart = 0;
    viewEnd   = d;
    drawWave();
    setWaveControlsEnabled(true); // 이 함수는 반드시 위쪽에 선언
    buildStyleSchedule();
    resetStyleCursor(0);
  };

  // === WebAudio로 한 번만 디코드 → 둘 다 재사용 ===
  try {
    const wa  = ensureAC();                   // ← 이름을 'ac'가 아닌 'wa'로 (충돌 방지)
    const arr = await file.arrayBuffer();
    AC_buf     = await wa.decodeAudioData(arr.slice(0)); // 정확 모드용
    audioBuffer = AC_buf;                                // 파형 그리기도 같은 버퍼 재사용
  } catch (err) {
    console.error("decodeAudioData failed", err);
    AC_buf = null;
    audioBuffer = null;
  }

  // HTMLAudio가 duration을 못 읽는 파일 대비: WebAudio 길이로 보정
  if ((!isFinite(audioEl.duration) || (audioEl.duration || 0) <= 0) && (AC_buf?.duration > 0)){
    const d = AC_buf.duration;
    durTimeEl.textContent = d.toFixed(3);
    viewStart = 0;
    viewEnd   = d;
    drawWave();
    setWaveControlsEnabled(true);
    buildStyleSchedule();
    resetStyleCursor(0);
  }

  // 캔버스 DPI/크기 반영
  resizeWaveCanvas();
  // history button initial state
  if (typeof updateHistoryButtons === 'function') updateHistoryButtons();
});
let _styleBaseColor = rgba(255, 255, 255, 255); 
function applyStyleEvents(nowSec){
  if (!Array.isArray(styleEvents) || styleEvents.length === 0){
    setGridColor(_styleBaseColor);
    _styleLastNow = nowSec;
    return;
  }

  const c = evalStyleColorAt(nowSec);
  setGridColor(c);

  _styleLastNow = nowSec;
}

playBtn.onclick  = () => { (AC_enabled && AC_buf) ? playAccurate() : audioEl.play(); };
pauseBtn.onclick = () => { (AC_enabled && AC_buf) ? pauseAccurate() : audioEl.pause(); };

// Spacebar toggles play/pause when not typing in an input field
window.addEventListener("keydown", (e) => {
  if (e.code === 'Space' || e.keyCode === 32) {
    const ae = document.activeElement;
    const tag = ae && ae.tagName ? ae.tagName.toUpperCase() : "";
    if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || (ae && ae.isContentEditable)) return;
    e.preventDefault();
    if (isPlaying()) {
      if (AC_enabled && AC_buf) pauseAccurate(); else audioEl.pause();
    } else {
      if (AC_enabled && AC_buf) playAccurate(); else audioEl.play();
    }
  }
}, {passive:false});

audioEl.addEventListener("timeupdate", ()=>{
  const t = qms(audioEl.currentTime || 0);
  applyStyleEvents(t);
  curTimeEl.textContent = t.toFixed(3);
  window.getPreviewNowSec = () => t;
  const bi=beatInfoAt(t);
  curBeatEl.textContent = bi.valid?bi.text:"-";
  drawWave();
});

function setWaveControlsEnabled(on=true){
  [playBtn, pauseBtn, undoBtn, redoBtn, zoomInBtn, zoomOutBtn, fitBtn].forEach(b=>{
    if (b) b.disabled = !on;
  });
}


ampScaleInput.addEventListener("input",(e)=>{ ampScale=parseFloat(e.target.value||"0.6")||0.6; drawWave(); });

// 별도 RAF 루프 (안정화)
let rafId = null;
function tick() { drawWave(); rafId = requestAnimationFrame(tick); }
audioEl.addEventListener("play", () => { if (rafId) cancelAnimationFrame(rafId); tick(); });
audioEl.addEventListener("pause", () => {
  const t = qms(audioEl.currentTime || 0);
  previewTimeSec = t;
  curTimeEl.textContent = t.toFixed(3);
  window.getPreviewNowSec = () => t;
  redrawBeat();
  drawWave();
});

audioEl.addEventListener("ended", () => { if (rafId) cancelAnimationFrame(rafId); rafId = null; drawWave(); });

function getDuration(){
  return (audioEl?.duration || 0)
      || (AC_buf?.duration || 0)
      || (audioBuffer?.duration || 0)
      || 0;
}

// History buttons updater and wiring
function updateHistoryButtons(){
  try{
    if (typeof undoBtn !== 'undefined' && undoBtn) undoBtn.disabled = undoStack.length <= 1;
    if (typeof redoBtn !== 'undefined' && redoBtn) redoBtn.disabled = redoStack.length === 0;
  }catch(e){}
}

if (typeof undoBtn !== 'undefined' && undoBtn){ undoBtn.addEventListener('click', ()=>{ undo(); updateHistoryButtons(); }); }
if (typeof redoBtn !== 'undefined' && redoBtn){ redoBtn.addEventListener('click', ()=>{ redo(); updateHistoryButtons(); }); }

// Ensure initial state
updateHistoryButtons();
function ensureViewBounds(){
  const D = getDuration();
  if (D <= 0){ viewStart = 0; viewEnd = 0; return; }

  const spanMin = Math.max(MIN_VIEW_SPAN_SEC, 0.001);
  let span = viewEnd - viewStart;

  if (span < spanMin){
    const c = (viewStart + viewEnd) / 2;
    viewStart = Math.max(0, c - spanMin/2);
    viewEnd   = Math.min(D, c + spanMin/2);
    span      = viewEnd - viewStart;
  }
  if (viewStart < 0){ viewEnd -= viewStart; viewStart = 0; }
  if (viewEnd > D){
    const over = viewEnd - D;
    viewStart = Math.max(0, viewStart - over);
    viewEnd   = D;
  }
}
function timeToX(t){ const span=(viewEnd-viewStart)||1; return ((t-viewStart)/span)*waveCanvas.clientWidth; }
function xToTime(x){ const span=(viewEnd-viewStart)||1; return viewStart+(x/waveCanvas.clientWidth)*span; }

zoomInBtn.onclick = () => {
  const c = (typeof getPreviewNowSec === "function") ? getPreviewNowSec()
            : (audioEl.currentTime || (viewStart+viewEnd)/2);
  zoomAt(c, 0.7);
};
zoomOutBtn.onclick = () => {
  const c = (typeof getPreviewNowSec === "function") ? getPreviewNowSec()
            : (audioEl.currentTime || (viewStart+viewEnd)/2);
  zoomAt(c, 1.4);
};
fitBtn.onclick = () => { const D = getDuration(); viewStart=0; viewEnd=D; drawWave(); };
function zoomAt(c, f){
  const D = getDuration(); if (D <= 0) return;
  const span   = (viewEnd - viewStart) || D;
  const ns     = clamp(span * f, MIN_VIEW_SPAN_SEC, D);
  const lr     = (c - viewStart) / span;

  viewStart = c - ns * lr;
  viewEnd   = viewStart + ns;

  ensureViewBounds();
  drawWave();
}

let waveHover = false;
waveCanvas.addEventListener("mouseenter", ()=> waveHover = true);
waveCanvas.addEventListener("mouseleave", ()=> waveHover = false);

window.addEventListener("keydown", (e)=>{
  // 텍스트 입력 중엔 무시
  const tag = (document.activeElement && document.activeElement.tagName) || "";
  if (tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT" || (document.activeElement && document.activeElement.isContentEditable)) return;

  // Undo/Redo: Ctrl+Z / Ctrl+Y (or Ctrl+Shift+Z)
  if ((e.ctrlKey || e.metaKey) && (e.key === 'z' || e.key === 'Z')){
    e.preventDefault();
    if (e.shiftKey) { redo(); } else { undo(); }
    return;
  }
  if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || e.key === 'Y')){
    e.preventDefault(); redo(); return;
  }

if (e.code && e.code.startsWith('Numpad')){
  // prevent default browser scrolling
  try{ e.preventDefault(); }catch(_){}

  // ⭐ Numpad0 → add grid
  if (e.code === 'Numpad0'){
    addGrid();
    return;
  }

  // Numpad1..Numpad9
  const m = e.code.match(/^Numpad([1-9])$/);
  if (m){
    const n = parseInt(m[1],10);
    // 7 8 9 = top row
    // 4 5 6 = middle
    // 1 2 3 = bottom
    const map = {
      7:[0,2],8:[1,2],9:[2,2],
      4:[0,1],5:[1,1],6:[2,1],
      1:[0,0],2:[1,0],3:[2,0]
    };
    const cell = map[n];
    if (cell){
      selectedCell = { c:cell[0], r:cell[1] };
      $("#cellCR").value = `${cell[0]},${cell[1]}`;
      refreshGridActive();
      drawView();
    }
    return;
  }

  // NumpadAdd : cycle cell
  if (e.code === 'NumpadAdd'){
    const idx = selectedCell.c + selectedCell.r * 3;
    const next = (idx + 1) % 9;
    const nc = next % 3;
    const nr = Math.floor(next / 3);
    selectedCell = { c:nc, r:nr };
    $("#cellCR").value = `${nc},${nr}`;
    refreshGridActive();
    drawView();
    return;
  }
}

  // (Numpad0 add shortcut removed — keep only cell selection via Numpad1-9 and NumpadAdd)

  // 좌/우 키만 처리
  if (e.key !== "ArrowLeft" && e.key !== "ArrowRight") return;

  // 슬라이더 편집 충돌 방지: 슬라이더 편집 중이면 Alt 눌렀을 때만 시점이동
  const sliderEditing = ($("#noteType")?.value === "Slider") && (pathPtsAbs?.length > 0);
  if (sliderEditing && !e.altKey) return;

  // 파형 위에서만 동작하게 하거나, Alt 키로 강제 동작
  if (!waveHover && !e.altKey) return;

  const D = getDuration(); if (D <= 0) return;

  // Move preview cursor by snapped subdivision (no panning)
  const bpm = num($("#bpm").value);
  const subdiv = parseInt($("#subdiv").value || "8");
  const spbVal = bpm > 0 ? 60 / bpm : 0;
  const unitSec = (spbVal > 0 && subdiv > 0) ? (spbVal / subdiv) : 0.5;
  const dir = (e.key === "ArrowLeft") ? -1 : +1;
  const cur = (typeof getPreviewNowSec === 'function') ? getPreviewNowSec() : (audioEl.currentTime || 0);
  const target = Math.max(0, Math.min(getDuration(), cur + dir * unitSec));
  // If playing, seek; otherwise move previewTimeSec and refresh
  if (isPlaying()){
    if (typeof seekAccurate === 'function') seekAccurate(target);
    else audioEl.currentTime = target;
  } else {
    previewTimeSec = qms(target);
    curTimeEl.textContent = previewTimeSec.toFixed(3);
    window.getPreviewNowSec = () => previewTimeSec;
    applyStyleEvents(previewTimeSec);
    redrawBeat();
    drawWave();
  }
  e.preventDefault();
});



waveCanvas.addEventListener("click", (e) => {
  if (isPanning || dragSelecting) return;

  const rect = waveCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  const hit = [...waveBlocks].reverse().find(
    b => x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h
  );
  if (hit) {
    startEdit(hit.idx);
    return;
  }

  const dur = getDuration();
  if (dur <= 0) return;

  const t = clamp(snapTime(xToTime(x)), 0, dur);
  applyTimeFromWave(t, null);     // 시킹 + 입력칸 채우기
  const tt = qms(t);

  // 정지 중일 때는 프리뷰 커서도 즉시 갱신
  if (!isPlaying()) {
    previewTimeSec = tt;
    curTimeEl.textContent = tt.toFixed(3);
    window.getPreviewNowSec = () => tt;  // (기존 코드와의 호환용)
    redrawBeat();
    drawWave();
  }
});


waveCanvas.addEventListener("mousemove",(e)=>{
  if(isPanning||dragSelecting) return;
  const rect=waveCanvas.getBoundingClientRect();
  const x=(e.clientX-rect.left), y=(e.clientY-rect.top);
  const hit = waveBlocks.find(b => x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h);
  waveCanvas.style.cursor = hit ? "pointer" : "default";
});



window.addEventListener("mousemove",(e)=>{
  if(isPanning){
    const rect = waveCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const dx = x - dragStartX;
    // use the original span captured at mouse down to avoid span changes causing zoom
    const dt = dx * (dragStartSpan) / Math.max(1, waveCanvas.clientWidth);
    viewStart = dragStartView - dt;
    viewEnd = viewStart + dragStartSpan;
    ensureViewBounds(); drawWave();
  } else if(dragSelecting){
    const rect=waveCanvas.getBoundingClientRect(); const x=e.clientX-rect.left; dragT1=xToTime(x); drawWave();
    const x0=timeToX(Math.min(dragT0,dragT1)), x1=timeToX(Math.max(dragT0,dragT1));
    wctx.fillStyle="rgba(102,217,239,0.15)"; wctx.fillRect(x0,0,x1-x0,waveCanvas.clientHeight);
    wctx.strokeStyle="#66d9ef"; wctx.strokeRect(x0+0.5,0.5,x1-x0-1,waveCanvas.clientHeight-1);
  }
});
window.addEventListener("mouseup",()=>{ if(isPanning) isPanning=false; if(dragSelecting){ dragSelecting=false; const a=Math.min(dragT0,dragT1), b=Math.max(dragT0,dragT1); applyTimeFromWave(a,b); } });

// Wheel: only support Ctrl+Wheel for zoom. Remove wheel-based panning.
waveCanvas.addEventListener("wheel",(e)=>{
  if (e.ctrlKey){
    e.preventDefault();
    const t = xToTime(e.offsetX);
    const f = (e.deltaY < 0) ? 0.9 : 1.1;
    zoomAt(t, f);
  }
  // otherwise ignore wheel to avoid accidental timeline jumps
},{passive:false});

// Mouse drag: left-drag to pan the timeline, Shift+left-drag to select a time range.
waveCanvas.addEventListener("mousedown", (e) => {
  // Only respond to primary button
  if (e.button !== 0) return;
  const rect = waveCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  // If Shift is held, start range selection
  if (e.shiftKey) {
    dragSelecting = true;
    dragT0 = xToTime(x);
    dragT1 = dragT0;
    // prevent text selection
    e.preventDefault();
    drawWave();
    return;
  }

  // Otherwise start panning
  isPanning = true;
  dragStartX = x;
  dragStartView = viewStart;
  dragStartSpan = viewEnd - viewStart;
  // prevent text selection / native drag
  e.preventDefault();
}, {passive:false});



function drawWave(){
  const w=waveCanvas.clientWidth, h=waveCanvas.clientHeight;
  wctx.clearRect(0,0,w,h); wctx.fillStyle="#0b0f1c"; wctx.fillRect(0,0,w,h);
  if(audioBuffer){ drawPeaksRange(wctx,w,h,audioBuffer,viewStart,viewEnd,ampScale); }
  else{ wctx.fillStyle="#9aa4bb"; wctx.fillText("오디오 파일을 선택하세요.", 10, h/2); }
  const bpm=num($("#bpm").value); const duration=getDuration(), offset=computeOffsetSeconds();
  drawTimeGrid(wctx,w,h,viewStart,viewEnd);
  if(bpm>0 && duration>0){ drawBeatGrid(wctx,w,h,viewStart,viewEnd,bpm,offset,parseInt($("#subdiv").value||"8")); }
  // 기존: const t = nowSecQms();
  const t = isPlaying() ? nowSecQms() : qms(previewTimeSec);

  if(t>=viewStart && t<=viewEnd){
    const x=timeToX(t); wctx.strokeStyle="#ffd48a"; wctx.lineWidth=2; wctx.beginPath(); wctx.moveTo(x,0); wctx.lineTo(x,h); wctx.stroke();
    if(audioEl.paused){
      const bi=beatInfoAt(t);
      const label=`${t.toFixed(3)}s | ${bi.valid?bi.text:"-"}`;
      const pad=6, textW=wctx.measureText(label).width, boxW=textW+pad*2, boxH=20;
      let bx=x+8, by=8; if(bx+boxW>w-4) bx=x-8-boxW; if(bx<4) bx=4;
      wctx.fillStyle="rgba(17,32,51,0.9)"; wctx.fillRect(bx,by,boxW,boxH);
      wctx.strokeStyle="#264463"; wctx.strokeRect(bx+0.5,by+0.5,boxW-1,boxH-1);
      wctx.fillStyle="#dfe7ff"; wctx.fillText(label, bx+pad, by+boxH-6);
    }
  }
  drawNoteBlocks();

  // Highlight currently edited/selected note on the waveform
  try{
    if (typeof editIndex === 'number' && editIndex !== null && Array.isArray(waveBlocks)){
      const sel = waveBlocks.filter(b => b.idx === editIndex);
      for (const b of sel){
        // semi-transparent fill
        wctx.save();
        wctx.fillStyle = 'rgba(255,220,100,0.10)';
        wctx.fillRect(b.x, b.y, b.w, b.h);
        wctx.strokeStyle = 'rgba(255,220,100,0.9)';
        wctx.lineWidth = 2;
        wctx.strokeRect(b.x + 0.5, b.y + 0.5, Math.max(1, b.w-1), Math.max(1, b.h-1));
        wctx.restore();
      }
      // If no block drawn (e.g., very narrow), draw a vertical marker at the note time
      if (sel.length === 0 && chart.notes && chart.notes[editIndex]){
        const n = chart.notes[editIndex];
        const t0 = getNoteTimeSec(n);
        if (isFinite(t0) && t0 >= viewStart && t0 <= viewEnd){
          const x = timeToX(t0);
          wctx.save(); wctx.strokeStyle = 'rgba(255,220,100,0.9)'; wctx.lineWidth = 2; wctx.beginPath(); wctx.moveTo(x,0); wctx.lineTo(x,wctx.canvas.height); wctx.stroke(); wctx.restore();
        }
      }
    }
  }catch(err){ /* ignore */ }

}
function drawPeaksRange(ctx, w, h, audioBuffer, t0, t1, ampScale){
  const data = audioBuffer.getChannelData(0);
  const sr   = audioBuffer.sampleRate;

  const centerY = h * 0.5;
  const gain = ampScale * 0.85;

  const span = Math.max(1e-6, t1 - t0);

  // ===== 파형 밀도 제어 =====
  const samplesPerPixel = Math.max(
    32,
    Math.floor((span * sr) / w)
  );
  const xStep = 2;

  /* =================================================
     1) 전체 대역 envelope (참고용, 과하지 않게)
     ================================================= */
  ctx.lineWidth = 1;
  ctx.strokeStyle = "rgba(155,220,255,0.5)";

  for(let x = 0; x < w; x += xStep){
    const base = Math.floor((t0 * sr) + x * samplesPerPixel);
    if(base >= data.length) break;

    let min =  1.0;
    let max = -1.0;

    for(let i = 0; i < samplesPerPixel; i++){
      const v = data[base + i];
      if(v === undefined) break;
      if(v < min) min = v;
      if(v > max) max = v;
    }

    const yMin = centerY - min * centerY * gain;
    const yMax = centerY - max * centerY * gain;

    ctx.beginPath();
    ctx.moveTo(x + 0.5, yMin);
    ctx.lineTo(x + 0.5, yMax);
    ctx.stroke();
  }

  /* =================================================
     2) 저음 강조 overlay (임계 기반, 핵심 부분)
     ================================================= */
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(255,200,120,0.85)";

  // 🔑 저음/킥 강조 임계값
  // 곡에 따라 0.06 ~ 0.12 사이가 적당
  const THRESHOLD = 0.08;

  for(let x = 0; x < w; x += xStep){
    const base = Math.floor((t0 * sr) + x * samplesPerPixel);
    if(base >= data.length) break;

    let sumSq = 0;
    let count = 0;

    for(let i = 0; i < samplesPerPixel; i++){
      const v = data[base + i];
      if(v === undefined) break;
      sumSq += v * v;
      count++;
    }

    if(count === 0) continue;

    // RMS 에너지
    let rms = Math.sqrt(sumSq / count);

    // 🔑 임계 이하 제거 (중요)
    if(rms < THRESHOLD) continue;

    // 임계 초과분만 정규화
    rms = (rms - THRESHOLD) / (1.0 - THRESHOLD);

    const y = centerY - rms * centerY * gain;

    ctx.beginPath();
    ctx.moveTo(x + 0.5, centerY);
    ctx.lineTo(x + 0.5, y);
    ctx.stroke();
  }

  /* =================================================
     중앙 기준선
     ================================================= */
  ctx.lineWidth = 1;
  ctx.strokeStyle = "#334";
  ctx.beginPath();
  ctx.moveTo(0, centerY);
  ctx.lineTo(w, centerY);
  ctx.stroke();
}



function drawTimeGrid(ctx,w,h,vStart,vEnd){
  const span=vEnd-vStart; if(span<=0) return;
  const targetPx=80; const secPerPx=span/w; const raw=targetPx*secPerPx;
  const mag=Math.pow(10,Math.floor(Math.log10(raw))); const cand=[1,2,5,10]; let step=cand[0]*mag;
  for(const c of cand){ const s=c*mag; if(s>=raw){step=s;break;} }
  const startTick=Math.ceil(vStart/step)*step;
  for(let s=startTick;s<=vEnd+1e-6;s+=step){
    const x=timeToX(s); const major=(Math.round(s/step)%5===0);
    ctx.strokeStyle=major?"#2d3653":"#1e2744"; ctx.lineWidth=major?1.5:1;
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
    if(major){ ctx.fillStyle="#9aa4bb"; ctx.fillText(`${s.toFixed(0)}s`, Math.max(2,x+2), 12); }
  }
}
function drawBeatGrid(ctx,w,h,vStart,vEnd,bpm,off,subdiv){
  const spb=60/bpm; const span=vEnd-vStart; const pxPerSec = (span>0)?(w/span):0;
  let bi=Math.floor((vStart-off)/spb)-1;
  for(;;bi++){
    const t=off+bi*spb; if(t>vEnd) break;
    if(t>=vStart){
      const x=timeToX(t); const bar=(bi%4===0);
      // Measure (bar) lines are thicker; quarter-note (beat) lines are thinner
      ctx.strokeStyle = bar ? "#66d9ef" : "#265a6d";
      ctx.lineWidth = bar ? 3 : 1.5;
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
      if(bar){ ctx.fillStyle="#b9c2d9"; ctx.fillText(`M${Math.floor(bi/4)+1}`, Math.max(2,x+2), h-6); }
    }
    if(subdiv && subdiv>1){
      // Skip drawing very dense subdivision lines for performance/clarity
      const subPx = pxPerSec * (spb / subdiv);
      if(subPx < 3) continue;
      for(let k=1;k<subdiv;k++){
        const tk=t+k*spb/subdiv; if(tk<vStart||tk>vEnd) continue;
        const xk=timeToX(tk);
        ctx.strokeStyle="#1e3a4f"; ctx.lineWidth=1;
        ctx.beginPath(); ctx.moveTo(xk,0); ctx.lineTo(xk,h); ctx.stroke();
      }
    }
  }
}

// === Beat/Sec conversion helpers (추가) ===
function spb(){                 // 1 beat = ? sec
  const bpm = num($("#bpm").value);
  return bpm > 0 ? 60 / bpm : 0;
}
function beatsToSec(beats){ return beats * spb(); }
function secToBeats(sec){ const s = spb(); return s>0 ? sec / s : 0; }

// === Lead seconds resolver (추가) ===
// Circle/Slider 리드는 timeMode에 따라 beats 또는 seconds 해석
function resolveCircleLeadSec(){
  if ($("#timeMode").value === "Beats") {
    const b = num($("#circleLeadBeats").value);
    if (b > 0) return beatsToSec(b);
  }
  return num($("#circleLead").value); // seconds fallback
}
function resolveSliderLeadSec(){
  if ($("#timeMode").value === "Beats") {
    const b = num($("#sliderLeadBeats").value);
    if (b > 0) return beatsToSec(b);
  }
  return num($("#sliderLead").value); // seconds fallback
}

// === Grid grow speed resolver (추가) ===
// gridGrowUnit=pxps → 그대로(px/s)
// gridGrowUnit=pxpbeat → px/s 로 변환(px/beat × BPM/60)
function resolveGridGrowPxPerSec(){
  const grow = num($("#gridGrow").value);
  const unit = $("#gridGrowUnit")?.value || "pxps";
  if (unit === "pxpbeat") {
    const bpm = num($("#bpm").value);
    return grow * (bpm / 60); // px/s
  }
  return grow; // px/s
}

// === Grid 타깃 해석: 모드에 따라 px로 환산 ===
function resolveGridTargetPx(){
  const mode = $("#gridTargetMode")?.value || "px";
  if (mode === "spacingX") return GRID_CELL;  // 216px
  if (mode === "spacingY") return GRID_CELL;  // 216px
  return num($("#gridTarget").value);         // absolute px
}


// === Grid 타깃 해석: 모드에 따라 px로 환산 (추가) ===
function cellToAbsPos(c, r) {
  const centerX = GRID_LEFT + GRID_CELL * (0.5 + c);        // 756, 972, 1188
  const centerY = 1080 - (GRID_TOP  + GRID_CELL * (0.5 + (2 - r)));  // r=0→아래, r=2→위
  return { x: centerX, y: centerY };
}

function beatInfoAt(t){
  const bpm=num($("#bpm").value); if(bpm<=0) return {valid:false,text:"-"};
  const spb=60/bpm, off=computeOffsetSeconds(); const beats=(t-off)/spb;
  const bar=Math.floor(beats/4)+1, inBar=beats-(bar-1)*4, bnum=Math.floor(inBar)+1, frac=inBar-Math.floor(inBar);
  return {valid:true, text:`${beats.toFixed(3)} (M${bar}, B${bnum}${frac>0?`+${frac.toFixed(3)}`:""})`};
}
function computeOffsetSeconds(){
  const bpm=num($("#bpm").value); const byBeats=$("#timeMode").value==="Beats";
  if(byBeats && bpm>0){ const beats=num($("#startOffsetBeats").value); return beats*(60/bpm); }
  return num($("#startOffsetSec").value);
}
function applyTimeFromWave(t0, t1){
  console.debug("[DBG] applyTimeFromWave.in", {t0, t1});
  if (!Number.isFinite(t0)) return;

  const S   = spb();                     // sec per beat
  const off = computeOffsetSeconds();    // chart offset (sec)

  const toBeatsUI = (secPlayback) => (S > 0 ? (secPlayback - off) / S : 0);
  const snap1ms   = (t) => snapTime(t);       // 1ms 양자화

  // ✅ 인자 이름과 본문 변수 통일 (secPlayback 사용)
  function fillSingleTime(secPlayback){
    const typ = $("#noteType").value;
    const secMusical = secPlayback - off;                // UI의 "sec"은 음악적 시각으로 표기
    const secStr     = qms(secMusical).toFixed(3);
    const beatStr    = (S>0 ? snappedBeatsFromSec(secPlayback).toFixed(3) : "0.000");

    if (typ === "Grid") {
      $("#judgeTimeSec").value = secStr;
      if (S>0) $("#judgeBeat").value = beatStr;
    } else if (typ === "CircleTap") {
      $("#circleJudgeSec").value = secStr;
      if (S>0) $("#circleJudgeBeat").value = beatStr;
    } else if (typ === "Slider") {
      $("#sliderStartSec").value = secStr;
      if (S>0) $("#sliderStartBeat").value = beatStr;
    } else if (typ === "Bullet") {
      $("#bulletStartSec").value = secStr;
      if (S>0) $("#bulletStartBeat").value = beatStr;
    } else if (typ === "Camera") {
      $("#camStartSec").value = secStr;
      if (S>0) $("#camStartBeat").value = beatStr;
    }
  }

  function fillRange(secA, secB){
    const aS = snap1ms(Math.min(secA, secB));   // playback sec
    const bS = snap1ms(Math.max(secA, secB));
    const dS = qms(Math.max(0, bS - aS));       // duration in sec (offset 무관)
    const aMus = aS - off;                      // 음악적 시작 sec

    const typ = $("#noteType").value;
    if (typ === "Slider") {
      $("#sliderStartSec").value = aMus.toFixed(3);
      $("#sliderDurSec").value   = dS.toFixed(3);
      if (S>0){
        $("#sliderStartBeat").value = snappedBeatsFromSec(aS).toFixed(3);
        $("#sliderDurBeats").value  = (snappedBeatsFromSec(bS) - snappedBeatsFromSec(aS)).toFixed(3);
      }
    } else if (typ === "Camera") {
      $("#camStartSec").value = aMus.toFixed(3);
      $("#camDurSec").value   = dS.toFixed(3);
      if (S>0){
        $("#camStartBeat").value = qms(toBeatsUI(aS)).toFixed(3);
        $("#camDurBeats").value  = qms(dS / S).toFixed(3);
      }
    } else {
      // 나머지 타입은 단일 시점 → 위 함수 재사용
      fillSingleTime(aS);
    }
    return aS;
  }

  if (t1 == null) {
    const snapped = $("#snap").checked ? snapTime(t0) : qms(t0); // ★
    fillSingleTime(snapped);
    if (typeof seekAccurate === "function") seekAccurate(snapped);
    else audioEl.currentTime = snapped;
  }  else {
  // 구간 스냅: 시작/끝 각각 스냅 → 시작으로 시킹
  const a = $("#snap").checked ? snapTime(Math.min(t0, t1)) : qms(Math.min(t0, t1));
  const b = $("#snap").checked ? snapTime(Math.max(t0, t1)) : qms(Math.max(t0, t1));
  const startSec = fillRange(a, b);
  if (typeof seekAccurate === "function") seekAccurate(startSec);
  else audioEl.currentTime = startSec;
  }


  redrawBeat();
  drawWave();
}
function snapTime(t){
  if (!$("#snap").checked) return t;

  const bpm = num($("#bpm").value);
  if (bpm <= 0) return t;

  const subdiv = parseInt($("#subdiv").value || "8");
  const spb    = 60 / bpm;                 // seconds per beat
  const off    = computeOffsetSeconds();

  // 현재 시간을 오프셋 기준 비트 좌표로 옮김
  const relBeats = (t - off) / spb;

  // ★정수 격자(k/subdiv)에 스냅 (부동소수 출력 없음)
  const k = Math.round(relBeats * subdiv); // integer grid index
  const snappedSec = off + (k * spb) / subdiv;

  return snappedSec; // 절대초(플레이백 좌표)
}
function redrawBeat(){
  // 재생 중이든, pause 중이든 “프리뷰 커서”가 있으면 그걸 우선 사용
  const t = (typeof getPreviewNowSec === "function")
              ? getPreviewNowSec()
              : (audioEl.currentTime || 0);

  const bi = beatInfoAt(t);
  curBeatEl.textContent = bi.valid ? bi.text : "-";
}

function snappedBeatsFromSec(secPlayback){
  const bpm = num($("#bpm").value);
  const spb = (bpm > 0) ? 60 / bpm : 0;
  const off = computeOffsetSeconds();
  const subdiv = parseInt($("#subdiv").value || "8");
  if (spb <= 0 || subdiv <= 0) return 0;

  // sec → 비트 좌표 → k 정수 → k/subdiv 로 복원
  const rel = (secPlayback - off) / spb;
  const k   = Math.round(rel * subdiv);
  return k / subdiv; // 정확한 비트(분수)
}

const rateSelect = $("#playbackRate");

// 일부 브라우저는 피치 보존 플래그가 다릅니다.
function applyPreservePitch(audio, on=true){
  try {
    if ('preservesPitch' in audio) audio.preservesPitch = on;
    if ('mozPreservesPitch' in audio) audio.mozPreservesPitch = on;
    if ('webkitPreservesPitch' in audio) audio.webkitPreservesPitch = on;
  } catch {}
}
// === [CAMERA PREVIEW] helpers: badge, label, guides ===========================
function camLabel(n, t0, t1){
  const parts = [];
  if (n.camAffectHeight) parts.push(`H=${Math.round(n.camHeightPx)}px`);
  if (n.camAffectAngle)  parts.push(`A=${fmt(n.camAngleDegZ)}°`);
  if (n.camAffectCenter) parts.push(`C=(${Math.round(n.camCenterPx?.x||960)},${Math.round(n.camCenterPx?.y||540)})`);
  const ease = (n.camEase && n.camEase.length) ? ` | ${n.camEase}` : "";
  return `CAM ${parts.join(" · ")}  |  ${fmt(t0)}→${fmt(t1)}s${ease}`;
}

function drawBadge(ctx, x, y, text, prog=NaN, maxW=300){
  ctx.save();
  ctx.font = "12px system-ui, sans-serif";
  const padX = 8, padY = 6;
  const textW = Math.min(ctx.measureText(text).width, maxW - padX*2);
  const w = textW + padX*2, h = 22;
  // 배경
  ctx.fillStyle = "rgba(17,32,51,0.92)";
  ctx.strokeStyle = "#264463";
  ctx.lineWidth = 1;
  roundRect(ctx, x, y, w, h, 6, true, true);
  // 텍스트 (overflow 시 잘라서 표시)
  ctx.save();
  ctx.beginPath(); ctx.rect(x+padX, y, w-padX*2, h); ctx.clip();
  ctx.fillStyle = "#dfe7ff";
  ctx.fillText(text, x+padX, y + h - 7);
  ctx.restore();
  // 진행바
  if (!isNaN(prog)){
    const barY = y + h - 3, barH = 2, barW = w - 2;
    ctx.fillStyle = "#1b2f47"; ctx.fillRect(x+1, barY, barW, barH);
    ctx.fillStyle = "#66d9ef"; ctx.fillRect(x+1, barY, Math.max(0, Math.min(barW, barW*prog)), barH);
  }
  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r, fill, stroke){
  if (w<2*r) r=w/2; if (h<2*r) r=h/2;
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y,   x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x,   y+h, r);
  ctx.arcTo(x,   y+h, x,   y,   r);
  ctx.arcTo(x,   y,   x+w, y,   r);
  if (fill) ctx.fill(); if (stroke) ctx.stroke();
}

// (옵션) 센터 가이드 크로스헤어
function drawCenterGuide(ctx, abs, sizePx=28){
  const a = toCXabs(abs);
  const s = (getAR().w / REF_W);
  const half = sizePx * 0.5 * s;
  ctx.save();
  ctx.strokeStyle = "rgba(147,197,253,0.9)";
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(a.x-half, a.y); ctx.lineTo(a.x+half, a.y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(a.x, a.y-half); ctx.lineTo(a.x, a.y+half); ctx.stroke();
  ctx.restore();
}

// === [CAMERA PREVIEW] renderer ===============================================
function drawCameraBadges(nowSec){
  const ar = getAR();
  const PAD = 8, maxW = Math.min(360, ar.w * 0.6);
  let row = 0;

  for (const n of chart.notes){
    if (n.type !== "Camera") continue;

    const t0 = getCameraStartSec(n);
    const d  = Math.max(0, getCameraDurSec(n));
    const t1 = t0 + d;

    // 약간의 패드로 근처에서도 보이게
    if (nowSec < t0 - 0.2 || nowSec > t1 + 0.2) continue;

    const prog = (d > 1e-6) ? clamp01((nowSec - t0) / d) : 1.0;
    const text = camLabel(n, t0, t1);

    // 상단 좌측부터 여러 개면 스택
    const x = ar.x + PAD;
    const y = ar.y + PAD + row * 26; // 배지 높이(22) + 간격(4)
    drawBadge(ctx, x, y, text, prog, maxW);
    if (n.camAffectCenter && n.camCenterPx) {
      drawCenterGuide(ctx, n.camCenterPx);
    }
    row++;
  }
}

function offsetSec(){ return computeOffsetSeconds() || 0; }

function chartTimeToPlaybackSec({sec=null, beat=null}) {
  const byBeats = ($("#timeMode").value === "Beats");
  const S = spb(); // sec per beat
  const present = v => v != null && isFinite(v);

  // timeMode에 따라 “우선값”을 정하고, 없으면 다른 축을 환산
  let baseSec;
  if (byBeats) {
    if (present(beat)) baseSec = beatsToSec(beat);
    else if (present(sec)) baseSec = sec;
    else baseSec = 0;
  } else {
    if (present(sec)) baseSec = sec;
    else if (present(beat)) baseSec = beatsToSec(beat);
    else baseSec = 0;
  }
  // ★ 오프셋 보정
  return baseSec + offsetSec();
}

function setPlaybackRate(r){
  const rate = (r && isFinite(r)) ? r : 1;
  audioEl.playbackRate = rate;
  // 편집용: 음정은 그대로, 속도만 변경 (가능한 브라우저에서)
  applyPreservePitch(audioEl, true);
  // 필요하면 배속 표기 갱신용 배지 등을 업데이트
  // (예) document.querySelector("#rateBadge")?.textContent = `${rate.toFixed(2)}×`;
}

rateSelect?.addEventListener("change", e => {
  const r = parseFloat(e.target.value) || 1;
  (AC_enabled && AC_buf) ? setRateAccurate(r) : setPlaybackRate(r);
});

// 오디오 로드되면 기본 배속 1.0으로 초기화
audioFileInput.addEventListener("change", ()=>{
  // 파일 설정은 기존 onloadedmetadata에서 처리되므로 여기서는 배속만 초기화
  setPlaybackRate(parseFloat(rateSelect?.value || "1") || 1);
});

// 초기 세팅(페이지 로드 직후)
setPlaybackRate(1);

// --- 1 ms time grid ---
const MS_GRID = 0.001;
const qms = (t) => Math.round(t / MS_GRID) * MS_GRID;    // 최근접 1ms
const qmsFloor = (t) => Math.floor(t / MS_GRID) * MS_GRID;
/* ---------- Utils ---------- */
/* ───────── Camera frame preview ───────── */

// 기본 카메라 상태 (Unity Fixed16x9Camera 기준)
const CAM_BASE = {
  heightPx: 1080,            // orthographicSize = height/2
  angleDegZ: 0,
  centerPx: { x: 960, y: 540 }
};

// 카메라 노트의 시작/지속(초) 환산
function getCameraStartSec(n){
  return chartTimeToPlaybackSec({ sec: n.startTime, beat: n.startBeat });
}
function getCameraDurationSec(n){
  const byBeats = ($("#timeMode").value === "Beats");
  if (byBeats) return isFinite(n.durationBeats) ? beatsToSec(n.durationBeats) : (n.duration || 0);
  return isFinite(n.duration) ? n.duration : (isFinite(n.durationBeats) ? beatsToSec(n.durationBeats) : 0);
}

// nowSec 시점의 카메라 상태를 순차 시뮬로 계산 (이벤트 체이닝 반영)
function computeCameraState(nowSec){
  let h = CAM_BASE.heightPx;
  let a = CAM_BASE.angleDegZ;
  let c = { ...CAM_BASE.centerPx };

  // 카메라 노트만 추출 후 시작시간 오름차순
  const cams = (chart.notes || []).filter(n => n.type === "Camera")
    .map(n => ({ n, t0: getCameraStartSec(n), dur: Math.max(0, getCameraDurationSec(n)) }))
    .sort((x,y)=> x.t0 - y.t0);

  // 이징(간단 버전)
  const easeFn = (name) => {
    name = (name || "").toLowerCase();
    if (name.includes("inout")) {
      return t => (t<0.5)? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;
    }
    return t => t; // Linear
  };

  for (const it of cams){
    const n = it.n, t0 = it.t0, d = it.dur, t1 = t0 + d;
    const eh = !!n.camAffectHeight, ea = !!n.camAffectAngle, ec = !!n.camAffectCenter;
    const toH = isFinite(n.camHeightPx) && n.camHeightPx>0 ? n.camHeightPx : h;
    const toA = isFinite(n.camAngleDegZ) ? n.camAngleDegZ : a;
    const toC = (n.camCenterPx && isFinite(n.camCenterPx.x) && isFinite(n.camCenterPx.y)) ? n.camCenterPx : c;
    const ease = easeFn(n.camEase);

    if (nowSec < t0) break;             // 아직 시작 전 → 현 상태 반환
    if (d <= 1e-6 || nowSec >= t1){     // 즉시/완료 상태 → 목표로 스냅
      if (eh) h = toH;
      if (ea) a = toA;
      if (ec) c = { x: toC.x, y: toC.y };
      continue;
    }
    // 진행 중이면 보간 후 바로 반환
    const r = ease(clamp01((nowSec - t0) / d));
    const H = eh ? (h + (toH - h) * r) : h;
    const A = ea ? (a + (toA - a) * r) : a;
    const C = ec ? { x: c.x + (toC.x - c.x) * r, y: c.y + (toC.y - c.y) * r } : c;
    return { heightPx: H, angleDegZ: A, centerPx: C };
  }

  return { heightPx: h, angleDegZ: a, centerPx: c };
}

// 회전 사각형(절대 px) 테두리만 그리기
function drawRotatedRectAbs(ctx, centerAbs, widthPx, heightPx, angleDeg, stroke="#ffd48a", lineW=2, dash=[6,4]){
  const s = (getAR().w / REF_W);              // px → 캔버스 스케일
  const cx = toCXabs(centerAbs).x;
  const cy = toCXabs(centerAbs).y;
  const w = widthPx * s, h = heightPx * s;
  const r = (angleDeg || 0) * Math.PI/180;

  // 사각형 4꼭짓점(로컬 → 회전 → 월드)
  const pts = [
    {x: -w/2, y: -h/2},
    {x:  w/2, y: -h/2},
    {x:  w/2, y:  h/2},
    {x: -w/2, y:  h/2},
  ].map(p => {
    const xr = p.x * Math.cos(r) - p.y * Math.sin(r) + cx;
    const yr = p.x * Math.sin(r) + p.y * Math.cos(r) + cy;
    return {x:xr, y:yr};
  });

  ctx.save();
  ctx.lineWidth = lineW;
  ctx.strokeStyle = stroke;
  if (dash) ctx.setLineDash(dash);
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}

// 미니 배지(선택)
function drawCamBadge(ctx, text, px, py){
  ctx.save();
  ctx.font = "12px system-ui, sans-serif";
  const pad = 6;
  const w = ctx.measureText(text).width + pad*2;
  const h = 20;
  ctx.fillStyle = "rgba(17,32,51,0.9)";
  ctx.fillRect(px, py, w, h);
  ctx.strokeStyle = "#264463";
  ctx.strokeRect(px+0.5, py+0.5, w-1, h-1);
  ctx.fillStyle = "#dfe7ff";
  ctx.fillText(text, px+pad, py+h-6);
  ctx.restore();
}

// 현재 시점 nowSec의 카메라 프레임을 그리기
function drawCameraFrame(nowSec){
  const show = document.querySelector("#showCamFrame")?.checked ?? true;
  if (!show) return;

  const st = computeCameraState(nowSec);
  const height = Math.max(1, st.heightPx);
  const width  = height * (16/9);        // Fixed16x9Camera 기준

  // 테두리
  drawRotatedRectAbs(ctx, st.centerPx, width, height, st.angleDegZ, "#ffd48a", 2, [8,5]);

  // 미니 배지 (좌상단)
  const label = `CAM ${Math.round(width)}×${Math.round(height)} @ (${Math.round(st.centerPx.x)},${Math.round(st.centerPx.y)})  rot ${Math.round(st.angleDegZ)}°`;
  drawCamBadge(ctx, label, 10, 10);
}

let rafAcc = null, accTimer = null;

function scheduleAccurateUiLoop(){
  // 1) RAF가 돌고 있지 않으면 시작
  if (!rafAcc){
    const step = () => {
      rafAcc = null;
      try { syncUiAccurate(); } catch(e){ console.error("[syncUiAccurate]", e); }
      if (AC_src) rafAcc = requestAnimationFrame(step);
    };
    rafAcc = requestAnimationFrame(step);
  }
  // 2) 혹시 백그라운드 탭 등으로 RAF가 멈출 수 있으니 30Hz 폴백
  if (!accTimer){
    accTimer = setInterval(()=>{
      try { syncUiAccurate(); } catch(e){ console.error("[syncUiAccurate-interval]", e); }
      if (!AC_src){ clearInterval(accTimer); accTimer = null; }
    }, 33);
  }
}

function stopAccurate(){
  if (AC_src){
    try { AC_src.stop(); } catch {}
    try { AC_src.disconnect(); } catch {}
  }
  AC_src = null;
  if (rafAcc){ cancelAnimationFrame(rafAcc); rafAcc = null; }
  if (accTimer){ clearInterval(accTimer); accTimer = null; }
}

function num(v){ const x=parseFloat(v||"0"); return isNaN(x)?0:x; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function r3(v){ return Math.round(v*1000)/1000; }
function fmt(v){ return (v==null)?"-":r3(v); }
function parseAbsXY(s,def){ const [xs,ys]=(s||def).split(","); return {x:clamp(parseFloat(xs||"960"),0,REF_W), y:clamp(parseFloat(ys||"540"),0,REF_H)}; }

/* ---------- Slider 포인트 리스트 UI ---------- */
(function(){
  const listBox = document.querySelector("#sliderPointList");
  const idxInput = document.querySelector("#ptIndex");
  const xyInput  = document.querySelector("#ptXY");
  if(!listBox || !idxInput || !xyInput) return;

  const getSel = () => Math.max(0, Math.min((pathPtsAbs?.length||1)-1, parseInt(idxInput.value||"0")));
  const setSel = (i) => { idxInput.value = String(Math.max(0, Math.min((pathPtsAbs?.length||1)-1, i))); syncXYFromSel(); renderPointList(); drawView(); };
  function syncXYFromSel(){
    const i = getSel(); const p = pathPtsAbs?.[i];
    if(p) xyInput.value = `${Math.round(p.x)},${Math.round(p.y)}`;
  }

  window.renderPointList = function renderPointList(){
    if(!listBox) return;
    const sel = getSel();
    if(!pathPtsAbs || pathPtsAbs.length===0){
      listBox.innerHTML = '<div class="muted">(no points)</div>';
      return;
    }
    let html = "";
    pathPtsAbs.forEach((p,i)=>{
      const active = (i===sel) ? "active" : "";
      html += `
        <div class="ptrow ${active}" data-i="${i}" style="display:flex;gap:8px;align-items:center;padding:4px 6px;">
          <span class="pill">${i}</span>
          <span>(${Math.round(p.x)}, ${Math.round(p.y)})</span>
          <span style="margin-left:auto;display:flex;gap:6px">
            <button type="button" data-act="sel"  data-i="${i}">Sel</button>
            <button type="button" data-act="edit" data-i="${i}">Edit</button>
          </span>
        </div>`;
    });
    listBox.innerHTML = html;

    listBox.onclick = (e)=>{
      const btn = e.target.closest("button");
      const row = e.target.closest(".ptrow");
      if(btn){
        const act = btn.dataset.act;
        const i   = parseInt(btn.dataset.i,10);
        if(Number.isFinite(i)){
          if(act==="sel"){ setSel(i); }
          else if(act==="edit"){ setSel(i); xyInput.value = `${Math.round(pathPtsAbs[i].x)},${Math.round(pathPtsAbs[i].y)}`; }
        }
      }else if(row){
        const i = parseInt(row.dataset.i,10);
        if(Number.isFinite(i)) setSel(i);
      }
    };
  };

  document.querySelector("#ptPrevBtn")?.addEventListener("click", ()=> setSel(getSel()-1));
  document.querySelector("#ptNextBtn")?.addEventListener("click", ()=> setSel(getSel()+1));

  xyInput.addEventListener("keydown", (e)=>{
    if(e.key === "Enter"){
      const i = getSel();
      const [xs,ys] = (xyInput.value||"960,540").split(",");
      const x = clamp(parseFloat(xs||"960"),0,REF_W);
      const y = clamp(parseFloat(ys||"540"),0,REF_H);
      if(!pathPtsAbs || pathPtsAbs.length===0){
        pathPtsAbs.push({x,y});
      }else{
        pathPtsAbs[i] = {x,y};
      }
      renderPointList(); drawView();
    }
  });

  window.addEventListener("keydown", (e)=>{
    if(document.querySelector("#noteType")?.value !== "Slider") return;
    if(!pathPtsAbs || pathPtsAbs.length===0) return;
    let i = getSel();
    const step = e.shiftKey ? 20 : 5;
    let moved = false;

    if(e.key==="ArrowLeft"){ pathPtsAbs[i].x = clamp(pathPtsAbs[i].x - step, 0, REF_W); moved=true; }
    if(e.key==="ArrowRight"){ pathPtsAbs[i].x = clamp(pathPtsAbs[i].x + step, 0, REF_W); moved=true; }
    if(e.key==="ArrowUp"){ pathPtsAbs[i].y = clamp(pathPtsAbs[i].y + step, 0, REF_H); moved=true; }
    if(e.key==="ArrowDown"){ pathPtsAbs[i].y = clamp(pathPtsAbs[i].y - step, 0, REF_H); moved=true; }
    if(moved){
      xyInput.value = `${Math.round(pathPtsAbs[i].x)},${Math.round(pathPtsAbs[i].y)}`;
      renderPointList(); drawView();
      e.preventDefault();
    }

    if(e.key==="PageUp"){ setSel(i-1); e.preventDefault(); }
    if(e.key==="PageDown"){ setSel(i+1); e.preventDefault(); }
  });

  renderPointList();
})();

// Clear All
function clearAll(){ chart.notes=[]; renderNotes(); drawView(); pushHistory(); }

/* ---------- Init ---------- */
function firstLayout(){
  const rect=view.getBoundingClientRect();
  const dpr=window.devicePixelRatio||1;
  view.width=Math.floor(rect.width*dpr);
  view.height=Math.floor(rect.width*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);

  buildGrid();
  // ★ 테이블 먼저
  renderNotes();
  // 그 다음 그리기들
  drawView();
  resizeWaveCanvas();
  updateBulletStageLabel();

  // (선택) 스타일 스케줄 초기화
  if (typeof buildStyleSchedule==="function"){ buildStyleSchedule(); resetStyleCursor(0); }
}

window.addEventListener("load", firstLayout);
setInterval(drawView, 100);
</script>
</body>
</html>











